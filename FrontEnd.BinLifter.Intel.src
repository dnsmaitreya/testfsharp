Intel.fs
//这段代码定义了Intel体系结构的指令翻译上下文和寄存器仓库:
//- IntelTranslationContext实现了翻译上下文,重写了寄存器访问方法
//- 继承自TranslationContext,内含RegExprs
//- Basis模块提供初始化方法:
//  - init返回翻译上下文和寄存器仓库
//  - initRegBay只返回寄存器仓库
//主要功能:
//1. 实现Intel特定的翻译上下文
//2. 重写翻译上下文对寄存器的访问
//3. 提供初始化方法生成上下文和仓库
//4. 将上下文和仓库解耦,可单独使用
//优点:
//1. 统一了Intel指令的翻译环境
//2. 隐藏了具体寄存器访问细节 
//3. 简化了后续使用的初始化步骤
//4. 提高了代码的复用性和可扩展性
//它针对Intel实现了专属的翻译组件,统一管理Intel指令的翻译环境。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.FrontEnd.BinLifter

/// Translation context for Intel (x86 or x86-64) instructions.
type IntelTranslationContext internal (isa, regexprs) =
  inherit TranslationContext (isa)
  /// Register expressions.
  member val private RegExprs: RegExprs = regexprs
  override __.GetRegVar id = Register.ofRegID id |> __.RegExprs.GetRegVar
  override __.GetPseudoRegVar id pos =
    __.RegExprs.GetPseudoRegVar (Register.ofRegID id ) pos

module Basis =
  let init (isa: ISA) =
    let regexprs = RegExprs (isa.WordSize)
    struct (
      IntelTranslationContext (isa, regexprs) :> TranslationContext,
      IntelRegisterBay (isa.WordSize, regexprs) :> RegisterBay
    )

  let initRegBay wordSize =
    let regexprs = RegExprs (wordSize)
    IntelRegisterBay (wordSize, regexprs) :> RegisterBay

// vim: set tw=80 sts=2 sw=2:

IntelAVXLifter.fs
//这个模块实现了AVX指令集相关多媒体/SIMD指令的翻译逻辑。
//主要功能点:
//1. 定义YMM/ZMM重组寄存器和操作的翻译函数。
//2. AVX操作数多元组打包和解包处理。 
//3. 每个具体AVX指令的翻译实现函数。
//4. 提供公用函数生成AVX指令中间代码。
//翻译流程:
//1. 解析/翻译AVX操作数获取中间表示。
//2. 调用具体实现函数完成SIMD指令语义。
//3. 多元组打包解包处理向量数据。
//4. 返回翻译结果的IRBuilder。
//它给上层提供了AVX指令集统一翻译接口。
//与通用/SSE模块配合,完成x86多媒体指令翻译任务。
//是AVX体系结构翻译不可或缺的重要组成部分。

module internal B2R2.FrontEnd.BinLifter.Intel.AVXLifter

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel.MMXLifter

let private haveEVEXPrx = function
  | Some v -> Option.isSome v.EVEXPrx
  | None -> false

let private r128to256 = function
  | OprReg R.XMM0 -> R.YMM0
  | OprReg R.XMM1 -> R.YMM1
  | OprReg R.XMM2 -> R.YMM2
  | OprReg R.XMM3 -> R.YMM3
  | OprReg R.XMM4 -> R.YMM4
  | OprReg R.XMM5 -> R.YMM5
  | OprReg R.XMM6 -> R.YMM6
  | OprReg R.XMM7 -> R.YMM7
  | OprReg R.XMM8 -> R.YMM8
  | OprReg R.XMM9 -> R.YMM9
  | OprReg R.XMM10 -> R.YMM10
  | OprReg R.XMM11 -> R.YMM11
  | OprReg R.XMM12 -> R.YMM12
  | OprReg R.XMM13 -> R.YMM13
  | OprReg R.XMM14 -> R.YMM14
  | OprReg R.XMM15 -> R.YMM15
  | _ -> raise InvalidOperandException

let private r128to512 = function
  | OprReg R.XMM0 -> R.ZMM0
  | OprReg R.XMM1 -> R.ZMM1
  | OprReg R.XMM2 -> R.ZMM2
  | OprReg R.XMM3 -> R.ZMM3
  | OprReg R.XMM4 -> R.ZMM4
  | OprReg R.XMM5 -> R.ZMM5
  | OprReg R.XMM6 -> R.ZMM6
  | OprReg R.XMM7 -> R.ZMM7
  | OprReg R.XMM8 -> R.ZMM8
  | OprReg R.XMM9 -> R.ZMM9
  | OprReg R.XMM10 -> R.ZMM10
  | OprReg R.XMM11 -> R.ZMM11
  | OprReg R.XMM12 -> R.ZMM12
  | OprReg R.XMM13 -> R.ZMM13
  | OprReg R.XMM14 -> R.ZMM14
  | OprReg R.XMM15 -> R.ZMM15
  | _ -> raise InvalidOperandException

let private r256to512 = function
  | OprReg R.YMM0 -> R.ZMM0
  | OprReg R.YMM1 -> R.ZMM1
  | OprReg R.YMM2 -> R.ZMM2
  | OprReg R.YMM3 -> R.ZMM3
  | OprReg R.YMM4 -> R.ZMM4
  | OprReg R.YMM5 -> R.ZMM5
  | OprReg R.YMM6 -> R.ZMM6
  | OprReg R.YMM7 -> R.ZMM7
  | OprReg R.YMM8 -> R.ZMM8
  | OprReg R.YMM9 -> R.ZMM9
  | OprReg R.YMM10 -> R.ZMM10
  | OprReg R.YMM11 -> R.ZMM11
  | OprReg R.YMM12 -> R.ZMM12
  | OprReg R.YMM13 -> R.ZMM13
  | OprReg R.YMM14 -> R.ZMM14
  | OprReg R.YMM15 -> R.ZMM15
  | _ -> raise InvalidOperandException

let private fillZeroHigh128 ctxt dst ir =
  let dst = r128to256 dst
  let dstC, dstD = getPseudoRegVar ctxt dst 3, getPseudoRegVar ctxt dst 4
  let n0 = AST.num0 64<rt>
  !!ir (dstC := n0)
  !!ir (dstD := n0)

let private fillZeroHigh256 ctxt dst ir =
  let dst = r256to512 dst
  let dstE, dstF, dstG, dstH =
    getPseudoRegVar ctxt dst 3, getPseudoRegVar ctxt dst 4,
    getPseudoRegVar ctxt dst 5, getPseudoRegVar ctxt dst 6
  let n0 = AST.num0 64<rt>
  !!ir (dstE := n0)
  !!ir (dstF := n0)
  !!ir (dstG := n0)
  !!ir (dstH := n0)

let private vexedPackedFPBinOp32 ins insLen ctxt op =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2) = getThreeOprs ins
  let oprSz = getOperationSize ins
  let do32PackedOp dst64 src1 src2 ir =
    let dstA, dstB = AST.xtlo 32<rt> dst64, AST.xthi 32<rt> dst64
    let src1A, src1B = AST.xtlo 32<rt> src1, AST.xthi 32<rt> src1
    let src2A, src2B = AST.xtlo 32<rt> src2, AST.xthi 32<rt> src2
    !!ir (dstA := op src1A src2A)
    !!ir (dstB := op src1B src2B)
  !<ir insLen
  match oprSz with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    do32PackedOp dst1 src1A src2A ir
    do32PackedOp dst2 src1B src2B ir
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let sr1D, sr1C, sr1B, sr1A = transOprToExpr256 ins insLen ctxt src1
    let sr2D, sr2C, sr2B, sr2A = transOprToExpr256 ins insLen ctxt src2
    do32PackedOp dst1 sr1A sr2A ir
    do32PackedOp dst2 sr1B sr2B ir
    do32PackedOp dst3 sr1C sr2C ir
    do32PackedOp dst4 sr1D sr2D ir
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private vexedPackedFPBinOp64 ins insLen ctxt op =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2) = getThreeOprs ins
  let oprSz = getOperationSize ins
  !<ir insLen
  match oprSz with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dst1 := op src1A src2A)
    !!ir (dst2 := op src1B src2B)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let sr1D, sr1C, sr1B, sr1A = transOprToExpr256 ins insLen ctxt src1
    let sr2D, sr2C, sr2B, sr2A = transOprToExpr256 ins insLen ctxt src2
    !!ir (dst1 := op sr1A sr2A)
    !!ir (dst2 := op sr1B sr2B)
    !!ir (dst3 := op sr1C sr2C)
    !!ir (dst4 := op sr1D sr2D)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private vexedScalarFPBinOp ins insLen ctxt sz op =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  !<ir insLen
  match sz with
  | 32<rt> ->
    let src2 = transOprToExpr32 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dst1 := op (AST.xtlo 32<rt> src1A) src2)
    !!ir (AST.xthi 32<rt> dst1 := AST.xthi 32<rt> src1A)
  | 64<rt> ->
    let src2 = transOprToExpr64 ins insLen ctxt src2
    !!ir (dst1 := op src1A src2)
  | _ -> raise InvalidOperandSizeException
  !!ir (dst2 := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vsqrtps ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  let oprSz = getOperationSize ins
  let do32PackedSqrt dst64 src ir =
    let dstA, dstB = AST.xtlo 32<rt> dst64, AST.xthi 32<rt> dst64
    let srcA, srcB = AST.xtlo 32<rt> src, AST.xthi 32<rt> src
    !!ir (dstA := AST.fsqrt srcA)
    !!ir (dstB := AST.fsqrt srcB)
  !<ir insLen
  match oprSz with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    do32PackedSqrt dst1 srcA ir
    do32PackedSqrt dst2 srcB ir
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let srD, srC, srB, srA = transOprToExpr256 ins insLen ctxt src
    do32PackedSqrt dst1 srA  ir
    do32PackedSqrt dst2 srB  ir
    do32PackedSqrt dst3 srC  ir
    do32PackedSqrt dst4 srD  ir
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vsqrtpd ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  let oprSz = getOperationSize ins
  !<ir insLen
  match oprSz with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src2, src1 = transOprToExpr128 ins insLen ctxt src
    !!ir (dst1 := AST.fsqrt src1)
    !!ir (dst2 := AST.fsqrt src2)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let sr4, sr3, sr2, sr1 = transOprToExpr256 ins insLen ctxt src
    !!ir (dst1 := AST.fsqrt sr1)
    !!ir (dst2 := AST.fsqrt sr2)
    !!ir (dst3 := AST.fsqrt sr3)
    !!ir (dst4 := AST.fsqrt sr4)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private vsqrts ins insLen ctxt sz =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  !<ir insLen
  match sz with
  | 32<rt> ->
    let src2 = transOprToExpr32 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dst1 := AST.fsqrt src2)
    !!ir (AST.xthi 32<rt> dst1 := AST.xthi 32<rt> src1A)
  | 64<rt> ->
    let src2 = transOprToExpr64 ins insLen ctxt src2
    !!ir (dst1 := AST.fsqrt src2)
  | _ -> raise InvalidOperandSizeException
  !!ir (dst2 := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vsqrtss ins insLen ctxt =
  vsqrts ins insLen ctxt 32<rt>

let vsqrtsd ins insLen ctxt =
  vsqrts ins insLen ctxt 64<rt>

let vaddps ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen
  | _ -> vexedPackedFPBinOp32 ins insLen ctxt AST.fadd

let vaddpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt AST.fadd

let vaddss ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 32<rt> AST.fadd

let vaddsd ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 64<rt> AST.fadd

let vsubps ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen
  | _ -> vexedPackedFPBinOp32 ins insLen ctxt AST.fsub

let vsubpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt AST.fsub

let vsubss ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 32<rt> AST.fsub

let vsubsd ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 64<rt> AST.fsub

let vmulps ins insLen ctxt =
  vexedPackedFPBinOp32 ins insLen ctxt AST.fmul

let vmulpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt AST.fmul

let vmulss ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 32<rt> AST.fmul

let vmulsd ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 64<rt> AST.fmul

let vdivps ins insLen ctxt =
  vexedPackedFPBinOp32 ins insLen ctxt AST.fdiv

let vdivpd ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen (* FIXME: #196 *)
  | _ -> vexedPackedFPBinOp64 ins insLen ctxt AST.fdiv

let vdivss ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 32<rt> AST.fdiv

let vdivsd ins insLen ctxt =
  vexedScalarFPBinOp ins insLen ctxt 64<rt> AST.fdiv

let vcvtsi2ss ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB , dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let src2 = transOprToExpr ins insLen ctxt src2
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dstA := AST.cast CastKind.IntToFloat 32<rt> src2)
  !!ir (AST.xthi 32<rt> dstA := AST.xthi 32<rt> src1A)
  !!ir (dstB := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vcvtsi2sd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB , dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
  let src2 = transOprToExpr ins insLen ctxt src2
  !<ir insLen
  !!ir (dstA := AST.cast CastKind.IntToFloat 64<rt> src2)
  !!ir (dstB := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vcvtsd2ss ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let src2 = transOprToExpr64 ins insLen ctxt src2
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dstA := AST.cast CastKind.FloatCast 32<rt> src2)
  !!ir (AST.xthi 32<rt> dstA := AST.xthi 32<rt> src1A)
  !!ir (dstB := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vcvtss2sd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
  let src2 = transOprToExpr32 ins insLen ctxt src2
  !<ir insLen
  !!ir (dstA := AST.cast CastKind.FloatCast 64<rt> src2)
  !!ir (dstB := src1B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let private getEVEXPrx = function
  | Some v -> match v.EVEXPrx with
              | Some ev -> ev
              | None -> Utils.impossible ()
  | None -> Utils.impossible ()

let private buildVectorMove ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  !<ir insLen
  if oprSize = 128<rt> then
    match dst with
    | OprReg _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := srcA)
      !!ir (dstB := srcB)
      fillZeroHigh128 ctxt dst ir
    | OprMem _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := srcA)
      !!ir (dstB := srcB)
    | _ -> raise InvalidOperandException
  elif oprSize = 256<rt> then
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
    !!ir (dstA := srcA)
    !!ir (dstB := srcB)
    !!ir (dstC := srcC)
    !!ir (dstD := srcD)
  elif oprSize = 512<rt> then
    let ePrx = getEVEXPrx ins.VEXInfo
    let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
    let masking dst =
      match ePrx.Z with
      | Zeroing -> AST.num0 32<rt>
      | Merging -> dst
    let cond idx =
      (* no write mask *)
      let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
      AST.extract k 1<rt> idx .| noWritemask
    let kl, vl = 16, 512
    match dst with
    | OprReg _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      let ite i src dst extFn =
        AST.ite (cond i) (extFn 32<rt> src) (masking (extFn 32<rt> dst))
      !!ir (AST.xtlo 32<rt> dstA := ite 0 srcA dstA AST.xtlo)
      !!ir (AST.xthi 32<rt> dstA := ite 1 srcA dstA AST.xthi)
      !!ir (AST.xtlo 32<rt> dstB := ite 2 srcB dstB AST.xtlo)
      !!ir (AST.xthi 32<rt> dstB := ite 3 srcB dstB AST.xthi)
      !!ir (AST.xtlo 32<rt> dstC := ite 4 srcC dstC AST.xtlo)
      !!ir (AST.xthi 32<rt> dstC := ite 5 srcC dstC AST.xthi)
      !!ir (AST.xtlo 32<rt> dstD := ite 6 srcD dstD AST.xtlo)
      !!ir (AST.xthi 32<rt> dstD := ite 7 srcD dstD AST.xthi)
      !!ir (AST.xtlo 32<rt> dstE := ite 8 srcE dstE AST.xtlo)
      !!ir (AST.xthi 32<rt> dstE := ite 9 srcE dstE AST.xthi)
      !!ir (AST.xtlo 32<rt> dstF := ite 10 srcF dstF AST.xtlo)
      !!ir (AST.xthi 32<rt> dstF := ite 11 srcF dstF AST.xthi)
      !!ir (AST.xtlo 32<rt> dstG := ite 12 srcG dstG AST.xtlo)
      !!ir (AST.xthi 32<rt> dstG := ite 13 srcG dstG AST.xthi)
      !!ir (AST.xtlo 32<rt> dstH := ite 14 srcH dstH AST.xtlo)
      !!ir (AST.xthi 32<rt> dstH := ite 15 srcH dstH AST.xthi)
    | OprMem _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      let ite i src dst extFn =
        AST.ite (cond i) (extFn 32<rt> src) (extFn 32<rt> dst)
      let evAssign src dst idx =
        AST.concat (ite (idx + 1) src dst AST.xthi) (ite idx src dst AST.xtlo)
      !!ir (dstA := evAssign srcA dstA 0)
      !!ir (dstB := evAssign srcB dstB 2)
      !!ir (dstC := evAssign srcC dstB 4)
      !!ir (dstD := evAssign srcD dstB 6)
      !!ir (dstE := evAssign srcE dstB 8)
      !!ir (dstF := evAssign srcF dstB 10)
      !!ir (dstG := evAssign srcG dstB 12)
      !!ir (dstH := evAssign srcH dstB 14)
    | _ -> raise InvalidOperandException
  else raise InvalidOperandSizeException
  !>ir insLen

let vmovd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  !<ir insLen
  let n0 = AST.num0 64<rt>
  let regToReg r1 r2 =
    match Register.getKind r1, Register.getKind r2 with
    | Register.Kind.XMM, Register.Kind.GP ->
      let dstD, dstC, dstB, dstA = getPseudoRegVar256 ctxt (r128to256 dst)
      let src = !.ctxt r2
      !!ir (dstAssign 32<rt> dstA src)
      !!ir (dstB := n0)
      !!ir (dstC := n0)
      !!ir (dstD := n0)
    | Register.Kind.GP, Register.Kind.XMM ->
      let dst = !.ctxt r1
      let srcA = getPseudoRegVar ctxt r2 1
      !!ir (dstAssign oprSize dst (AST.xtlo 32<rt> srcA))
    | _ -> raise InvalidOperandException
  match dst, src with
  | OprReg r1, OprReg r2 -> regToReg r1 r2
  | OprReg r, OprMem _ ->
    let dstD, dstC, dstB, dstA = getPseudoRegVar256 ctxt (r128to256 dst)
    let src = transOprToExpr ins insLen ctxt src
    !!ir (dstAssign 32<rt> dstA src)
    !!ir (dstB := n0)
    !!ir (dstC := n0)
    !!ir (dstD := n0)
  | OprMem _, OprReg r ->
    let dst = transOprToExpr ins insLen ctxt dst
    let srcA = getPseudoRegVar ctxt r 1
    !!ir (dst := AST.xtlo 32<rt> srcA)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovq ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  let n0 = AST.num0 64<rt>
  let regToReg r1 r2 =
    match Register.getKind r1, Register.getKind r2 with
    | Register.Kind.XMM, Register.Kind.XMM ->
      let dstD, dstC, dstB, dstA = getPseudoRegVar256 ctxt (r128to256 dst)
      let srcA = getPseudoRegVar ctxt r2 1
      !!ir (dstA := srcA)
      !!ir (dstB := n0)
      !!ir (dstC := n0)
      !!ir (dstD := n0)
    | Register.Kind.XMM, Register.Kind.GP ->
      let dstD, dstC, dstB, dstA = getPseudoRegVar256 ctxt (r128to256 dst)
      let src = !.ctxt r2
      !!ir (dstA := src)
      !!ir (dstB := n0)
      !!ir (dstC := n0)
      !!ir (dstD := n0)
    | Register.Kind.GP, Register.Kind.XMM ->
      let dst = !.ctxt r1
      let srcA = getPseudoRegVar ctxt r2 1
      !!ir (dst := srcA)
    | _ -> raise InvalidOperandException
  match dst, src with
  | OprReg r1, OprReg r2 -> regToReg r1 r2
  | OprReg _, OprMem _ ->
    let dstD, dstC, dstB, dstA = getPseudoRegVar256 ctxt (r128to256 dst)
    let src = transOprToExpr ins insLen ctxt src
    !!ir (dstA := src)
    !!ir (dstB := n0)
    !!ir (dstC := n0)
    !!ir (dstD := n0)
  | OprMem _, OprReg r ->
    let dst = transOprToExpr ins insLen ctxt dst
    let srcA = getPseudoRegVar ctxt r 1
    !!ir (dst := srcA)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovdqu ins insLen ctxt =
  buildVectorMove ins insLen ctxt

let private fillZeroFromVLToMaxVL ctxt dst vl maxVl ir =
  let n0 = AST.num0 64<rt>
  match maxVl, vl with
  | 512, 128 ->
    let dst = r128to512 dst
    let dstC, dstD, dstE, dstF, dstG, dstH =
      getPseudoRegVar ctxt dst 3, getPseudoRegVar ctxt dst 4,
      getPseudoRegVar ctxt dst 5, getPseudoRegVar ctxt dst 6,
      getPseudoRegVar ctxt dst 7, getPseudoRegVar ctxt dst 8
    !!ir (dstC := n0)
    !!ir (dstD := n0)
    !!ir (dstE := n0)
    !!ir (dstF := n0)
    !!ir (dstG := n0)
    !!ir (dstH := n0)
  | 512, 256 ->
    let dst = r256to512 dst
    let dstE, dstF, dstG, dstH =
      getPseudoRegVar ctxt dst 5, getPseudoRegVar ctxt dst 6,
      getPseudoRegVar ctxt dst 7, getPseudoRegVar ctxt dst 8
    !!ir (dstE := n0)
    !!ir (dstF := n0)
    !!ir (dstG := n0)
    !!ir (dstH := n0)
  | _ -> Utils.impossible ()

let vmovdqu16 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 16<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let kl, vl = 8, 128
    match dst with
    | OprReg _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      let assign dst src idx =
        let pos = (idx % 4) * 16
        let dst = AST.extract dst 16<rt> pos
        dst := AST.ite (cond idx) (AST.extract src 16<rt> pos) (masking dst)
      !!ir (assign dstA srcA 0)
      !!ir (assign dstA srcA 1)
      !!ir (assign dstA srcA 2)
      !!ir (assign dstA srcA 3)
      !!ir (assign dstB srcB 4)
      !!ir (assign dstB srcB 5)
      !!ir (assign dstB srcB 6)
      !!ir (assign dstB srcB 7)
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      let tmps = Array.init 4 (fun _ -> !*ir 16<rt>)
      let assign dst src idx =
        for i in 0 .. 3 do
          let pos = i * 16
          let dst = AST.extract dst 16<rt> pos
          !!ir (tmps[i] :=
                 AST.ite (cond (idx + i)) (AST.extract src 16<rt> pos) dst)
        AST.concatArr tmps
      !!ir (dstA := assign dstA srcA 0)
      !!ir (dstB := assign dstB srcB 4)
    | _ -> raise InvalidOperandException
  | 256<rt> ->
    let kl, vl = 16, 256
    match dst with
    | OprReg _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      let assign dst src idx =
        let pos = (idx % 4) * 16
        let dst = AST.extract dst 16<rt> pos
        dst := AST.ite (cond idx) (AST.extract src 16<rt> pos) (masking dst)
      !!ir (assign dstA srcA 0)
      !!ir (assign dstA srcA 1)
      !!ir (assign dstA srcA 2)
      !!ir (assign dstA srcA 3)
      !!ir (assign dstB srcB 4)
      !!ir (assign dstB srcB 5)
      !!ir (assign dstB srcB 6)
      !!ir (assign dstB srcB 7)
      !!ir (assign dstC srcC 8)
      !!ir (assign dstC srcC 9)
      !!ir (assign dstC srcC 10)
      !!ir (assign dstC srcC 11)
      !!ir (assign dstD srcD 12)
      !!ir (assign dstD srcD 13)
      !!ir (assign dstD srcD 14)
      !!ir (assign dstD srcD 15)
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      let tmps = Array.init 4 (fun _ -> !*ir 16<rt>)
      let assign dst src idx =
        for i in 0 .. 3 do
          let pos = i * 16
          let dst = AST.extract dst 16<rt> pos
          !!ir
            (tmps[i] := AST.ite (cond (idx + i)) (AST.extract src 16<rt> pos) dst)
        AST.concatArr tmps
      !!ir (dstA := assign dstA srcA 0)
      !!ir (dstB := assign dstB srcB 4)
      !!ir (dstC := assign dstC srcC 8)
      !!ir (dstD := assign dstD srcD 12)
    | _ -> raise InvalidOperandException
  | 512<rt> ->
    let kl, vl = 32, 512
    match dst with
    | OprReg _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      let assign dst src idx =
        let pos = (idx % 4) * 16
        let dst = AST.extract dst 16<rt> pos
        dst := AST.ite (cond idx) (AST.extract src 16<rt> pos) (masking dst)
      !!ir (assign dstA srcA 0)
      !!ir (assign dstA srcA 1)
      !!ir (assign dstA srcA 2)
      !!ir (assign dstA srcA 3)
      !!ir (assign dstB srcB 4)
      !!ir (assign dstB srcB 5)
      !!ir (assign dstB srcB 6)
      !!ir (assign dstB srcB 7)
      !!ir (assign dstC srcC 8)
      !!ir (assign dstC srcC 9)
      !!ir (assign dstC srcC 10)
      !!ir (assign dstC srcC 11)
      !!ir (assign dstD srcD 12)
      !!ir (assign dstD srcD 13)
      !!ir (assign dstD srcD 14)
      !!ir (assign dstD srcD 15)
      !!ir (assign dstE srcE 16)
      !!ir (assign dstE srcE 17)
      !!ir (assign dstE srcE 18)
      !!ir (assign dstE srcE 19)
      !!ir (assign dstE srcE 20)
      !!ir (assign dstF srcF 21)
      !!ir (assign dstF srcF 22)
      !!ir (assign dstF srcF 23)
      !!ir (assign dstG srcG 24)
      !!ir (assign dstG srcG 25)
      !!ir (assign dstG srcG 26)
      !!ir (assign dstG srcG 27)
      !!ir (assign dstH srcH 28)
      !!ir (assign dstH srcH 29)
      !!ir (assign dstH srcH 30)
      !!ir (assign dstH srcH 31)
    | OprMem _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      let tmps = Array.init 4 (fun _ -> !*ir 16<rt>)
      let assign dst src idx =
        for i in 0 .. 3 do
          let pos = i * 16
          let dst = AST.extract dst 16<rt> pos
          !!ir (tmps[i] :=
                 AST.ite (cond (idx + i)) (AST.extract src 16<rt> pos) dst)
        AST.concatArr tmps
      !!ir (dstA := assign dstA srcA 0)
      !!ir (dstB := assign dstB srcB 4)
      !!ir (dstC := assign dstC srcC 8)
      !!ir (dstD := assign dstD srcD 12)
      !!ir (dstE := assign dstE srcE 16)
      !!ir (dstF := assign dstF srcF 20)
      !!ir (dstG := assign dstG srcG 24)
      !!ir (dstH := assign dstH srcH 28)
    | _ -> raise InvalidOperandException
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovdqu64 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 64<rt>
    | Merging -> dst
  let cond idx =
    if ePrx.AAA = 0uy then AST.num0 1<rt> (* no write mask *)
    else AST.extract k 1<rt> idx
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let kl, vl = 4, 128
    match dst with
    | OprReg _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
    | _ -> raise InvalidOperandException
  | 256<rt> ->
    let kl, vl = 8, 256
    match dst with
    | OprReg _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      !!ir (dstC := AST.ite (cond 2) srcC (masking dstC))
      !!ir (dstD := AST.ite (cond 3) srcD (masking dstD))
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
      !!ir (dstC := AST.ite (cond 2) srcC dstC)
      !!ir (dstD := AST.ite (cond 3) srcD dstD)
    | _ -> raise InvalidOperandException
  | 512<rt> ->
    let kl, vl = 16, 512
    match dst with
    | OprReg _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      !!ir (dstC := AST.ite (cond 2) srcC (masking dstC))
      !!ir (dstD := AST.ite (cond 3) srcD (masking dstD))
      !!ir (dstE := AST.ite (cond 4) srcE (masking dstE))
      !!ir (dstF := AST.ite (cond 5) srcF (masking dstF))
      !!ir (dstG := AST.ite (cond 6) srcG (masking dstG))
      !!ir (dstH := AST.ite (cond 7) srcH (masking dstH))
    | OprMem _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
      !!ir (dstC := AST.ite (cond 2) srcC dstC)
      !!ir (dstD := AST.ite (cond 3) srcD dstD)
      !!ir (dstE := AST.ite (cond 4) srcE dstE)
      !!ir (dstF := AST.ite (cond 5) srcF dstF)
      !!ir (dstG := AST.ite (cond 6) srcG dstG)
      !!ir (dstH := AST.ite (cond 7) srcH dstH)
    | _ -> raise InvalidOperandException
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovdqa ins insLen ctxt = buildVectorMove ins insLen ctxt

let vmovdqa64 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 64<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let kl, vl = 2, 128
    match dst with
    | OprReg _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      let srcB, srcA = transOprToExpr128 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
    | _ -> raise InvalidOperandException
  | 256<rt> ->
    let kl, vl = 4, 256
    match dst with
    | OprReg _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      !!ir (dstC := AST.ite (cond 2) srcC (masking dstC))
      !!ir (dstD := AST.ite (cond 3) srcD (masking dstD))
      fillZeroFromVLToMaxVL ctxt dst vl 512 ir
    | OprMem _ ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
      !!ir (dstC := AST.ite (cond 2) srcC dstC)
      !!ir (dstD := AST.ite (cond 3) srcD dstD)
    | _ -> raise InvalidOperandException
  | 512<rt> ->
    let kl, vl = 8, 512
    match dst with
    | OprReg _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA (masking dstA))
      !!ir (dstB := AST.ite (cond 1) srcB (masking dstB))
      !!ir (dstC := AST.ite (cond 2) srcC (masking dstC))
      !!ir (dstD := AST.ite (cond 3) srcD (masking dstD))
      !!ir (dstE := AST.ite (cond 4) srcE (masking dstE))
      !!ir (dstF := AST.ite (cond 5) srcF (masking dstF))
      !!ir (dstG := AST.ite (cond 6) srcG (masking dstG))
      !!ir (dstH := AST.ite (cond 7) srcH (masking dstH))
    | OprMem _ ->
      let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
        transOprToExpr512 ins insLen ctxt dst
      let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
        transOprToExpr512 ins insLen ctxt src
      !!ir (dstA := AST.ite (cond 0) srcA dstA)
      !!ir (dstB := AST.ite (cond 1) srcB dstB)
      !!ir (dstC := AST.ite (cond 2) srcC dstC)
      !!ir (dstD := AST.ite (cond 3) srcD dstD)
      !!ir (dstE := AST.ite (cond 4) srcE dstE)
      !!ir (dstF := AST.ite (cond 5) srcF dstF)
      !!ir (dstG := AST.ite (cond 6) srcG dstG)
      !!ir (dstH := AST.ite (cond 7) srcH dstH)
    | _ -> raise InvalidOperandException
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovntdq ins insLen ctxt =
  SSELifter.buildMove ins insLen ctxt 16

let vmovups ins insLen ctxt =
  buildVectorMove ins insLen ctxt

let vmovupd ins insLen ctxt =
  buildVectorMove ins insLen ctxt

let vmovddup ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src = transOprToExpr64 ins insLen ctxt src
    !!ir (dst1 := src)
    !!ir (dst2 := src)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let _src4, src3, _src2, src1 = transOprToExpr256 ins insLen ctxt src
    !!ir (dst1 := src1)
    !!ir (dst2 := src1)
    !!ir (dst3 := src3)
    !!ir (dst4 := src3)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovntps ins insLen ctxt =
  SSELifter.buildMove ins insLen ctxt 16

let vmovntpd ins insLen ctxt =
  SSELifter.buildMove ins insLen ctxt 16

let vmovhlps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
  let src2B, _src2A = transOprToExpr128 ins insLen ctxt src2
  !<ir insLen
  !!ir (dstA := src1B)
  !!ir (dstB := src2B)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vmovhpd (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  match ins.Operands with
  | TwoOperands (dst, src) ->
    if haveEVEXPrx ins.VEXInfo then ()
    else
      let dst = transOprToExpr64 ins insLen ctxt dst
      let src2, _src1 = transOprToExpr128 ins insLen ctxt src
      !!ir (dst := src2)
  | ThreeOperands (dst, src1, src2)->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let _src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2 = transOprToExpr64 ins insLen ctxt src2
    !!ir (dstA := src1A)
    !!ir (dstB := src2)
    fillZeroHigh128 ctxt dst ir
  | _ -> raise InvalidOperandException
  !>ir insLen

let vmovlhps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let _src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let _src2B, src2A = transOprToExpr128 ins insLen ctxt src2
  !<ir insLen
  !!ir (dstA := src1A)
  !!ir (dstB := src2A)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vmovlpd (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  match ins.Operands with
  | TwoOperands (dst, src) ->
    let dst = transOprToExpr64 ins insLen ctxt dst
    let _, srcA = transOprToExpr128 ins insLen ctxt src
    !!ir (dst := srcA)
  | ThreeOperands (dst, src1, src2)->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
    let src2 = transOprToExpr ins insLen ctxt src2
    !!ir (dstA := src2)
    !!ir (dstB := src1B)
    fillZeroHigh128 ctxt dst ir
  | _ -> raise InvalidOperandException
  !>ir insLen

let vmovmskpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let dstSz = TypeCheck.typeOf dst
  let mskpd r =
    match Register.getKind r with
    | Register.Kind.XMM -> SSELifter.movmskpd ins insLen ctxt
    | Register.Kind.YMM ->
      !<ir insLen
      let src4, src3, src2, src1 = transOprToExpr256 ins insLen ctxt src
      let src63 = AST.sext dstSz (AST.xthi 1<rt> src1)
      let src127 = (AST.sext dstSz (AST.xthi 1<rt> src2)) << AST.num1 dstSz
      let src191 = (AST.sext dstSz (AST.xthi 1<rt> src3)) << numI32 2 dstSz
      let src255 = (AST.sext dstSz (AST.xthi 1<rt> src4)) << numI32 3 dstSz
      !!ir (dst := src63 .| src127 .| src191 .| src255)
      !>ir insLen
    | _ -> raise InvalidOperandException
  match src with
  | OprReg r -> mskpd r
  | _ -> raise InvalidOperandSizeException

let vmovmskps ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let dstSz = TypeCheck.typeOf dst
  let mskpd r =
    match Register.getKind r with
    | Register.Kind.XMM -> SSELifter.movmskps ins insLen ctxt
    | Register.Kind.YMM ->
      !<ir insLen
      let src4, src3, src2, src1 = transOprToExpr256 ins insLen ctxt src
      let src1A, src1B = AST.xtlo 32<rt> src1, AST.xthi 32<rt> src1
      let src2A, src2B = AST.xtlo 32<rt> src2, AST.xthi 32<rt> src2
      let src3A, src3B = AST.xtlo 32<rt> src3, AST.xthi 32<rt> src3
      let src4A, src4B = AST.xtlo 32<rt> src4, AST.xthi 32<rt> src4
      let src31 = AST.sext dstSz (AST.xthi 1<rt> src1A)
      let src63 = AST.sext dstSz (AST.xthi 1<rt> src1B) << AST.num1 dstSz
      let src95 = (AST.sext dstSz (AST.xthi 1<rt> src2A)) << numI32 2 dstSz
      let src127 = (AST.sext dstSz (AST.xthi 1<rt> src2B)) << numI32 3 dstSz
      let src159 = (AST.sext dstSz (AST.xthi 1<rt> src3A)) << numI32 4 dstSz
      let src191 = (AST.sext dstSz (AST.xthi 1<rt> src3B)) << numI32 5 dstSz
      let src223 = (AST.sext dstSz (AST.xthi 1<rt> src4A)) << numI32 6 dstSz
      let src255 = (AST.sext dstSz (AST.xthi 1<rt> src4B)) << numI32 7 dstSz
      !!ir (dst := src31 .| src63 .| src95 .| src127)
      !!ir (dst := dst .| src159 .| src191 .| src223 .| src255)
      !>ir insLen
    | _ -> raise InvalidOperandException
  match src with
  | OprReg r -> mskpd r
  | _ -> raise InvalidOperandSizeException

let vmovsd (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  match ins.Operands with
  | TwoOperands (OprMem _ , _) -> SSELifter.movsd ins insLen ctxt
  | TwoOperands (OprReg _ as dst, src) ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src = transOprToExpr64 ins insLen ctxt src
    !!ir (dst1 := src)
    !!ir (dst2 := AST.num0 64<rt>)
    fillZeroHigh128 ctxt dst ir
    !>ir insLen
  | ThreeOperands (dst, src1, src2)->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
    let _src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstA := src2A)
    !!ir (dstB := src1B)
    fillZeroHigh128 ctxt dst ir
    !>ir insLen
  | _ -> raise InvalidOperandException

let vmovshdup ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src2, src1 = transOprToExpr128 ins insLen ctxt src
    !!ir (AST.xtlo 32<rt> dst1 := AST.xthi 32<rt> src1)
    !!ir (AST.xthi 32<rt> dst1 := AST.xthi 32<rt> src1)
    !!ir (AST.xtlo 32<rt> dst2 := AST.xthi 32<rt> src2)
    !!ir (AST.xthi 32<rt> dst2 := AST.xthi 32<rt> src2)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let src4, src3, src2, src1 = transOprToExpr256 ins insLen ctxt src
    !!ir (AST.xtlo 32<rt> dst1 := AST.xthi 32<rt> src1)
    !!ir (AST.xthi 32<rt> dst1 := AST.xthi 32<rt> src1)
    !!ir (AST.xtlo 32<rt> dst2 := AST.xthi 32<rt> src2)
    !!ir (AST.xthi 32<rt> dst2 := AST.xthi 32<rt> src2)
    !!ir (AST.xtlo 32<rt> dst3 := AST.xthi 32<rt> src3)
    !!ir (AST.xthi 32<rt> dst3 := AST.xthi 32<rt> src3)
    !!ir (AST.xtlo 32<rt> dst4 := AST.xthi 32<rt> src4)
    !!ir (AST.xthi 32<rt> dst4 := AST.xthi 32<rt> src4)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovsldup ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src2, src1 = transOprToExpr128 ins insLen ctxt src
    !!ir (AST.xtlo 32<rt> dst1 := AST.xtlo 32<rt> src1)
    !!ir (AST.xthi 32<rt> dst1 := AST.xtlo 32<rt> src1)
    !!ir (AST.xtlo 32<rt> dst2 := AST.xtlo 32<rt> src2)
    !!ir (AST.xthi 32<rt> dst2 := AST.xtlo 32<rt> src2)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    let src4, src3, src2, src1 = transOprToExpr256 ins insLen ctxt src
    !!ir (AST.xtlo 32<rt> dst1 := AST.xtlo 32<rt> src1)
    !!ir (AST.xthi 32<rt> dst1 := AST.xtlo 32<rt> src1)
    !!ir (AST.xtlo 32<rt> dst2 := AST.xtlo 32<rt> src2)
    !!ir (AST.xthi 32<rt> dst2 := AST.xtlo 32<rt> src2)
    !!ir (AST.xtlo 32<rt> dst3 := AST.xtlo 32<rt> src3)
    !!ir (AST.xthi 32<rt> dst3 := AST.xtlo 32<rt> src3)
    !!ir (AST.xtlo 32<rt> dst4 := AST.xtlo 32<rt> src4)
    !!ir (AST.xthi 32<rt> dst4 := AST.xtlo 32<rt> src4)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vmovss (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  match ins.Operands with
  | TwoOperands (OprMem _ , _) -> SSELifter.movss ins insLen ctxt
  | TwoOperands (OprReg _ as dst, src) ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    let src = transOprToExpr32 ins insLen ctxt src
    !!ir (AST.xtlo 32<rt> dst1 := src)
    !!ir (AST.xthi 32<rt> dst1 := AST.num0 32<rt>)
    !!ir (dst2 := AST.num0 64<rt>)
    fillZeroHigh128 ctxt dst ir
    !>ir insLen
  | ThreeOperands (dst, src1, src2)->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let _src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dstA := AST.xtlo 32<rt> src2A)
    !!ir (AST.xthi 32<rt> dstA := AST.xthi 32<rt> src1A)
    !!ir (dstB := src1B)
    fillZeroHigh128 ctxt dst ir
    !>ir insLen
  | _ -> raise InvalidOperandException

let vandps ins insLen ctxt =
  vexedPackedFPBinOp32 ins insLen ctxt (.&)

let vandpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt (.&)

let private andnpdOp e1 e2 = (AST.not e1) .& e2

let vandnps ins insLen ctxt =
  vexedPackedFPBinOp32 ins insLen ctxt andnpdOp

let vandnpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt andnpdOp

let vorps ins insLen ctxt =
  vexedPackedFPBinOp32 ins insLen ctxt (.|)

let vorpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt (.|)

let vshufi32x4 ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2, imm) = getFourOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 32<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  let i8 = getImmValue imm
  !<ir insLen
  match oprSize with
  | 256<rt> ->
    let kl, vl = 8, 256
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let src1D, src1C, src1B, src1A =
      transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A =
      transOprToExpr256 ins insLen ctxt src2
    let struct (tDstD, tDstC, tDstB, tDstA) = tmpVars4 ir 64<rt>
    let imm0 (* imm8[0] *) = i8 &&& 0b1L
    let imm1 (* imm8[1] *) = (i8 >>> 1) &&& 0b1L
    !!ir (tDstA := if imm0 = 0L then src1A else src1C)
    !!ir (tDstB := if imm0 = 0L then src1D else src1B)
    !!ir (tDstC := if imm1 = 0L then src2C else src2A)
    !!ir (tDstD := if imm1 = 0L then src2D else src2B)
    let assign dst tDst idx =
      let pos = (idx % 2) * 32
      let dst = AST.extract dst 32<rt> pos
      dst := AST.ite (cond idx) (AST.extract tDst 32<rt> pos) (masking dst)
    !!ir (assign dstA tDstA 0)
    !!ir (assign dstA tDstA 1)
    !!ir (assign dstB tDstB 2)
    !!ir (assign dstB tDstB 3)
    !!ir (assign dstC tDstC 4)
    !!ir (assign dstC tDstC 5)
    !!ir (assign dstD tDstD 6)
    !!ir (assign dstD tDstD 7)
  | 512<rt> ->
    let kl, vl = 16, 512
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let src1H, src1G, src1F, src1E, src1D, src1C, src1B, src1A =
      transOprToExpr512 ins insLen ctxt src1
    let src2H, src2G, src2F, src2E, src2D, src2C, src2B, src2A =
      transOprToExpr512 ins insLen ctxt src2
    let struct (tDstD, tDstC, tDstB, tDstA) = tmpVars4 ir 64<rt>
    let struct (tDstH, tDstG, tDstF, tDstE) = tmpVars4 ir 64<rt>
    let tS2Arr = Array.init (kl / 2) (fun _ -> !*ir 64<rt>)
    let src2Arr = [| src2A; src2B; src2C; src2D; src2E; src2F; src2G; src2H |]
    match src2 with
    | OprMem _ when ePrx.B = 1uy ->
      let tSrcA = !*ir 64<rt>
      let tSrcA32 (* SRC2[31:0] *) = AST.extract src2A 32<rt> 0
      !!ir (tSrcA := AST.concat tSrcA32 tSrcA32)
      for i in 0 .. (kl / 2) - 1 do !!ir (tS2Arr[i] := tSrcA)
    | _ -> for i in 0 .. (kl / 2) - 1 do !!ir (tS2Arr[i] := src2Arr[i])
    let select4 control srcA srcB srcC srcD =
      match control (* control[1:0] *) with
      | 0b00L -> srcA
      | 0b01L -> srcB
      | 0b10L -> srcC
      | _ (* 11 *) -> srcD
    let ctrl imm8 amt = (imm8 >>> amt) &&& 0b11L
    !!ir (tDstA := select4 (ctrl i8 0) src1A src1C src1E src1G)
    !!ir (tDstB := select4 (ctrl i8 0) src1B src1D src1F src1H)
    !!ir (tDstC := select4 (ctrl i8 2) src1A src1C src1E src1G)
    !!ir (tDstD := select4 (ctrl i8 2) src1B src1D src1F src1H)
    !!ir (tDstE := select4 (ctrl i8 4) tS2Arr[0] tS2Arr[2] tS2Arr[4] tS2Arr[6])
    !!ir (tDstF := select4 (ctrl i8 4) tS2Arr[1] tS2Arr[3] tS2Arr[5] tS2Arr[7])
    !!ir (tDstG := select4 (ctrl i8 6) tS2Arr[0] tS2Arr[2] tS2Arr[4] tS2Arr[6])
    !!ir (tDstH := select4 (ctrl i8 6) tS2Arr[1] tS2Arr[3] tS2Arr[5] tS2Arr[7])
    let assign dst tDst idx =
      let pos = (idx % 2) * 32
      let dst = AST.extract dst 32<rt> pos
      dst := AST.ite (cond idx) (AST.extract tDst 32<rt> pos) (masking dst)
    !!ir (assign dstA tDstA 0)
    !!ir (assign dstA tDstA 1)
    !!ir (assign dstB tDstB 2)
    !!ir (assign dstB tDstB 3)
    !!ir (assign dstC tDstC 4)
    !!ir (assign dstC tDstC 5)
    !!ir (assign dstD tDstD 6)
    !!ir (assign dstD tDstD 7)
    !!ir (assign dstE tDstE 8)
    !!ir (assign dstE tDstE 9)
    !!ir (assign dstF tDstF 10)
    !!ir (assign dstF tDstF 11)
    !!ir (assign dstG tDstG 12)
    !!ir (assign dstG tDstG 13)
    !!ir (assign dstH tDstH 14)
    !!ir (assign dstH tDstH 15)
  | _ -> raise InvalidOperandException
  !>ir insLen

let vshufps ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (dst, src1, src2, imm) = getFourOprs ins
  let imm = transOprToExpr ins insLen ctxt imm
  let cond1 = AST.xtlo 2<rt> imm
  let cond2 = AST.extract imm 2<rt> 2
  let cond3 = AST.extract imm 2<rt> 4
  let cond4 = AST.extract imm 2<rt> 6
  let doShuf cond dst e1 e2 =
    !!ir (dst := AST.num0 32<rt>)
    !!ir (dst := AST.ite (cond == AST.num0 2<rt>) (AST.xtlo 32<rt> e1) dst)
    !!ir (dst := AST.ite (cond == AST.num1 2<rt>) (AST.xthi 32<rt> e1) dst)
    !!ir (dst := AST.ite (cond == numI32 2 2<rt>) (AST.xtlo 32<rt> e2) dst)
    !!ir (dst := AST.ite (cond == numI32 3 2<rt>) (AST.xthi 32<rt> e2) dst)
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let sr1B, sr1A = transOprToExpr128 ins insLen ctxt src1
    let sr2B, sr2A = transOprToExpr128 ins insLen ctxt src2
    doShuf cond1 (AST.xtlo 32<rt> dstA) sr1A sr1B
    doShuf cond2 (AST.xthi 32<rt> dstA) sr1A sr1B
    doShuf cond3 (AST.xtlo 32<rt> dstB) sr2A sr2B
    doShuf cond4 (AST.xthi 32<rt> dstB) sr2A sr2B
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let sr1D, sr1C, sr1B, sr1A = transOprToExpr256 ins insLen ctxt src1
    let sr2D, sr2C, sr2B, sr2A = transOprToExpr256 ins insLen ctxt src2
    doShuf cond1 (AST.xtlo 32<rt> dstA) sr1A sr1B
    doShuf cond2 (AST.xthi 32<rt> dstA) sr1A sr1B
    doShuf cond3 (AST.xtlo 32<rt> dstB) sr2A sr2B
    doShuf cond4 (AST.xthi 32<rt> dstB) sr2A sr2B
    doShuf cond1 (AST.xtlo 32<rt> dstC) sr1C sr1D
    doShuf cond2 (AST.xthi 32<rt> dstC) sr1C sr1D
    doShuf cond3 (AST.xtlo 32<rt> dstD) sr2C sr2D
    doShuf cond4 (AST.xthi 32<rt> dstD) sr2C sr2D
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vshufpd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2, imm) = getFourOprs ins
  let imm = transOprToExpr ins insLen ctxt imm
  let cond1 = AST.xtlo 1<rt> imm
  let cond2 = AST.extract imm 1<rt> 1
  let cond3 = AST.extract imm 1<rt> 2
  let cond4 = AST.extract imm 1<rt> 3
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstA := AST.ite cond1 src1B src1A)
    !!ir (dstB := AST.ite cond2 src2B src2A)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let sr1D, sr1C, sr1B, sr1A = transOprToExpr256 ins insLen ctxt src1
    let sr2D, sr2C, sr2B, sr2A = transOprToExpr256 ins insLen ctxt src2
    !!ir (dstA := AST.ite cond1 sr1B sr1A)
    !!ir (dstB := AST.ite cond2 sr2B sr2A)
    !!ir (dstC := AST.ite cond3 sr1D sr1C)
    !!ir (dstD := AST.ite cond4 sr2D sr2C)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vunpckhps ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2) = getThreeOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, _src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dstA := AST.xtlo 32<rt> src1B)
    !!ir (AST.xthi 32<rt> dstA := AST.xtlo 32<rt> src2B)
    !!ir (AST.xtlo 32<rt> dstB := AST.xthi 32<rt> src1B)
    !!ir (AST.xthi 32<rt> dstB := AST.xthi 32<rt> src2B)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let sr1D, _, sr1B, _ = transOprToExpr256 ins insLen ctxt src1
    let sr2D, _, sr2B, _ = transOprToExpr256 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dstA := AST.xtlo 32<rt> sr1B)
    !!ir (AST.xthi 32<rt> dstA := AST.xtlo 32<rt> sr2B)
    !!ir (AST.xtlo 32<rt> dstB := AST.xthi 32<rt> sr1B)
    !!ir (AST.xthi 32<rt> dstB := AST.xthi 32<rt> sr2B)
    !!ir (AST.xtlo 32<rt> dstC := AST.xtlo 32<rt> sr1D)
    !!ir (AST.xthi 32<rt> dstC := AST.xtlo 32<rt> sr2D)
    !!ir (AST.xtlo 32<rt> dstD := AST.xthi 32<rt> sr1D)
    !!ir (AST.xthi 32<rt> dstD := AST.xthi 32<rt> sr2D)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vunpckhpd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, _src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, _src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstA := src1B)
    !!ir (dstB := src2B)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let sr1D, _, sr1B, _ = transOprToExpr256 ins insLen ctxt src1
    let sr2D, _, sr2B, _ = transOprToExpr256 ins insLen ctxt src2
    !!ir (dstA := sr1B)
    !!ir (dstB := sr2B)
    !!ir (dstC := sr1D)
    !!ir (dstD := sr2D)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vunpcklps ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2) = getThreeOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let _src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let _src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dstA := AST.xtlo 32<rt> src1A)
    !!ir (AST.xthi 32<rt> dstA := AST.xtlo 32<rt> src2A)
    !!ir (AST.xtlo 32<rt> dstB := AST.xthi 32<rt> src1A)
    !!ir (AST.xthi 32<rt> dstB := AST.xthi 32<rt> src2A)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let _, src1C, _, src1A = transOprToExpr256 ins insLen ctxt src1
    let _, src2C, _, src2A = transOprToExpr256 ins insLen ctxt src2
    !!ir (AST.xtlo 32<rt> dstA := AST.xtlo 32<rt> src1A)
    !!ir (AST.xthi 32<rt> dstA := AST.xtlo 32<rt> src2A)
    !!ir (AST.xtlo 32<rt> dstB := AST.xthi 32<rt> src1A)
    !!ir (AST.xthi 32<rt> dstB := AST.xthi 32<rt> src2A)
    !!ir (AST.xtlo 32<rt> dstC := AST.xtlo 32<rt> src1C)
    !!ir (AST.xthi 32<rt> dstC := AST.xtlo 32<rt> src2C)
    !!ir (AST.xtlo 32<rt> dstD := AST.xthi 32<rt> src1C)
    !!ir (AST.xthi 32<rt> dstD := AST.xthi 32<rt> src2C)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vunpcklpd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let _src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let _src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstA := src1A)
    !!ir (dstB := src2A)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let _, src1C, _, src1A = transOprToExpr256 ins insLen ctxt src1
    let _, src2C, _, src2A = transOprToExpr256 ins insLen ctxt src2
    !!ir (dstA := src1A)
    !!ir (dstB := src2A)
    !!ir (dstC := src1C)
    !!ir (dstD := src2C)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vxorps ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> ->
    let ir = IRBuilder (16)
    let struct (dst, src1, src2) = getThreeOprs ins
    !<ir insLen
    let ePrx = getEVEXPrx ins.VEXInfo
    let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
    let masking dst =
      match ePrx.Z with
      | Zeroing -> AST.num0 32<rt>
      | Merging -> dst
    let cond idx =
      (* no write mask *)
      let noWritemask =
        if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
      AST.extract k 1<rt> idx .| noWritemask
    let tmpDest = Array.init 2 (fun _ -> !*ir 32<rt>)
    let evAssign dst s1 s2 src2A idx =
      for i in 0 .. 1 do
        let s1 = AST.extract s1 32<rt> (i * 32)
        let s2 = AST.extract s2 32<rt> (i * 32)
        let dst = AST.extract dst 32<rt> (i * 32)
        let tSrc =
          match src2 with
          | OprMem _ when ePrx.AAA (* B *) = 1uy ->
            s1 <+> (AST.extract src2A 32<rt> 0)
          | _ -> s1 <+> s2
        !!ir (tmpDest[i] := AST.ite (cond (idx + i)) tSrc (masking dst))
      AST.concatArr tmpDest
    let kl, vl = 16, 512
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let src1H, src1G, src1F, src1E, src1D, src1C, src1B, src1A =
      transOprToExpr512 ins insLen ctxt src1
    let src2H, src2G, src2F, src2E, src2D, src2C, src2B, src2A =
      transOprToExpr512 ins insLen ctxt src2
    !!ir (dstA := evAssign dstA src1A src2A src2A 0)
    !!ir (dstB := evAssign dstB src1B src2B src2A 2)
    !!ir (dstC := evAssign dstC src1C src2C src2A 4)
    !!ir (dstD := evAssign dstD src1D src2D src2A 6)
    !!ir (dstE := evAssign dstE src1E src2E src2A 8)
    !!ir (dstF := evAssign dstF src1F src2F src2A 10)
    !!ir (dstG := evAssign dstG src1G src2G src2A 12)
    !!ir (dstH := evAssign dstH src1H src2H src2A 14)
    !>ir insLen
  | _ -> vexedPackedFPBinOp32 ins insLen ctxt (<+>)

let vxorpd ins insLen ctxt =
  vexedPackedFPBinOp64 ins insLen ctxt (<+>)

let vbroadcasti128 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
  let srcB, srcA = transOprToExpr128 ins insLen ctxt src
  !<ir insLen
  !!ir (dstA := srcA)
  !!ir (dstB := srcB)
  !!ir (dstC := srcA)
  !!ir (dstD := srcB)
  !>ir insLen

let vbroadcastss ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (dst, src) = getTwoOprs ins
  let src = transOprToExpr32 ins insLen ctxt src
  let tmp = !*ir 32<rt>
  !<ir insLen
  match getOperationSize ins with
  | 128<rt> ->
    let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
    !!ir (tmp := src)
    !!ir (AST.xtlo 32<rt> dst1 := tmp)
    !!ir (AST.xthi 32<rt> dst1 := tmp)
    !!ir (AST.xtlo 32<rt> dst2 := tmp)
    !!ir (AST.xthi 32<rt> dst2 := tmp)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dst4, dst3, dst2, dst1 = transOprToExpr256 ins insLen ctxt dst
    !!ir (tmp := src)
    !!ir (AST.xtlo 32<rt> dst1 := tmp)
    !!ir (AST.xthi 32<rt> dst1 := tmp)
    !!ir (AST.xtlo 32<rt> dst2 := tmp)
    !!ir (AST.xthi 32<rt> dst2 := tmp)
    !!ir (AST.xtlo 32<rt> dst3 := tmp)
    !!ir (AST.xthi 32<rt> dst3 := tmp)
    !!ir (AST.xtlo 32<rt> dst4 := tmp)
    !!ir (AST.xthi 32<rt> dst4 := tmp)
  | 512<rt> -> ()
  | _ -> raise InvalidOperandException
  !>ir insLen

let vextracti32x8 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 32<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  let vl = 512
  let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
  let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
    transOprToExpr512 ins insLen ctxt src
  let imm0 = getImmValue imm &&& 0b1L (* imm8[0] *)
  let struct (tDstD, tDstC, tDstB, tDstA) = tmpVars4 ir 64<rt>
  !<ir insLen
  if imm0 = 0L then
    !!ir (tDstA := srcA)
    !!ir (tDstB := srcB)
    !!ir (tDstC := srcC)
    !!ir (tDstD := srcD)
  else (* imm0 = 1 *)
    !!ir (tDstA := srcE)
    !!ir (tDstB := srcF)
    !!ir (tDstC := srcG)
    !!ir (tDstD := srcH)
  match dst with
  | OprReg _ ->
    let tmps = Array.init 2 (fun _ -> !*ir 32<rt>)
    let assign dst src idx =
      for i in 0 .. 1 do
        let dst = AST.extract dst 32<rt> (i * 32)
        let src = AST.extract src 32<rt> (i * 32)
        !!ir (tmps[i] := AST.ite (cond (idx + i)) src (masking dst))
      AST.concatArr tmps
    !!ir (dstA := assign dstA tDstA 0)
    !!ir (dstB := assign dstB tDstB 2)
    !!ir (dstC := assign dstC tDstC 4)
    !!ir (dstD := assign dstD tDstD 6)
  | OprMem _ ->
    let tmps = Array.init 2 (fun _ -> !*ir 32<rt>)
    let assign dst src idx =
      for i in 0 .. 1 do
        let dst = AST.extract dst 32<rt> (i * 32)
        let src = AST.extract src 32<rt> (i * 32)
        !!ir (tmps[i] := AST.ite (cond (idx + i)) src dst)
      AST.concatArr tmps
    !!ir (dstA := assign dstA tDstA 0)
    !!ir (dstB := assign dstB tDstB 2)
    !!ir (dstC := assign dstC tDstC 4)
    !!ir (dstD := assign dstD tDstD 6)
  | _ -> raise InvalidOperandException
  !>ir insLen

let vextracti64x4 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let oprSize = getOperationSize ins
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 64<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  let vl = 512
  let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
  let srcH, srcG, srcF, srcE, srcD, srcC, srcB, srcA =
    transOprToExpr512 ins insLen ctxt src
  let imm0 = getImmValue imm &&& 0b1L (* imm8[0] *)
  let struct (tDstD, tDstC, tDstB, tDstA) = tmpVars4 ir 64<rt>
  !<ir insLen
  if imm0 = 0L then
    !!ir (tDstA := srcA)
    !!ir (tDstB := srcB)
    !!ir (tDstC := srcC)
    !!ir (tDstD := srcD)
  else (* imm0 = 1 *)
    !!ir (tDstA := srcE)
    !!ir (tDstB := srcF)
    !!ir (tDstC := srcG)
    !!ir (tDstD := srcH)
  match dst with
  | OprReg _ ->
    !!ir (dstA := AST.ite (cond 0) tDstA (masking dstA))
    !!ir (dstB := AST.ite (cond 1) tDstB (masking dstB))
    !!ir (dstC := AST.ite (cond 2) tDstC (masking dstC))
    !!ir (dstD := AST.ite (cond 3) tDstD (masking dstD))
  | OprMem _ ->
    !!ir (dstA := AST.ite (cond 0) tDstA dstA)
    !!ir (dstB := AST.ite (cond 1) tDstB dstB)
    !!ir (dstC := AST.ite (cond 2) tDstC dstC)
    !!ir (dstD := AST.ite (cond 3) tDstD dstD)
  | _ -> raise InvalidOperandException
  !>ir insLen

let vinserti128 ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2, imm) = getFourOprs ins
  let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
  let src1D, src1C, src1B, src1A = transOprToExpr256 ins insLen ctxt src1
  let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
  let imm = transOprToExpr ins insLen ctxt imm
  let cond = !*ir 1<rt>
  !<ir insLen
  !!ir (cond := AST.xtlo 1<rt> imm)
  !!ir (dstA := AST.ite cond src1A src2A)
  !!ir (dstB := AST.ite cond src1B src2B)
  !!ir (dstC := AST.ite cond src2A src1C)
  !!ir (dstD := AST.ite cond src2B src1D)
  !>ir insLen

let vpaddb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> (opP (.+)) 32

let vpaddd ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> ->
    let ir = IRBuilder (16)
    let struct (dst, src1, src2) = getThreeOprs ins
    !<ir insLen
    let ePrx = getEVEXPrx ins.VEXInfo
    let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
    let masking dst =
      match ePrx.Z with
      | Zeroing -> AST.num0 32<rt>
      | Merging -> dst
    let cond idx =
      (* no write mask *)
      let noWritemask =
        if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
      AST.extract k 1<rt> idx .| noWritemask
    let tmpDest = Array.init 2 (fun _ -> !*ir 32<rt>)
    let evAssign dst s1 s2 src2A idx =
      for i in 0 .. 1 do
        let s1 = AST.extract s1 32<rt> (i * 32)
        let s2 = AST.extract s2 32<rt> (i * 32)
        let dst = AST.extract dst 32<rt> (i * 32)
        let tSrc =
          match src2 with
          | OprMem _ when ePrx.AAA (* B *) = 1uy ->
            s1 .+ (AST.extract src2A 32<rt> 0)
          | _ -> s1 .+ s2
        !!ir (tmpDest[i] := AST.ite (cond (idx + i)) tSrc (masking dst))
      AST.concatArr tmpDest
    let kl, vl = 16, 512
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let src1H, src1G, src1F, src1E, src1D, src1C, src1B, src1A =
      transOprToExpr512 ins insLen ctxt src1
    let src2H, src2G, src2F, src2E, src2D, src2C, src2B, src2A =
      transOprToExpr512 ins insLen ctxt src2
    !!ir (dstA := evAssign dstA src1A src2A src2A 0)
    !!ir (dstB := evAssign dstB src1B src2B src2A 2)
    !!ir (dstC := evAssign dstC src1C src2C src2A 4)
    !!ir (dstD := evAssign dstD src1D src2D src2A 6)
    !!ir (dstE := evAssign dstE src1E src2E src2A 8)
    !!ir (dstF := evAssign dstF src1F src2F src2A 10)
    !!ir (dstG := evAssign dstG src1G src2G src2A 12)
    !!ir (dstH := evAssign dstH src1H src2H src2A 14)
    !>ir insLen
  | _ -> buildPackedInstr ins insLen ctxt 32<rt> (opP (.+)) 16

let vpaddq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> (opP (.+)) 16

let vpalignr ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src1, src2, imm) = getFourOprs ins
  let oprSize = getOperationSize ins
  let imm = getImmValue imm
  let amount = imm * 8L
  let rAmt = numI64 (amount % 64L) 64<rt> (* Right Shift *)
  let lAmt = numI64 (64L - (amount % 64L)) 64<rt> (* Left Shift *)
  !<ir insLen
  if oprSize = 128<rt> then
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    let struct (tSrc1A, tSrc1B, tSrc2A, tSrc2B) = tmpVars4 ir 64<rt>
    !!ir (tSrc1A := src1A)
    !!ir (tSrc1B := src1B)
    !!ir (tSrc2A := src2A)
    !!ir (tSrc2B := src2B)
    if amount < 64 then
      !!ir (dstA := (tSrc2B << lAmt) .| (tSrc2A >> rAmt))
      !!ir (dstB := (tSrc1A << lAmt) .| (tSrc2B >> rAmt))
    elif amount < 128 then
      !!ir (dstA := (tSrc1A << lAmt) .| (tSrc2B >> rAmt))
      !!ir (dstB := (tSrc1B << lAmt) .| (tSrc1A >> rAmt))
    elif amount < 192 then
      !!ir (dstA := (tSrc1B << lAmt) .| (tSrc1A >> rAmt))
      !!ir (dstB := tSrc1B >> rAmt)
    else
      !!ir (dstA := tSrc1B >> rAmt)
      !!ir (dstB := AST.num0 64<rt>)
    fillZeroHigh128 ctxt dst ir
  elif oprSize = 256<rt> then
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let src1D, src1C, src1B, src1A = transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A = transOprToExpr256 ins insLen ctxt src2
    let struct (tSrc1A, tSrc1B, tSrc1C, tSrc1D) = tmpVars4 ir 64<rt>
    let struct (tSrc2A, tSrc2B, tSrc2C, tSrc2D) = tmpVars4 ir 64<rt>
    !!ir (tSrc1A := src1A)
    !!ir (tSrc1B := src1B)
    !!ir (tSrc1C := src1C)
    !!ir (tSrc1D := src1D)
    !!ir (tSrc2A := src2A)
    !!ir (tSrc2B := src2B)
    !!ir (tSrc2C := src2C)
    !!ir (tSrc2D := src2D)
    if amount < 64 then
      !!ir (dstA := (tSrc2B << lAmt) .| (tSrc2A >> rAmt))
      !!ir (dstB := (tSrc1A << lAmt) .| (tSrc2B >> rAmt))
      !!ir (dstC := (tSrc2D << lAmt) .| (tSrc2C >> rAmt))
      !!ir (dstD := (tSrc1C << lAmt) .| (tSrc2D >> rAmt))
    elif amount < 128 then
      !!ir (dstA := (tSrc1A << lAmt) .| (tSrc2B >> rAmt))
      !!ir (dstB := (tSrc1B << lAmt) .| (tSrc1A >> rAmt))
      !!ir (dstC := (tSrc1C << lAmt) .| (tSrc2D >> rAmt))
      !!ir (dstD := (tSrc1D << lAmt) .| (tSrc1C >> rAmt))
    elif amount < 192 then
      !!ir (dstA := (tSrc1B << lAmt) .| (tSrc1A >> rAmt))
      !!ir (dstB := tSrc1B >> rAmt)
      !!ir (dstC := (tSrc1D << lAmt) .| (tSrc1C >> rAmt))
      !!ir (dstD := tSrc1D >> rAmt)
    else
      !!ir (dstA := tSrc1B >> rAmt)
      !!ir (dstB := AST.num0 64<rt>)
      !!ir (dstC := tSrc1D >> rAmt)
      !!ir (dstD := AST.num0 64<rt>)
  else raise InvalidOperandSizeException
  !>ir insLen

let vpand ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPand 16

let vpandn ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPandn 16

let vpbroadcastb ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  match oprSize with
  | 512<rt> -> () (* FIXME: #196 *)
  | _ ->
    let src =
      match src with
      | OprReg _ -> transOprToExpr128 ins insLen ctxt src |> snd
      | OprMem _ -> transOprToExpr ins insLen ctxt src
      | _ -> raise InvalidOperandException
      |> AST.xtlo 8<rt>
    let tSrc = !*ir 8<rt>
    !<ir insLen
    !!ir (tSrc := src)
    let tmps = Array.init 8 (fun _ -> !*ir 8<rt>)
    for i in 0 .. 7 do !!ir (tmps[i] := tSrc) done
    let t = !*ir 64<rt>
    !!ir (t := AST.concatArr tmps)
    match oprSize with
    | 128<rt> ->
      let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
      !!ir (dstA := t)
      !!ir (dstB := t)
      fillZeroHigh128 ctxt dst ir
    | 256<rt> ->
      let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
      !!ir (dstA := t)
      !!ir (dstB := t)
      !!ir (dstC := t)
      !!ir (dstD := t)
    | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vpbroadcastd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let oprSize = getOperationSize ins
  let temp = !*ir 32<rt>
  let src =
    match src with
    | OprReg r ->
      match Register.getKind r with
      | Register.Kind.XMM ->
        transOprToExpr128 ins insLen ctxt src |> snd
      | Register.Kind.GP -> transOprToExpr ins insLen ctxt src
      | _ -> raise InvalidOperandException
    | OprMem _ -> transOprToExpr ins insLen ctxt src
    | _ -> raise InvalidOperandException
    |> AST.xtlo 32<rt>
  !<ir insLen
  !!ir (temp := src)
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    !!ir (AST.extract dstA 32<rt> 0 := temp)
    !!ir (AST.extract dstA 32<rt> 32 := temp)
    !!ir (AST.extract dstB 32<rt> 0 := temp)
    !!ir (AST.extract dstB 32<rt> 32 := temp)
    fillZeroFromVLToMaxVL ctxt dst 128 512 ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    !!ir (AST.extract dstA 32<rt> 0 := temp)
    !!ir (AST.extract dstA 32<rt> 32 := temp)
    !!ir (AST.extract dstB 32<rt> 0 := temp)
    !!ir (AST.extract dstB 32<rt> 32 := temp)
    !!ir (AST.extract dstC 32<rt> 0 := temp)
    !!ir (AST.extract dstC 32<rt> 32 := temp)
    !!ir (AST.extract dstD 32<rt> 0 := temp)
    !!ir (AST.extract dstD 32<rt> 32 := temp)
    fillZeroFromVLToMaxVL ctxt dst 256 512 ir
  | 512<rt> ->
    let kl, vl = 16, 512
    let ePrx = getEVEXPrx ins.VEXInfo
    let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
    let masking dst =
      match ePrx.Z with
      | Zeroing -> AST.num0 32<rt>
      | Merging -> dst
    let cond idx =
      (* no write mask *)
      let noWritemask =
        if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
      AST.extract k 1<rt> idx .| noWritemask
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let assign dst idx sPos =
      let extDst = AST.extract dst 32<rt> sPos
      extDst := AST.ite (cond idx) temp (masking extDst)
    !!ir (assign dstA 0 0)
    !!ir (assign dstA 1 32)
    !!ir (assign dstB 2 0)
    !!ir (assign dstB 3 32)
    !!ir (assign dstC 4 0)
    !!ir (assign dstC 5 32)
    !!ir (assign dstD 6 0)
    !!ir (assign dstD 7 32)
    !!ir (assign dstE 8 0)
    !!ir (assign dstE 9 32)
    !!ir (assign dstF 10 0)
    !!ir (assign dstF 11 32)
    !!ir (assign dstG 12 0)
    !!ir (assign dstG 13 32)
    !!ir (assign dstH 14 0)
    !!ir (assign dstH 15 32)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vpcmpeqb ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen (* FIXME: #197 *)
  | _ -> buildPackedInstr ins insLen ctxt 8<rt> opPcmpeqb 64

let vpcmpeqd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPcmpeqd 32

let vpcmpeqq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> SSELifter.opPcmpeqq 16

let vpcmpgtb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPcmpgtb 64

let vpinsrd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2, count) = getFourOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let src2 = transOprToExpr ins insLen ctxt src2
  let sel = getImmValue count &&& 0b11L (* COUNT[1:0] *)
  let mask = numI64 (0xFFFFFFFFL <<< ((int32 sel * 32) % 64)) 64<rt>
  let amount = sel * 32L
  let t = !*ir 64<rt>
  let expAmt = numI64 (amount % 64L) 64<rt>
  !<ir insLen
  !!ir (t := ((AST.zext 64<rt> src2) << expAmt) .& mask)
  if amount < 64 then !!ir (dstA := (src1A .& (AST.not mask)) .& t)
  else !!ir (dstB := (src1B .& (AST.not mask)) .& t)
  fillZeroFromVLToMaxVL ctxt dst 128 512 ir
  !>ir insLen

let vpminub ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> SSELifter.opPminub 64

let vpminud ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> SSELifter.opPminud 32

let private opVpmuludq _ =
  let low32 expr = expr .& numI64 0xffffffffL 64<rt>
  Array.map2 (fun e1 e2 -> low32 e1 .* low32 e2)

let vpmuludq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opVpmuludq 16

let vpor ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen
  | _ -> buildPackedInstr ins insLen ctxt 64<rt> opPor 8

let vpshufb ins insLen ctxt =
  let struct (dst, src1, src2) = getThreeOprs ins
  let oprSize = getOperationSize ins
  let cnt = if oprSize = 128<rt> then 16 else 32
  let ir = IRBuilder (2 * cnt)
  let n0 = AST.num0 8<rt>
  let mask = numU32 0x0Fu 8<rt>
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    let highTmps = Array.init 8 (fun _ -> !*ir 8<rt>)
    let lowTmps = Array.init 8 (fun _ -> !*ir 8<rt>)
    let struct (tSrc1, tSrc2) = tmpVars2 ir 64<rt>
    for i in 0 .. cnt - 1 do
      !!ir (tSrc2 := if i < 8 then src2A else src2B)
      let cond = AST.extract tSrc2 1<rt> (((i * 8) % 64) + 7)
      let idx = (AST.extract tSrc2 8<rt> ((i * 8) % 64)) .& mask
      let numShift =
        ((AST.zext 64<rt> idx) .* (numI32 8 64<rt>)) .% (numI32 64 64<rt>)
      !!ir (tSrc1 := AST.ite (idx .< numI32 8 8<rt>) src1A src1B)
      let src1 = AST.xtlo 8<rt> (tSrc1 >> numShift)
      if i < 8 then !!ir (lowTmps[i] := AST.ite cond n0 src1)
      else !!ir (highTmps[i % 8] := AST.ite cond n0 src1)
    done
    !!ir (dstA := AST.concatArr lowTmps)
    !!ir (dstB := AST.concatArr highTmps)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let src1D, src1C, src1B, src1A = transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A = transOprToExpr256 ins insLen ctxt src2
    let tmpsA = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsB = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsC = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsD = Array.init 8 (fun _ -> !*ir 8<rt>)
    let struct (tSrc1, tSrc2) = tmpVars2 ir 64<rt>
    let src1 = [| src1A; src1B; src1C; src1D  |]
    let src2 = [| src2A; src2B; src2C; src2D  |]
    let n8 = numI32 8 8<rt>
    let n16 = numI32 16 8<rt>
    let n24 = numI32 24 8<rt>
    for i in 0 .. cnt - 1 do
      !!ir (tSrc1 := src1[i / 8])
      !!ir (tSrc2 := src2[i / 8])
      let cond = AST.extract tSrc2 1<rt> (((i * 8) % 64) + 7)
      let idx = (AST.extract tSrc2 8<rt> ((i * 8) % 64)) .& mask
      let numShift =
        ((AST.zext 64<rt> idx) .* (numI32 8 64<rt>)) .% (numI32 64 64<rt>)
      let src1 =
        AST.ite (idx .< n8) src1A (AST.ite (idx .< n16) src1B
        (AST.ite (idx .< n24) src1C src1D))
      !!ir (tSrc1 := src1)
      let src1 = AST.xtlo 8<rt> (tSrc1 >> numShift)
      if i < 8 then !!ir (tmpsA[i] := AST.ite cond n0 src1)
      elif i < 16 then !!ir (tmpsB[i % 8] := AST.ite cond n0 src1)
      elif i < 24 then !!ir (tmpsC[i % 8] := AST.ite cond n0 src1)
      else !!ir (tmpsD[i % 8] := AST.ite cond n0 src1)
    done
    !!ir (dstA := AST.concatArr tmpsA)
    !!ir (dstB := AST.concatArr tmpsB)
    !!ir (dstC := AST.concatArr tmpsC)
    !!ir (dstD := AST.concatArr tmpsD)
  | 512<rt> ->
    let kl, vl = 64, 512
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let src1H, src1G, src1F, src1E, src1D, src1C, src1B, src1A =
      transOprToExpr512 ins insLen ctxt src1
    let src2H, src2G, src2F, src2E, src2D, src2C, src2B, src2A =
      transOprToExpr512 ins insLen ctxt src2
    let tmpsA = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsB = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsC = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsD = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsE = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsF = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsG = Array.init 8 (fun _ -> !*ir 8<rt>)
    let tmpsH = Array.init 8 (fun _ -> !*ir 8<rt>)
    let src1 = [| src1A; src1B; src1C; src1D; src1E; src1F; src1G; src1H |]
    let src2 = [| src2A; src2B; src2C; src2D; src2E; src2F; src2G; src2H |]
    let struct (tSrc1, tSrc2) = tmpVars2 ir 64<rt>
    let numF = numU32 0xFu 8<rt>
    let n0 = AST.num0 8<rt>
    let jmask = !*ir 8<rt>
    let ePrx = getEVEXPrx ins.VEXInfo
    let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
    let cond1 idx =
      let noWritemask = (* no masking *)
        if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
      AST.extract k 1<rt> idx .| noWritemask
    let lblNoMask = ir.NewSymbol "NoMasking"
    let lblZero = ir.NewSymbol "Zeroing"
    let lblL0 = ir.NewSymbol "L0" (* index & 0x80 *)
    let lblL1 = ir.NewSymbol "L1"
    let lblEnd = ir.NewSymbol "End"
    let struct (index, cond2) = tmpVars2 ir 8<rt>
    let getTmpDst idx =
      if idx < 8 then tmpsA[idx]
      elif idx < 16 then tmpsB[idx % 8]
      elif idx < 24 then tmpsC[idx % 8]
      elif idx < 32 then tmpsD[idx % 8]
      elif idx < 40 then tmpsE[idx % 8]
      elif idx < 48 then tmpsF[idx % 8]
      elif idx < 56 then tmpsG[idx % 8]
      else tmpsG[idx % 8]
    let n8 = numI32 8 8<rt>
    let n16 = numI32 16 8<rt>
    let n24 = numI32 24 8<rt>
    let n32 = numI32 32 8<rt>
    let n40 = numI32 40 8<rt>
    let n48 = numI32 48 8<rt>
    let n56 = numI32 56 8<rt>
    !!ir (jmask := numI32 ((kl - 1) &&& ~~~0xF) 8<rt>)
    for i in 0 .. kl - 1 do
      !!ir (tSrc2 := src2[i / 8])
      !!ir (AST.cjmp (cond1 i) (AST.name lblNoMask) (AST.name lblZero))
      !!ir (AST.lmark lblNoMask)
      !!ir (index := AST.extract tSrc2 8<rt> ((i * 8) % 64))
      !!ir (cond2 := index .& numI32 0x80 8<rt>)
      !!ir (AST.cjmp cond2 (AST.name lblL0) (AST.name lblL1))
      !!ir (AST.lmark lblL0)
      !!ir (getTmpDst i := n0)
      !!ir (AST.jmp (AST.name lblEnd))
      !!ir (AST.lmark lblL1)
      !!ir (index := (index .& numF) .+ (numI32 (i % 8) 8<rt> .& jmask))
      let numShift =
        ((AST.zext 64<rt> index) .* (numI32 8 64<rt>)) .% (numI32 64 64<rt>)
      let src1 =
        AST.ite (index .< n8) src1A (AST.ite (index .< n16) src1B
          (AST.ite (index .< n24) src1C (AST.ite (index .< n32) src1D
            (AST.ite (index .< n40) src1E (AST.ite (index .< n48) src1E
              (AST.ite (index .< n56) src1G src1H))))))
      !!ir (tSrc1 := src1)
      let src1 = AST.xtlo 8<rt> (tSrc1 >> numShift)
      !!ir (getTmpDst i := src1)
      !!ir (AST.jmp (AST.name lblEnd))
      !!ir (AST.lmark lblZero)
      !!ir (getTmpDst i := n0)
      !!ir (AST.lmark lblEnd)
    done
    !!ir (dstA := AST.concatArr tmpsA)
    !!ir (dstB := AST.concatArr tmpsB)
    !!ir (dstC := AST.concatArr tmpsC)
    !!ir (dstD := AST.concatArr tmpsD)
    !!ir (dstE := AST.concatArr tmpsE)
    !!ir (dstF := AST.concatArr tmpsF)
    !!ir (dstG := AST.concatArr tmpsG)
    !!ir (dstH := AST.concatArr tmpsH)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vpshufd ins insLen ctxt =
  let struct (dst, src, ord) = getThreeOprs ins
  let ord = getImmValue ord
  let oprSize = getOperationSize ins
  let cnt = RegType.toBitWidth oprSize / 32
  let ir = IRBuilder (2 * cnt)
  let rShiftTo64 hiExpr lowExpr amount =
    let rightAmt = numI64 (amount % 64L) 64<rt>
    let leftAmt = numI64 (64L - (amount % 64L)) 64<rt>
    if amount < 64L then
      AST.xtlo 32<rt> ((hiExpr << leftAmt) .| (lowExpr >> rightAmt))
    elif amount < 128 then AST.xtlo 32<rt> (hiExpr >> rightAmt)
    else AST.num0 32<rt>
  let amount idx = ((ord >>> (idx * 2)) &&& 0b11L) * 32L
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let struct (tSrcB, tSrcA) = tmpVars2 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    let src amtIdx = rShiftTo64 tSrcB tSrcA (amount amtIdx)
    !!ir (dstA := AST.concat (src 1) (src 0))
    !!ir (dstB := AST.concat (src 3) (src 2))
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
    let struct (tSrcD, tSrcC, tSrcB, tSrcA) = tmpVars4 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    !!ir (tSrcC := srcC)
    !!ir (tSrcD := srcD)
    let lowSrc amtIdx = rShiftTo64 tSrcB tSrcA (amount amtIdx)
    let hiSrc amtIdx = rShiftTo64 tSrcD tSrcC (amount amtIdx)
    !!ir (dstA := AST.concat (lowSrc 1) (lowSrc 0))
    !!ir (dstB := AST.concat (lowSrc 3) (lowSrc 2))
    !!ir (dstC := AST.concat (hiSrc 1) (hiSrc 0))
    !!ir (dstD := AST.concat (hiSrc 3) (hiSrc 2))
    fillZeroHigh256 ctxt dst ir
  | 512<rt> -> () (* FIXME: #196 *)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private opShiftVpackedDataLogical oprSize packSz shf src1 (src2: Expr []) =
  let count = src2[0] |> AST.zext oprSize
  let cond = AST.gt count (numI32 ((int packSz) - 1) oprSize)
  let shifted expr = AST.extract (shf (AST.zext oprSize expr) count) packSz 0
  Array.map (fun e -> AST.ite cond (AST.num0 packSz) (shifted e)) src1

let private opVpslld oprSize = opShiftVpackedDataLogical oprSize 32<rt> (<<)

let vpslld ins insLen ctxt =
  match getOperationSize ins with
  | 512<rt> -> GeneralLifter.nop insLen
  | _ -> buildPackedInstr ins insLen ctxt 32<rt> opVpslld 16

let private opVpsllq oprSize = opShiftVpackedDataLogical oprSize 64<rt> (<<)

let vpsllq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opVpsllq 16

let vpslldq ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, cnt) = getThreeOprs ins
  let cnt = getImmValue cnt
  let amount = cnt * 8L
  let rightAmt = numI64 (64L - (amount % 64L)) 64<rt>
  let leftAmt = numI64 (amount % 64L) 64<rt>
  let oprSize = getOperationSize ins
  !<ir insLen
  let cnt = if cnt > 15L then 16L else cnt
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let struct (tSrcB, tSrcA) = tmpVars2 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    if amount < 64 then
      !!ir (dstA := tSrcA << leftAmt)
      !!ir (dstB := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
    elif amount < 128 then
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := tSrcA << leftAmt)
    else
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
    let struct (tSrcD, tSrcC, tSrcB, tSrcA) = tmpVars4 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    !!ir (tSrcC := srcC)
    !!ir (tSrcD := srcD)
    if amount < 64 then
      !!ir (dstA := tSrcA << leftAmt)
      !!ir (dstB := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
      !!ir (dstC := (tSrcC << leftAmt) .| (tSrcB >> rightAmt))
      !!ir (dstD := (tSrcD << leftAmt) .| (tSrcC >> rightAmt))
    elif amount < 128 then
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := tSrcA << leftAmt)
      !!ir (dstC := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
      !!ir (dstD := (tSrcC << leftAmt) .| (tSrcB >> rightAmt))
    elif amount < 192 then
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
      !!ir (dstC := tSrcA << leftAmt)
      !!ir (dstD := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
    elif amount < 256 then
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
      !!ir (dstC := AST.num0 64<rt>)
      !!ir (dstD := tSrcA << leftAmt)
    else
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
      !!ir (dstC := AST.num0 64<rt>)
      !!ir (dstD := AST.num0 64<rt>)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vpsrlq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opVpsllq 16

let vpsrldq ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, cnt) = getThreeOprs ins
  let cnt = getImmValue cnt
  let cnt = if cnt > 15L then 16L else cnt
  let amount = cnt * 8L
  let rightAmt = numI64 (amount % 64L) 64<rt>
  let leftAmt = numI64 (64L - (amount % 64L)) 64<rt>
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let struct (tSrcB, tSrcA) = tmpVars2 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    (* FIXME: refactoring *)
    /// Case 1
    let index = (int amount) / 64
    let src = [| tSrcA; tSrcB; AST.num0 64<rt>; AST.num0 64<rt> |]
    !!ir (dstA := (src[index + 1] << leftAmt) .| (src[index] >> rightAmt))
    !!ir (dstB := src[index + 1] >> rightAmt)
    (*
    /// Case 2
    if amount < 64 then
      !!ir (dstA := (srcB << leftAmt) .| (srcA >> rightAmt))
      !!ir (dstB := srcB >> rightAmt)
    elif amount < 128 then
      !!ir (dstA := srcB >> rightAmt)
      !!ir (dstB := AST.num0 64<rt>)
    else
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
    *)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
    let struct (tSrcD, tSrcC, tSrcB, tSrcA) = tmpVars4 ir 64<rt>
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    !!ir (tSrcC := srcC)
    !!ir (tSrcD := srcD)
    if amount < 64 then
      !!ir (dstA := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
      !!ir (dstB := (tSrcC << leftAmt) .| (tSrcB >> rightAmt))
      !!ir (dstC := (tSrcD << leftAmt) .| (tSrcC >> rightAmt))
      !!ir (dstD := tSrcD >> rightAmt)
    elif amount < 128 then
      !!ir (dstA := (tSrcC << leftAmt) .| (tSrcB >> rightAmt))
      !!ir (dstB := (tSrcD << leftAmt) .| (tSrcC >> rightAmt))
      !!ir (dstC := tSrcD >> rightAmt)
      !!ir (dstD := AST.num0 64<rt>)
    elif amount < 192 then
      !!ir (dstA := (tSrcD << leftAmt) .| (tSrcC >> rightAmt))
      !!ir (dstB := tSrcD >> rightAmt)
      !!ir (dstC := AST.num0 64<rt>)
      !!ir (dstD := AST.num0 64<rt>)
    else
      !!ir (dstA := tSrcD >> rightAmt)
      !!ir (dstB := AST.num0 64<rt>)
      !!ir (dstC := AST.num0 64<rt>)
      !!ir (dstD := AST.num0 64<rt>)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private opVpsrld oprSize = opShiftVpackedDataLogical oprSize 32<rt> (<<)

let vpsrld ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opVpsrld 16

let vpsubb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPsub 128

let vptest ins insLen ctxt =
  if getOperationSize ins = 128<rt> then SSELifter.ptest ins insLen ctxt
  else
    let ir = IRBuilder (16)
    let struct (src1, src2) = getTwoOprs ins
    let src1D, src1C, src1B, src1A =
      transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A =
      transOprToExpr256 ins insLen ctxt src2
    let struct (t1, t2, t3, t4) = tmpVars4 ir 64<rt>
    let struct (t5, t6, t7, t8) = tmpVars4 ir 64<rt>
    !<ir insLen
    !!ir (t1 := src2A .& src1A)
    !!ir (t2 := src2B .& src1B)
    !!ir (t3 := src2C .& src1C)
    !!ir (t4 := src2D .& src1D)
    !!ir (!.ctxt R.ZF := (t1 .| t2 .| t3 .| t4) == (AST.num0 64<rt>))
    !!ir (t5 := src2A .& AST.not src1A)
    !!ir (t6 := src2B .& AST.not src1B)
    !!ir (t7 := src2C .& AST.not src1C)
    !!ir (t8 := src2D .& AST.not src1D)
    !!ir (!.ctxt R.CF := (t5 .| t6 .| t7 .| t8) == (AST.num0 64<rt>))
    !!ir (!.ctxt R.AF := AST.b0)
    !!ir (!.ctxt R.OF := AST.b0)
    !!ir (!.ctxt R.PF := AST.b0)
    !!ir (!.ctxt R.SF := AST.b0)
    !>ir insLen

let vpunpckhdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPunpckHigh 16

let vpunpckhqdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPunpckHigh 16

let vpunpckldq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPunpckLow 16

let vpunpcklqdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPunpckLow 16

let vpxor ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize with
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstB := src1B <+> src2B)
    !!ir (dstA := src1A <+> src2A)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let src1D, src1C, src1B, src1A =
      transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A =
      transOprToExpr256 ins insLen ctxt src2
    !!ir (dstD := src1D <+> src2D)
    !!ir (dstC := src1C <+> src2C)
    !!ir (dstB := src1B <+> src2B)
    !!ir (dstA := src1A <+> src2A)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vpxord ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = getThreeOprs ins
  let oprSize = getOperationSize ins
  !<ir insLen
  let ePrx = getEVEXPrx ins.VEXInfo
  let k = !.ctxt (ePrx.AAA |> Disasm.getOpmaskRegister)
  let masking dst =
    match ePrx.Z with
    | Zeroing -> AST.num0 32<rt>
    | Merging -> dst
  let cond idx =
    (* no write mask *)
    let noWritemask = if ePrx.AAA = 0uy then AST.num1 1<rt> else AST.num0 1<rt>
    AST.extract k 1<rt> idx .| noWritemask
  let tmpDest = Array.init 2 (fun _ -> !*ir 32<rt>)
  let evAssign dst s1 s2 src2A dstA idx =
    for i in 0 .. 1 do
      let s1 = AST.extract s1 32<rt> (i * 32)
      let s2 = AST.extract s2 32<rt> (i * 32)
      let dst = AST.extract dstA 32<rt> 0
      let tSrc =
        match src2 with
        | OprMem _ when ePrx.AAA (* B *) = 1uy ->
          s1 <+> (AST.extract src2A 32<rt> 0)
        | _ -> s1 <+> s2
      !!ir (tmpDest[i] := AST.ite (cond (idx + i)) tSrc (masking dst))
    AST.concatArr tmpDest
  match oprSize with
  | 128<rt> ->
    let kl, vl = 4, 128
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
    let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
    !!ir (dstA := evAssign dstA src1A src2A src2A dstA 0)
    !!ir (dstB := evAssign dstB src1B src2B src2A dstA 2)
    fillZeroHigh128 ctxt dst ir
  | 256<rt> ->
    let kl, vl = 8, 256
    let dstD, dstC, dstB, dstA = transOprToExpr256 ins insLen ctxt dst
    let src1D, src1C, src1B, src1A =
      transOprToExpr256 ins insLen ctxt src1
    let src2D, src2C, src2B, src2A =
      transOprToExpr256 ins insLen ctxt src2
    !!ir (dstA := evAssign dstA src1A src2A src2A dstA 0)
    !!ir (dstB := evAssign dstB src1B src2B src2A dstA 2)
    !!ir (dstC := evAssign dstC src1C src2B src2A dstA 4)
    !!ir (dstD := evAssign dstD src1D src2B src2A dstA 6)
    fillZeroHigh256 ctxt dst ir
  | 512<rt> ->
    let kl, vl = 16, 512
    let dstH, dstG, dstF, dstE, dstD, dstC, dstB, dstA =
      transOprToExpr512 ins insLen ctxt dst
    let src1H, src1G, src1F, src1E, src1D, src1C, src1B, src1A =
      transOprToExpr512 ins insLen ctxt src1
    let src2H, src2G, src2F, src2E, src2D, src2C, src2B, src2A =
      transOprToExpr512 ins insLen ctxt src2
    !!ir (dstA := evAssign dstA src1A src2A src2A dstA 0)
    !!ir (dstB := evAssign dstB src1B src2B src2A dstA 2)
    !!ir (dstC := evAssign dstC src1C src2C src2A dstA 4)
    !!ir (dstD := evAssign dstD src1D src2D src2A dstA 6)
    !!ir (dstE := evAssign dstE src1E src2E src2A dstA 8)
    !!ir (dstF := evAssign dstF src1F src2F src2A dstA 10)
    !!ir (dstG := evAssign dstG src1G src2G src2A dstA 12)
    !!ir (dstH := evAssign dstH src1H src2H src2A dstA 14)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let vzeroupper ins insLen ctxt =
  let ir = IRBuilder (32)
  !<ir insLen
  let n0 = AST.num0 64<rt>
  !!ir (getPseudoRegVar ctxt R.YMM0 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM0 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM1 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM1 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM2 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM2 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM3 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM3 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM4 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM4 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM5 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM5 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM6 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM6 4 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM7 3 := n0)
  !!ir (getPseudoRegVar ctxt R.YMM7 4 := n0)
  if is64bit ctxt then
    !!ir (getPseudoRegVar ctxt R.YMM8 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM8 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM9 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM9 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM10 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM10 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM11 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM11 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM12 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM12 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM13 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM13 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM14 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM14 4 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM15 3 := n0)
    !!ir (getPseudoRegVar ctxt R.YMM15 4 := n0)
  !>ir insLen

let vfmadd132sd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src2, src3) = getThreeOprs ins
  let _dstB , dstA = transOprToExpr128 ins insLen ctxt dst
  let src2 = transOprToExpr64 ins insLen ctxt src2
  let src3 = transOprToExpr64 ins insLen ctxt src3
  let tmp = !*ir 64<rt>
  !<ir insLen
  !!ir (tmp := AST.fmul dstA src3)
  !!ir (dstA := AST.fadd tmp src2)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vfmadd213sd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src2, src3) = getThreeOprs ins
  let _dstB , dstA = transOprToExpr128 ins insLen ctxt dst
  let src2 = transOprToExpr64 ins insLen ctxt src2
  let src3 = transOprToExpr64 ins insLen ctxt src3
  let tmp = !*ir 64<rt>
  !<ir insLen
  !!ir (tmp := AST.fmul dstA src2)
  !!ir (dstA := AST.fadd tmp src3)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

let vfmadd231sd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src2, src3) = getThreeOprs ins
  let _dstB , dstA = transOprToExpr128 ins insLen ctxt dst
  let src2 = transOprToExpr64 ins insLen ctxt src2
  let src3 = transOprToExpr64 ins insLen ctxt src3
  let tmp = !*ir 64<rt>
  !<ir insLen
  !!ir (tmp := AST.fmul src2 src3)
  !!ir (dstA := AST.fadd dstA tmp)
  fillZeroHigh128 ctxt dst ir
  !>ir insLen

IntelDisasm.fs
//这段代码定义了x86/x64体系结构指令的反汇编逻辑。
//主要功能点包括:
//1. 定义了反汇编助手DisasmHelper类型。
//2. 定义指令信息InsInfo数据结构。
//3. 定义反汇编构建器DisasmBuilder。
//4. 定义操作数类型,如寄存器表达式OprReg等。 
//5. 提供操作数转字符串的函数,如oprToString。
//6. 提供前缀、指令名等组成部分转字符串的函数。
//7. disasm函数实现指令完整反汇编逻辑:
//   - 根据InsInfo信息构建字符串
//   - 构建前缀
//   - 构建指令名
//   - 构建每个操作数
//   - 返回整个反汇编字符串
//所以,这个模块定义了x86/x64体系结构完整的指令反汇编流程,可以将已解析的指令信息还原成易读的汇编文本表示。
//它与前端模块和后端模块配合,实现从机器码到中间代码再到汇编文本的完整翻译流程。

module internal B2R2.FrontEnd.BinLifter.Intel.Disasm

open B2R2
open B2R2.FrontEnd.BinLifter

let opCodeToString = function
  | Opcode.AAA -> "aaa"
  | Opcode.AAD -> "aad"
  | Opcode.AAM -> "aam"
  | Opcode.AAS -> "aas"
  | Opcode.ADC -> "adc"
  | Opcode.ADCX -> "adcx"
  | Opcode.ADD -> "add"
  | Opcode.ADDPD -> "addpd"
  | Opcode.ADDPS -> "addps"
  | Opcode.ADDSD -> "addsd"
  | Opcode.ADDSS -> "addss"
  | Opcode.ADDSUBPD -> "addsubpd"
  | Opcode.ADDSUBPS -> "addsubps"
  | Opcode.ADOX -> "adox"
  | Opcode.AESDEC -> "aesdec"
  | Opcode.AESDECLAST -> "aesdeclast"
  | Opcode.AESENC -> "aesenc"
  | Opcode.AESENCLAST -> "aesenclast"
  | Opcode.AESIMC -> "aesimc"
  | Opcode.AESKEYGENASSIST -> "aeskeygenassist"
  | Opcode.AND -> "and"
  | Opcode.ANDN -> "andn"
  | Opcode.ANDNPD -> "andnpd"
  | Opcode.ANDNPS -> "andnps"
  | Opcode.ANDPD -> "andpd"
  | Opcode.ANDPS -> "andps"
  | Opcode.ARPL -> "arpl"
  | Opcode.BEXTR -> "bextr"
  | Opcode.BLENDPD -> "blendpd"
  | Opcode.BLENDPS -> "blendps"
  | Opcode.BLENDVPD -> "blendvpd"
  | Opcode.BLENDVPS -> "blendvps"
  | Opcode.BLSI -> "blsi"
  | Opcode.BLSMSK -> "blsmsk"
  | Opcode.BLSR -> "blsr"
  | Opcode.BNDCL -> "bndcl"
  | Opcode.BNDCN -> "bndcn"
  | Opcode.BNDCU -> "bndcu"
  | Opcode.BNDLDX -> "bndldx"
  | Opcode.BNDMK -> "bndmk"
  | Opcode.BNDMOV -> "bndmov"
  | Opcode.BNDSTX -> "bndstx"
  | Opcode.BOUND -> "bound"
  | Opcode.BSF -> "bsf"
  | Opcode.BSR -> "bsr"
  | Opcode.BSWAP -> "bswap"
  | Opcode.BT -> "bt"
  | Opcode.BTC -> "btc"
  | Opcode.BTR -> "btr"
  | Opcode.BTS -> "bts"
  | Opcode.BZHI -> "bzhi"
  | Opcode.CALLFar | Opcode.CALLNear -> "call"
  | Opcode.CBW -> "cbw"
  | Opcode.CDQ -> "cdq"
  | Opcode.CDQE -> "cdqe"
  | Opcode.CLAC -> "clac"
  | Opcode.CLC -> "clc"
  | Opcode.CLD -> "cld"
  | Opcode.CLFLUSH -> "clflush"
  | Opcode.CLFLUSHOPT -> "clflushopt"
  | Opcode.CLI -> "cli"
  | Opcode.CLRSSBSY -> "clrssbsy"
  | Opcode.CLTS -> "clts"
  | Opcode.CLWB -> "clwb"
  | Opcode.CMC -> "cmc"
  | Opcode.CMOVA -> "cmova"
  | Opcode.CMOVAE -> "cmovae"
  | Opcode.CMOVB -> "cmovb"
  | Opcode.CMOVBE -> "cmovbe"
  | Opcode.CMOVC -> "cmovc"
  | Opcode.CMOVG -> "cmovg"
  | Opcode.CMOVGE -> "cmovge"
  | Opcode.CMOVL -> "cmovl"
  | Opcode.CMOVLE -> "cmovle"
  | Opcode.CMOVNC -> "cmovnc"
  | Opcode.CMOVNO -> "cmovno"
  | Opcode.CMOVNP -> "cmovnp"
  | Opcode.CMOVNS -> "cmovns"
  | Opcode.CMOVNZ -> "cmovnz"
  | Opcode.CMOVO -> "cmovo"
  | Opcode.CMOVP -> "cmovp"
  | Opcode.CMOVS -> "cmovs"
  | Opcode.CMOVZ -> "cmovz"
  | Opcode.CMP -> "cmp"
  | Opcode.CMPPD -> "cmppd"
  | Opcode.CMPPS -> "cmpps"
  | Opcode.CMPSB -> "cmpsb"
  | Opcode.CMPSD -> "cmpsd"
  | Opcode.CMPSQ -> "cmpsq"
  | Opcode.CMPSS -> "cmpss"
  | Opcode.CMPSW -> "cmpsw"
  | Opcode.CMPXCHG -> "cmpxchg"
  | Opcode.CMPXCHG16B -> "cmpxchg16b"
  | Opcode.CMPXCHG8B -> "cmpxchg8b"
  | Opcode.COMISD -> "comisd"
  | Opcode.COMISS -> "comiss"
  | Opcode.CPUID -> "cpuid"
  | Opcode.CQO -> "cqo"
  | Opcode.CRC32 -> "crc32"
  | Opcode.CVTDQ2PD -> "cvtdq2pd"
  | Opcode.CVTDQ2PS -> "cvtdq2ps"
  | Opcode.CVTPD2DQ -> "cvtpd2dq"
  | Opcode.CVTPD2PI -> "cvtpd2pi"
  | Opcode.CVTPD2PS -> "cvtpd2ps"
  | Opcode.CVTPI2PD -> "cvtpi2pd"
  | Opcode.CVTPI2PS -> "cvtpi2ps"
  | Opcode.CVTPS2DQ -> "cvtps2dq"
  | Opcode.CVTPS2PD -> "cvtps2pd"
  | Opcode.CVTPS2PI -> "cvtps2pi"
  | Opcode.CVTSD2SI -> "cvtsd2si"
  | Opcode.CVTSD2SS -> "cvtsd2ss"
  | Opcode.CVTSI2SD -> "cvtsi2sd"
  | Opcode.CVTSI2SS -> "cvtsi2ss"
  | Opcode.CVTSS2SD -> "cvtss2sd"
  | Opcode.CVTSS2SI -> "cvtss2si"
  | Opcode.CVTTPD2DQ -> "cvttpd2dq"
  | Opcode.CVTTPD2PI -> "cvttpd2pi"
  | Opcode.CVTTPS2DQ -> "cvttps2dq"
  | Opcode.CVTTPS2PI -> "cvttps2pi"
  | Opcode.CVTTSD2SI -> "cvttsd2si"
  | Opcode.CVTTSS2SI -> "cvttss2si"
  | Opcode.CWD -> "cwd"
  | Opcode.CWDE -> "cwde"
  | Opcode.DAA -> "daa"
  | Opcode.DAS -> "das"
  | Opcode.DEC -> "dec"
  | Opcode.DIV -> "div"
  | Opcode.DIVPD -> "divpd"
  | Opcode.DIVPS -> "divps"
  | Opcode.DIVSD -> "divsd"
  | Opcode.DIVSS -> "divss"
  | Opcode.DPPD -> "dppd"
  | Opcode.DPPS -> "dpps"
  | Opcode.EMMS -> "emms"
  | Opcode.ENCLS -> "encls"
  | Opcode.ENCLU -> "enclu"
  | Opcode.ENDBR32 -> "endbr32"
  | Opcode.ENDBR64 -> "endbr64"
  | Opcode.ENTER -> "enter"
  | Opcode.EXTRACTPS -> "extractps"
  | Opcode.EXTRQ -> "extrq"
  | Opcode.F2XM1 -> "f2xm1"
  | Opcode.FABS -> "fabs"
  | Opcode.FADD -> "fadd"
  | Opcode.FADDP -> "faddp"
  | Opcode.FBLD -> "fbld"
  | Opcode.FBSTP -> "fbstp"
  | Opcode.FCHS -> "fchs"
  | Opcode.FCLEX -> "fclex"
  | Opcode.FCMOVB -> "fcmovb"
  | Opcode.FCMOVBE -> "fcmovbe"
  | Opcode.FCMOVE -> "fcmove"
  | Opcode.FCMOVNB -> "fcmovnb"
  | Opcode.FCMOVNBE -> "fcmovnbe"
  | Opcode.FCMOVNE -> "fcmovne"
  | Opcode.FCMOVNU -> "fcmovnu"
  | Opcode.FCMOVU -> "fcmovu"
  | Opcode.FCOM -> "fcom"
  | Opcode.FCOMI -> "fcomi"
  | Opcode.FCOMIP -> "fcomip"
  | Opcode.FCOMP -> "fcomp"
  | Opcode.FCOMPP -> "fcompp"
  | Opcode.FCOS -> "fcos"
  | Opcode.FDECSTP -> "fdecstp"
  | Opcode.FDIV -> "fdiv"
  | Opcode.FDIVP -> "fdivp"
  | Opcode.FDIVR -> "fdivr"
  | Opcode.FDIVRP -> "fdivrp"
  | Opcode.FFREE -> "ffree"
  | Opcode.FFREEP -> "ffreep"
  | Opcode.FIADD -> "fiadd"
  | Opcode.FICOM -> "ficom"
  | Opcode.FICOMP -> "ficomp"
  | Opcode.FIDIV -> "fidiv"
  | Opcode.FIDIVR -> "fidivr"
  | Opcode.FILD -> "fild"
  | Opcode.FIMUL -> "fimul"
  | Opcode.FINCSTP -> "fincstp"
  | Opcode.FINIT -> "finit"
  | Opcode.FIST -> "fist"
  | Opcode.FISTP -> "fistp"
  | Opcode.FISTTP -> "fisttp"
  | Opcode.FISUB -> "fisub"
  | Opcode.FISUBR -> "fisubr"
  | Opcode.FLD -> "fld"
  | Opcode.FLD1 -> "fld1"
  | Opcode.FLDCW -> "fldcw"
  | Opcode.FLDENV -> "fldenv"
  | Opcode.FLDL2E -> "fldl2e"
  | Opcode.FLDL2T -> "fldl2t"
  | Opcode.FLDLG2 -> "fldlg2"
  | Opcode.FLDLN2 -> "fldln2"
  | Opcode.FLDPI -> "fldpi"
  | Opcode.FLDZ -> "fldz"
  | Opcode.FMUL -> "fmul"
  | Opcode.FMULP -> "fmulp"
  | Opcode.FNCLEX -> "fnclex"
  | Opcode.FNINIT -> "fninit"
  | Opcode.FNOP -> "fnop"
  | Opcode.FNSAVE -> "fnsave"
  | Opcode.FNSTCW -> "fnstcw"
  | Opcode.FNSTENV -> "fnstenv"
  | Opcode.FNSTSW -> "fnstsw"
  | Opcode.FPATAN -> "fpatan"
  | Opcode.FPREM -> "fprem"
  | Opcode.FPREM1 -> "fprem1"
  | Opcode.FPTAN -> "fptan"
  | Opcode.FRNDINT -> "frndint"
  | Opcode.FRSTOR -> "frstor"
  | Opcode.FSAVE -> "fsave"
  | Opcode.FSCALE -> "fscale"
  | Opcode.FSIN -> "fsin"
  | Opcode.FSINCOS -> "fsincos"
  | Opcode.FSQRT -> "fsqrt"
  | Opcode.FST -> "fst"
  | Opcode.FSTCW -> "fstcw"
  | Opcode.FSTENV -> "fstenv"
  | Opcode.FSTP -> "fstp"
  | Opcode.FSTSW -> "fstsw"
  | Opcode.FSUB -> "fsub"
  | Opcode.FSUBP -> "fsubp"
  | Opcode.FSUBR -> "fsubr"
  | Opcode.FSUBRP -> "fsubrp"
  | Opcode.FTST -> "ftst"
  | Opcode.FUCOM -> "fucom"
  | Opcode.FUCOMI -> "fucomi"
  | Opcode.FUCOMIP -> "fucomip"
  | Opcode.FUCOMP -> "fucomp"
  | Opcode.FUCOMPP -> "fucompp"
  | Opcode.FWAIT -> "fwait"
  | Opcode.FXAM -> "fxam"
  | Opcode.FXCH -> "fxch"
  | Opcode.FXRSTOR -> "fxrstor"
  | Opcode.FXRSTOR64 -> "fxrstor64"
  | Opcode.FXSAVE -> "fxsave"
  | Opcode.FXSAVE64 -> "fxsave64"
  | Opcode.FXTRACT -> "fxtract"
  | Opcode.FYL2X -> "fyl2x"
  | Opcode.FYL2XP1 -> "fyl2xp1"
  | Opcode.GETSEC -> "getsec"
  | Opcode.GF2P8AFFINEINVQB -> "gf2p8affineinvqb"
  | Opcode.GF2P8AFFINEQB -> "gf2p8affineqb"
  | Opcode.GF2P8MULB -> "gf2p8mulb"
  | Opcode.HADDPD -> "haddpd"
  | Opcode.HADDPS -> "haddps"
  | Opcode.HLT -> "hlt"
  | Opcode.HSUBPD -> "hsubpd"
  | Opcode.HSUBPS -> "hsubps"
  | Opcode.IDIV -> "idiv"
  | Opcode.IMUL -> "imul"
  | Opcode.IN -> "in"
  | Opcode.INC -> "inc"
  | Opcode.INCSSPD -> "incsspd"
  | Opcode.INCSSPQ -> "incsspq"
  | Opcode.INS -> "ins"
  | Opcode.INSB -> "insb"
  | Opcode.INSD -> "insd"
  | Opcode.INSERTPS -> "insertps"
  | Opcode.INSERTQ -> "insertq"
  | Opcode.INSW -> "insw"
  | Opcode.INT -> "int"
  | Opcode.INT3 -> "int3"
  | Opcode.INTO -> "into"
  | Opcode.INVD -> "invd"
  | Opcode.INVEPT -> "invept"
  | Opcode.INVLPG -> "invlpg"
  | Opcode.INVPCID -> "invpcid"
  | Opcode.INVVPID -> "invvpid"
  | Opcode.IRET -> "iret"
  | Opcode.IRETD -> "iretd"
  | Opcode.IRETQ -> "iretq"
  | Opcode.IRETW -> "iretw"
  | Opcode.JNB -> "jnb"
  | Opcode.JB -> "jb"
  | Opcode.JCXZ -> "jcxz"
  | Opcode.JECXZ -> "jecxz"
  | Opcode.JNL -> "jnl"
  | Opcode.JMPFar | Opcode.JMPNear -> "jmp"
  | Opcode.JBE -> "jbe"
  | Opcode.JA -> "ja"
  | Opcode.JLE -> "jle"
  | Opcode.JL -> "jl"
  | Opcode.JG -> "jg"
  | Opcode.JNO -> "jno"
  | Opcode.JNS -> "jns"
  | Opcode.JNZ -> "jnz"
  | Opcode.JO -> "jo"
  | Opcode.JP -> "jp"
  | Opcode.JNP -> "jnp"
  | Opcode.JRCXZ -> "jrcxz"
  | Opcode.JS -> "js"
  | Opcode.JZ -> "jz"
  | Opcode.KADDB -> "kaddb"
  | Opcode.KADDD -> "kaddd"
  | Opcode.KADDQ -> "kaddq"
  | Opcode.KADDW -> "kaddw"
  | Opcode.KANDB -> "kandb"
  | Opcode.KANDD -> "kandd"
  | Opcode.KANDNB -> "kandnb"
  | Opcode.KANDND -> "kandnd"
  | Opcode.KANDNQ -> "kandnq"
  | Opcode.KANDNW -> "kandnw"
  | Opcode.KANDQ -> "kandq"
  | Opcode.KANDW -> "kandw"
  | Opcode.KMOVB -> "kmovb"
  | Opcode.KMOVD -> "kmovd"
  | Opcode.KMOVQ -> "kmovq"
  | Opcode.KMOVW -> "kmovw"
  | Opcode.KNOTB -> "knotb"
  | Opcode.KNOTD -> "knotd"
  | Opcode.KNOTQ -> "knotq"
  | Opcode.KNOTW -> "knotw"
  | Opcode.KORB -> "korb"
  | Opcode.KORD -> "kord"
  | Opcode.KORQ -> "korq"
  | Opcode.KORTESTB -> "kortestb"
  | Opcode.KORTESTD -> "kortestd"
  | Opcode.KORTESTQ -> "kortestq"
  | Opcode.KORTESTW -> "kortestw"
  | Opcode.KORW -> "korw"
  | Opcode.KSHIFTLB -> "kshiftlb"
  | Opcode.KSHIFTLD -> "kshiftld"
  | Opcode.KSHIFTLQ -> "kshiftlq"
  | Opcode.KSHIFTLW -> "kshiftlw"
  | Opcode.KSHIFTRB -> "kshiftrb"
  | Opcode.KSHIFTRD -> "kshiftrd"
  | Opcode.KSHIFTRQ -> "kshiftrq"
  | Opcode.KSHIFTRW -> "kshiftrw"
  | Opcode.KTESTB -> "ktestb"
  | Opcode.KTESTD -> "ktestd"
  | Opcode.KTESTQ -> "ktestq"
  | Opcode.KTESTW -> "ktestw"
  | Opcode.KUNPCKBW -> "kunpckbw"
  | Opcode.KUNPCKDQ -> "kunpckdq"
  | Opcode.KUNPCKWD -> "kunpckwd"
  | Opcode.KXNORB -> "kxnorb"
  | Opcode.KXNORD -> "kxnord"
  | Opcode.KXNORQ -> "kxnorq"
  | Opcode.KXNORW -> "kxnorw"
  | Opcode.KXORB -> "kxorb"
  | Opcode.KXORD -> "kxord"
  | Opcode.KXORQ -> "kxorq"
  | Opcode.KXORW -> "kxorw"
  | Opcode.LAHF -> "lahf"
  | Opcode.LAR -> "lar"
  | Opcode.LDDQU -> "lddqu"
  | Opcode.LDMXCSR -> "ldmxcsr"
  | Opcode.LDS -> "lds"
  | Opcode.LEA -> "lea"
  | Opcode.LEAVE -> "leave"
  | Opcode.LES -> "les"
  | Opcode.LFENCE -> "lfence"
  | Opcode.LFS -> "lfs"
  | Opcode.LGDT -> "lgdt"
  | Opcode.LGS -> "lgs"
  | Opcode.LIDT -> "lidt"
  | Opcode.LLDT -> "lldt"
  | Opcode.LMSW -> "lmsw"
  | Opcode.LOCK -> "lock"
  | Opcode.LODSB -> "lodsb"
  | Opcode.LODSD -> "lodsd"
  | Opcode.LODSQ -> "lodsq"
  | Opcode.LODSW -> "lodsw"
  | Opcode.LOOP -> "loop"
  | Opcode.LOOPE -> "loope"
  | Opcode.LOOPNE -> "loopne"
  | Opcode.LSL -> "lsl"
  | Opcode.LSS -> "lss"
  | Opcode.LTR -> "ltr"
  | Opcode.LZCNT -> "lzcnt"
  | Opcode.MASKMOVDQU -> "maskmovdqu"
  | Opcode.MASKMOVQ -> "maskmovq"
  | Opcode.MAXPD -> "maxpd"
  | Opcode.MAXPS -> "maxps"
  | Opcode.MAXSD -> "maxsd"
  | Opcode.MAXSS -> "maxss"
  | Opcode.MFENCE -> "mfence"
  | Opcode.MINPD -> "minpd"
  | Opcode.MINPS -> "minps"
  | Opcode.MINSD -> "minsd"
  | Opcode.MINSS -> "minss"
  | Opcode.MONITOR -> "monitor"
  | Opcode.MOV -> "mov"
  | Opcode.MOVAPD -> "movapd"
  | Opcode.MOVAPS -> "movaps"
  | Opcode.MOVBE -> "movbe"
  | Opcode.MOVD -> "movd"
  | Opcode.MOVDDUP -> "movddup"
  | Opcode.MOVDQ2Q -> "movdq2q"
  | Opcode.MOVDQA -> "movdqa"
  | Opcode.MOVDQU -> "movdqu"
  | Opcode.MOVHLPS -> "movhlps"
  | Opcode.MOVHPD -> "movhpd"
  | Opcode.MOVHPS -> "movhps"
  | Opcode.MOVLHPS -> "movlhps"
  | Opcode.MOVLPD -> "movlpd"
  | Opcode.MOVLPS -> "movlps"
  | Opcode.MOVMSKPD -> "movmskpd"
  | Opcode.MOVMSKPS -> "movmskps"
  | Opcode.MOVNTDQ -> "movntdq"
  | Opcode.MOVNTDQA -> "movntdqa"
  | Opcode.MOVNTI -> "movnti"
  | Opcode.MOVNTPD -> "movntpd"
  | Opcode.MOVNTPS -> "movntps"
  | Opcode.MOVNTQ -> "movntq"
  | Opcode.MOVQ -> "movq"
  | Opcode.MOVQ2DQ -> "movq2dq"
  | Opcode.MOVSB -> "movsb"
  | Opcode.MOVSD -> "movsd"
  | Opcode.MOVSHDUP -> "movshdup"
  | Opcode.MOVSLDUP -> "movsldup"
  | Opcode.MOVSQ -> "movsq"
  | Opcode.MOVSS -> "movss"
  | Opcode.MOVSW -> "movsw"
  | Opcode.MOVSX -> "movsx"
  | Opcode.MOVSXD -> "movsxd"
  | Opcode.MOVUPD -> "movupd"
  | Opcode.MOVUPS -> "movups"
  | Opcode.MOVZX -> "movzx"
  | Opcode.MPSADBW -> "mpsadbw"
  | Opcode.MUL -> "mul"
  | Opcode.MULPD -> "mulpd"
  | Opcode.MULPS -> "mulps"
  | Opcode.MULSD -> "mulsd"
  | Opcode.MULSS -> "mulss"
  | Opcode.MULX -> "mulx"
  | Opcode.MWAIT -> "mwait"
  | Opcode.NEG -> "neg"
  | Opcode.NOP -> "nop"
  | Opcode.NOT -> "not"
  | Opcode.OR -> "or"
  | Opcode.ORPD -> "orpd"
  | Opcode.ORPS -> "orps"
  | Opcode.OUT -> "out"
  | Opcode.OUTS -> "outs"
  | Opcode.OUTSB -> "outsb"
  | Opcode.OUTSD -> "outsd"
  | Opcode.OUTSW -> "outsw"
  | Opcode.PABSB -> "pabsb"
  | Opcode.PABSD -> "pabsd"
  | Opcode.PABSW -> "pabsw"
  | Opcode.PACKSSDW -> "packssdw"
  | Opcode.PACKSSWB -> "packsswb"
  | Opcode.PACKUSDW -> "packusdw"
  | Opcode.PACKUSWB -> "packuswb"
  | Opcode.PADDB -> "paddb"
  | Opcode.PADDD -> "paddd"
  | Opcode.PADDQ -> "paddq"
  | Opcode.PADDSB -> "paddsb"
  | Opcode.PADDSW -> "paddsw"
  | Opcode.PADDUSB -> "paddusb"
  | Opcode.PADDUSW -> "paddusw"
  | Opcode.PADDW -> "paddw"
  | Opcode.PALIGNR -> "palignr"
  | Opcode.PAND -> "pand"
  | Opcode.PANDN -> "pandn"
  | Opcode.PAUSE -> "pause"
  | Opcode.PAVGB -> "pavgb"
  | Opcode.PAVGW -> "pavgw"
  | Opcode.PBLENDVB -> "pblendvb"
  | Opcode.PBLENDW -> "pblendw"
  | Opcode.PCLMULQDQ -> "pclmulqdq"
  | Opcode.PCMPEQB -> "pcmpeqb"
  | Opcode.PCMPEQD -> "pcmpeqd"
  | Opcode.PCMPEQQ -> "pcmpeqq"
  | Opcode.PCMPEQW -> "pcmpeqw"
  | Opcode.PCMPESTRI -> "pcmpestri"
  | Opcode.PCMPESTRM -> "pcmpestrm"
  | Opcode.PCMPGTB -> "pcmpgtb"
  | Opcode.PCMPGTD -> "pcmpgtd"
  | Opcode.PCMPGTQ -> "pcmpgtq"
  | Opcode.PCMPGTW -> "pcmpgtw"
  | Opcode.PCMPISTRI -> "pcmpistri"
  | Opcode.PCMPISTRM -> "pcmpistrm"
  | Opcode.PDEP -> "pdep"
  | Opcode.PEXT -> "pext"
  | Opcode.PEXTRB -> "pextrb"
  | Opcode.PEXTRD -> "pextrd"
  | Opcode.PEXTRQ -> "pextrq"
  | Opcode.PEXTRW -> "pextrw"
  | Opcode.PHADDD -> "phaddd"
  | Opcode.PHADDSW -> "phaddsw"
  | Opcode.PHADDW -> "phaddw"
  | Opcode.PHMINPOSUW -> "phminposuw"
  | Opcode.PHSUBD -> "phsubd"
  | Opcode.PHSUBSW -> "phsubsw"
  | Opcode.PHSUBW -> "phsubw"
  | Opcode.PINSRB -> "pinsrb"
  | Opcode.PINSRD -> "pinsrd"
  | Opcode.PINSRQ -> "pinsrq"
  | Opcode.PINSRW -> "pinsrw"
  | Opcode.PMADDUBSW -> "pmaddubsw"
  | Opcode.PMADDWD -> "pmaddwd"
  | Opcode.PMAXSB -> "pmaxsb"
  | Opcode.PMAXSD -> "pmaxsd"
  | Opcode.PMAXSW -> "pmaxsw"
  | Opcode.PMAXUB -> "pmaxub"
  | Opcode.PMAXUD -> "pmaxud"
  | Opcode.PMAXUW -> "pmaxuw"
  | Opcode.PMINSB -> "pminsb"
  | Opcode.PMINSD -> "pminsd"
  | Opcode.PMINSW -> "pminsw"
  | Opcode.PMINUB -> "pminub"
  | Opcode.PMINUD -> "pminud"
  | Opcode.PMINUW -> "pminuw"
  | Opcode.PMOVMSKB -> "pmovmskb"
  | Opcode.PMOVSXBD -> "pmovsxbd"
  | Opcode.PMOVSXBQ -> "pmovsxbq"
  | Opcode.PMOVSXBW -> "pmovsxbw"
  | Opcode.PMOVSXDQ -> "pmovsxdq"
  | Opcode.PMOVSXWD -> "pmovsxwd"
  | Opcode.PMOVSXWQ -> "pmovsxwq"
  | Opcode.PMOVZXBD -> "pmovzxbd"
  | Opcode.PMOVZXBQ -> "pmovzxbq"
  | Opcode.PMOVZXBW -> "pmovzxbw"
  | Opcode.PMOVZXDQ -> "pmovzxdq"
  | Opcode.PMOVZXWD -> "pmovzxwd"
  | Opcode.PMOVZXWQ -> "pmovzxwq"
  | Opcode.PMULDQ -> "pmuldq"
  | Opcode.PMULHRSW -> "pmulhrsw"
  | Opcode.PMULHUW -> "pmulhuw"
  | Opcode.PMULHW -> "pmulhw"
  | Opcode.PMULLD -> "pmulld"
  | Opcode.PMULLW -> "pmullw"
  | Opcode.PMULUDQ -> "pmuludq"
  | Opcode.POP -> "pop"
  | Opcode.POPA -> "popa"
  | Opcode.POPAD -> "popad"
  | Opcode.POPCNT -> "popcnt"
  | Opcode.POPF -> "popf"
  | Opcode.POPFD -> "popfd"
  | Opcode.POPFQ -> "popfq"
  | Opcode.POR -> "por"
  | Opcode.PREFETCHNTA -> "prefetchnta"
  | Opcode.PREFETCHT0 -> "prefetcht0"
  | Opcode.PREFETCHT1 -> "prefetcht1"
  | Opcode.PREFETCHT2 -> "prefetcht2"
  | Opcode.PREFETCHW -> "prefetchw"
  | Opcode.PREFETCHWT1 -> "prefetchwt1"
  | Opcode.PSADBW -> "psadbw"
  | Opcode.PSHUFB -> "pshufb"
  | Opcode.PSHUFD -> "pshufd"
  | Opcode.PSHUFHW -> "pshufhw"
  | Opcode.PSHUFLW -> "pshuflw"
  | Opcode.PSHUFW -> "pshufw"
  | Opcode.PSIGNB -> "psignb"
  | Opcode.PSIGND -> "psignd"
  | Opcode.PSIGNW -> "psignw"
  | Opcode.PSLLD -> "pslld"
  | Opcode.PSLLDQ -> "pslldq"
  | Opcode.PSLLQ -> "psllq"
  | Opcode.PSLLW -> "psllw"
  | Opcode.PSRAD -> "psrad"
  | Opcode.PSRAW -> "psraw"
  | Opcode.PSRLD -> "psrld"
  | Opcode.PSRLDQ -> "psrldq"
  | Opcode.PSRLQ -> "psrlq"
  | Opcode.PSRLW -> "psrlw"
  | Opcode.PSUBB -> "psubb"
  | Opcode.PSUBD -> "psubd"
  | Opcode.PSUBQ -> "psubq"
  | Opcode.PSUBSB -> "psubsb"
  | Opcode.PSUBSW -> "psubsw"
  | Opcode.PSUBUSB -> "psubusb"
  | Opcode.PSUBUSW -> "psubusw"
  | Opcode.PSUBW -> "psubw"
  | Opcode.PTEST -> "ptest"
  | Opcode.PUNPCKHBW -> "punpckhbw"
  | Opcode.PUNPCKHDQ -> "punpckhdq"
  | Opcode.PUNPCKHQDQ -> "punpckhqdq"
  | Opcode.PUNPCKHWD -> "punpckhwd"
  | Opcode.PUNPCKLBW -> "punpcklbw"
  | Opcode.PUNPCKLDQ -> "punpckldq"
  | Opcode.PUNPCKLQDQ -> "punpcklqdq"
  | Opcode.PUNPCKLWD -> "punpcklwd"
  | Opcode.PUSH -> "push"
  | Opcode.PUSHA -> "pusha"
  | Opcode.PUSHAD -> "pushad"
  | Opcode.PUSHF -> "pushf"
  | Opcode.PUSHFD -> "pushfd"
  | Opcode.PUSHFQ -> "pushfq"
  | Opcode.PXOR -> "pxor"
  | Opcode.RCL -> "rcl"
  | Opcode.RCPPS -> "rcpps"
  | Opcode.RCPSS -> "rcpss"
  | Opcode.RCR -> "rcr"
  | Opcode.RDFSBASE -> "rdfsbase"
  | Opcode.RDGSBASE -> "rdgsbase"
  | Opcode.RDMSR -> "rdmsr"
  | Opcode.RDPKRU -> "rdpkru"
  | Opcode.RDPMC -> "rdpmc"
  | Opcode.RDRAND -> "rdrand"
  | Opcode.RDSEED -> "rdseed"
  | Opcode.RDSSPD -> "rdsspd"
  | Opcode.RDSSPQ -> "rdsspq"
  | Opcode.RDTSC -> "rdtsc"
  | Opcode.RDTSCP -> "rdtscp"
  | Opcode.REP -> "rep"
  | Opcode.REPE -> "repe"
  | Opcode.REPNE -> "repne"
  | Opcode.REPNZ -> "repnz"
  | Opcode.REPZ -> "repz"
  | Opcode.RETFar | Opcode.RETFarImm
  | Opcode.RETNear | Opcode.RETNearImm -> "ret"
  | Opcode.ROL -> "rol"
  | Opcode.ROR -> "ror"
  | Opcode.RORX -> "rorx"
  | Opcode.ROUNDPD -> "roundpd"
  | Opcode.ROUNDPS -> "roundps"
  | Opcode.ROUNDSD -> "roundsd"
  | Opcode.ROUNDSS -> "roundss"
  | Opcode.RSM -> "rsm"
  | Opcode.RSQRTPS -> "rsqrtps"
  | Opcode.RSQRTSS -> "rsqrtss"
  | Opcode.RSTORSSP -> "rstorssp"
  | Opcode.SAHF -> "sahf"
  | Opcode.SAR -> "sar"
  | Opcode.SARX -> "sarx"
  | Opcode.SAVEPREVSSP -> "saveprevssp"
  | Opcode.SBB -> "sbb"
  | Opcode.SCASB -> "scasb"
  | Opcode.SCASD -> "scasd"
  | Opcode.SCASQ -> "scasq"
  | Opcode.SCASW -> "scasw"
  | Opcode.SETA -> "seta"
  | Opcode.SETB -> "setb"
  | Opcode.SETBE -> "setbe"
  | Opcode.SETG -> "setg"
  | Opcode.SETL -> "setl"
  | Opcode.SETLE -> "setle"
  | Opcode.SETNB -> "setnb"
  | Opcode.SETNL -> "setnl"
  | Opcode.SETNO -> "setno"
  | Opcode.SETNP -> "setnp"
  | Opcode.SETNS -> "setns"
  | Opcode.SETNZ -> "setnz"
  | Opcode.SETO -> "seto"
  | Opcode.SETP -> "setp"
  | Opcode.SETS -> "sets"
  | Opcode.SETSSBSY -> "setssbsy"
  | Opcode.SETZ -> "setz"
  | Opcode.SFENCE -> "sfence"
  | Opcode.SGDT -> "sgdt"
  | Opcode.SHA1MSG1 -> "sha1msg1"
  | Opcode.SHA1MSG2 -> "sha1msg2"
  | Opcode.SHA1NEXTE -> "sha1nexte"
  | Opcode.SHA1RNDS4 -> "sha1rnds4"
  | Opcode.SHA256MSG1 -> "sha256msg1"
  | Opcode.SHA256MSG2 -> "sha256msg2"
  | Opcode.SHA256RNDS2 -> "sha256rnds2"
  | Opcode.SHL -> "shl"
  | Opcode.SHLD -> "shld"
  | Opcode.SHLX -> "shlx"
  | Opcode.SHR -> "shr"
  | Opcode.SHRD -> "shrd"
  | Opcode.SHRX -> "shrx"
  | Opcode.SHUFPD -> "shufpd"
  | Opcode.SHUFPS -> "shufps"
  | Opcode.SIDT -> "sidt"
  | Opcode.SLDT -> "sldt"
  | Opcode.SMSW -> "smsw"
  | Opcode.SQRTPD -> "sqrtpd"
  | Opcode.SQRTPS -> "sqrtps"
  | Opcode.SQRTSD -> "sqrtsd"
  | Opcode.SQRTSS -> "sqrtss"
  | Opcode.STAC -> "stac"
  | Opcode.STC -> "stc"
  | Opcode.STD -> "std"
  | Opcode.STI -> "sti"
  | Opcode.STMXCSR -> "stmxcsr"
  | Opcode.STOSB -> "stosb"
  | Opcode.STOSD -> "stosd"
  | Opcode.STOSQ -> "stosq"
  | Opcode.STOSW -> "stosw"
  | Opcode.STR -> "str"
  | Opcode.SUB -> "sub"
  | Opcode.SUBPD -> "subpd"
  | Opcode.SUBPS -> "subps"
  | Opcode.SUBSD -> "subsd"
  | Opcode.SUBSS -> "subss"
  | Opcode.SWAPGS -> "swapgs"
  | Opcode.SYSCALL -> "syscall"
  | Opcode.SYSENTER -> "sysenter"
  | Opcode.SYSEXIT -> "sysexit"
  | Opcode.SYSRET -> "sysret"
  | Opcode.TEST -> "test"
  | Opcode.TZCNT -> "tzcnt"
  | Opcode.UCOMISD -> "ucomisd"
  | Opcode.UCOMISS -> "ucomiss"
  | Opcode.UD -> "ud"
  | Opcode.UD2 -> "ud2"
  | Opcode.UNPCKHPD -> "unpckhpd"
  | Opcode.UNPCKHPS -> "unpckhps"
  | Opcode.UNPCKLPD -> "unpcklpd"
  | Opcode.UNPCKLPS -> "unpcklps"
  | Opcode.V4FMADDPS -> "v4fmaddps"
  | Opcode.V4FMADDSS -> "v4fmaddss"
  | Opcode.V4FNMADDPS -> "v4fnmaddps"
  | Opcode.V4FNMADDSS -> "v4fnmaddss"
  | Opcode.VADDPD -> "vaddpd"
  | Opcode.VADDPS -> "vaddps"
  | Opcode.VADDSD -> "vaddsd"
  | Opcode.VADDSS -> "vaddss"
  | Opcode.VADDSUBPD -> "vaddsubpd"
  | Opcode.VADDSUBPS -> "vaddsubps"
  | Opcode.VAESDEC -> "vaesdec"
  | Opcode.VAESDECLAST -> "vaesdeclast"
  | Opcode.VAESENC -> "vaesenc"
  | Opcode.VAESENCLAST -> "vaesenclast"
  | Opcode.VALIGND -> "valignd"
  | Opcode.VALIGNQ -> "valignq"
  | Opcode.VANDNPD -> "vandnpd"
  | Opcode.VANDNPS -> "vandnps"
  | Opcode.VANDPD -> "vandpd"
  | Opcode.VANDPS -> "vandps"
  | Opcode.VBLENDMPD -> "vblendmpd"
  | Opcode.VBLENDMPS -> "vblendmps"
  | Opcode.VBLENDPD -> "vblendpd"
  | Opcode.VBLENDPS -> "vblendps"
  | Opcode.VBLENDVPD -> "vblendvpd"
  | Opcode.VBLENDVPS -> "vblendvps"
  | Opcode.VBROADCASTF128 -> "vbroadcastf128"
  | Opcode.VBROADCASTI128 -> "vbroadcasti128"
  | Opcode.VBROADCASTI32X2 -> "vbroadcasti32x2"
  | Opcode.VBROADCASTI32X4 -> "vbroadcasti32x4"
  | Opcode.VBROADCASTI32X8 -> "vbroadcasti32x8"
  | Opcode.VBROADCASTI64X2 -> "vbroadcasti64x2"
  | Opcode.VBROADCASTI64X4 -> "vbroadcasti64x4"
  | Opcode.VBROADCASTSD -> "vbroadcastsd"
  | Opcode.VBROADCASTSS -> "vbroadcastss"
  | Opcode.VCMPPD -> "vcmppd"
  | Opcode.VCMPPS -> "vcmpps"
  | Opcode.VCMPSD -> "vcmpsd"
  | Opcode.VCMPSS -> "vcmpss"
  | Opcode.VCOMISD -> "vcomisd"
  | Opcode.VCOMISS -> "vcomiss"
  | Opcode.VCOMPRESSPD -> "vcompresspd"
  | Opcode.VCOMPRESSPS -> "vcompressps"
  | Opcode.VCVTDQ2PD -> "vcvtdq2pd"
  | Opcode.VCVTDQ2PS -> "vcvtdq2ps"
  | Opcode.VCVTNE2PS2BF16 -> "vcvtne2ps2bf16"
  | Opcode.VCVTNEPS2BF16 -> "vcvtneps2bf16"
  | Opcode.VCVTPD2DQ -> "vcvtpd2dq"
  | Opcode.VCVTPD2PS -> "vcvtpd2ps"
  | Opcode.VCVTPD2QQ -> "vcvtpd2qq"
  | Opcode.VCVTPD2UDQ -> "vcvtpd2udq"
  | Opcode.VCVTPD2UQQ -> "vcvtpd2uqq"
  | Opcode.VCVTPH2PS -> "vcvtph2ps"
  | Opcode.VCVTPS2PD -> "vcvtps2pd"
  | Opcode.VCVTPS2PH -> "vcvtps2ph"
  | Opcode.VCVTPS2QQ -> "vcvtps2qq"
  | Opcode.VCVTPS2UDQ -> "vcvtps2udq"
  | Opcode.VCVTPS2UQQ -> "vcvtps2uqq"
  | Opcode.VCVTQQ2PD -> "vcvtqq2pd"
  | Opcode.VCVTQQ2PS -> "vcvtqq2ps"
  | Opcode.VCVTSD2SI -> "vcvtsd2si"
  | Opcode.VCVTSD2SS -> "vcvtsd2ss"
  | Opcode.VCVTSD2USI -> "vcvtsd2usi"
  | Opcode.VCVTSI2SD -> "vcvtsi2sd"
  | Opcode.VCVTSI2SS -> "vcvtsi2ss"
  | Opcode.VCVTSS2SD -> "vcvtss2sd"
  | Opcode.VCVTSS2SI -> "vcvtss2si"
  | Opcode.VCVTSS2USI -> "vcvtss2usi"
  | Opcode.VCVTTPD2DQ -> "vcvttpd2dq"
  | Opcode.VCVTTPD2QQ -> "vcvttpd2qq"
  | Opcode.VCVTTPD2UDQ -> "vcvttpd2udq"
  | Opcode.VCVTTPD2UQQ -> "vcvttpd2uqq"
  | Opcode.VCVTTPS2DQ -> "vcvttps2dq"
  | Opcode.VCVTTPS2QQ -> "vcvttps2qq"
  | Opcode.VCVTTPS2UDQ -> "vcvttps2udq"
  | Opcode.VCVTTPS2UQQ -> "vcvttps2uqq"
  | Opcode.VCVTTSD2SI -> "vcvttsd2si"
  | Opcode.VCVTTSD2USI -> "vcvttsd2usi"
  | Opcode.VCVTTSS2SI -> "vcvttss2si"
  | Opcode.VCVTTSS2USI -> "vcvttss2usi"
  | Opcode.VCVTUDQ2PD -> "vcvtudq2pd"
  | Opcode.VCVTUDQ2PS -> "vcvtudq2ps"
  | Opcode.VCVTUQQ2PD -> "vcvtuqq2pd"
  | Opcode.VCVTUQQ2PS -> "vcvtuqq2ps"
  | Opcode.VCVTUSI2SD -> "vcvtusi2sd"
  | Opcode.VCVTUSI2SS -> "vcvtusi2ss"
  | Opcode.VCVTUSI2USD -> "vcvtusi2usd"
  | Opcode.VCVTUSI2USS -> "vcvtusi2uss"
  | Opcode.VDBPSADBW -> "vdbpsadbw"
  | Opcode.VDIVPD -> "vdivpd"
  | Opcode.VDIVPS -> "vdivps"
  | Opcode.VDIVSD -> "vdivsd"
  | Opcode.VDIVSS -> "vdivss"
  | Opcode.VDPBF16PS -> "vdpbf16ps"
  | Opcode.VERR -> "verr"
  | Opcode.VERW -> "verw"
  | Opcode.VEXP2PD -> "vexp2pd"
  | Opcode.VEXP2PS -> "vexp2ps"
  | Opcode.VEXP2SD -> "vexp2sd"
  | Opcode.VEXP2SS -> "vexp2ss"
  | Opcode.VEXPANDPD -> "vexpandpd"
  | Opcode.VEXPANDPS -> "vexpandps"
  | Opcode.VEXTRACTF128 -> "vextractf128"
  | Opcode.VEXTRACTF32X4 -> "vextractf32x4"
  | Opcode.VEXTRACTF32X8 -> "vextractf32x8"
  | Opcode.VEXTRACTF64X2 -> "vextractf64x2"
  | Opcode.VEXTRACTF64X4 -> "vextractf64x4"
  | Opcode.VEXTRACTI128 -> "vextracti128"
  | Opcode.VEXTRACTI32X4 -> "vextracti32x4"
  | Opcode.VEXTRACTI32X8 -> "vextracti32x8"
  | Opcode.VEXTRACTI64X2 -> "vextracti64x2"
  | Opcode.VEXTRACTI64X4 -> "vextracti64x4"
  | Opcode.VEXTRACTPS -> "vextractps"
  | Opcode.VFIXUPIMMPD -> "vfixupimmpd"
  | Opcode.VFIXUPIMMPS -> "vfixupimmps"
  | Opcode.VFIXUPIMMSD -> "vfixupimmsd"
  | Opcode.VFIXUPIMMSS -> "vfixupimmss"
  | Opcode.VFMADD132PD -> "vfmadd132pd"
  | Opcode.VFMADD132PS -> "vfmadd132ps"
  | Opcode.VFMADD132SD -> "vfmadd132sd"
  | Opcode.VFMADD132SS -> "vfmadd132ss"
  | Opcode.VFMADD213PD -> "vfmadd213pd"
  | Opcode.VFMADD213PS -> "vfmadd213ps"
  | Opcode.VFMADD213SD -> "vfmadd213sd"
  | Opcode.VFMADD213SS -> "vfmadd213ss"
  | Opcode.VFMADD231PD -> "vfmadd231pd"
  | Opcode.VFMADD231PS -> "vfmadd231ps"
  | Opcode.VFMADD231SD -> "vfmadd231sd"
  | Opcode.VFMADD231SS -> "vfmadd231ss"
  | Opcode.VFMADDSUB132PD -> "vfmaddsub132pd"
  | Opcode.VFMADDSUB132PS -> "vfmaddsub132ps"
  | Opcode.VFMADDSUB213PD -> "vfmaddsub213pd"
  | Opcode.VFMADDSUB213PS -> "vfmaddsub213ps"
  | Opcode.VFMADDSUB231PD -> "vfmaddsub231pd"
  | Opcode.VFMADDSUB231PS -> "vfmaddsub231ps"
  | Opcode.VFMSUB132PD -> "vfmsub132pd"
  | Opcode.VFMSUB132PS -> "vfmsub132ps"
  | Opcode.VFMSUB132SD -> "vfmsub132sd"
  | Opcode.VFMSUB132SS -> "vfmsub132ss"
  | Opcode.VFMSUB213PD -> "vfmsub213pd"
  | Opcode.VFMSUB213PS -> "vfmsub213ps"
  | Opcode.VFMSUB213SD -> "vfmsub213sd"
  | Opcode.VFMSUB213SS -> "vfmsub213ss"
  | Opcode.VFMSUB231PD -> "vfmsub231pd"
  | Opcode.VFMSUB231PS -> "vfmsub231ps"
  | Opcode.VFMSUB231SD -> "vfmsub231sd"
  | Opcode.VFMSUB231SS -> "vfmsub231ss"
  | Opcode.VFMSUBADD132PD -> "vfmsubadd132pd"
  | Opcode.VFMSUBADD132PS -> "vfmsubadd132ps"
  | Opcode.VFMSUBADD213PD -> "vfmsubadd213pd"
  | Opcode.VFMSUBADD213PS -> "vfmsubadd213ps"
  | Opcode.VFMSUBADD231PD -> "vfmsubadd231pd"
  | Opcode.VFMSUBADD231PS -> "vfmsubadd231ps"
  | Opcode.VFNMADD132PD -> "vfnmadd132pd"
  | Opcode.VFNMADD132PS -> "vfnmadd132ps"
  | Opcode.VFNMADD132SD -> "vfnmadd132sd"
  | Opcode.VFNMADD132SS -> "vfnmadd132ss"
  | Opcode.VFNMADD213PD -> "vfnmadd213pd"
  | Opcode.VFNMADD213PS -> "vfnmadd213ps"
  | Opcode.VFNMADD213SD -> "vfnmadd213sd"
  | Opcode.VFNMADD213SS -> "vfnmadd213ss"
  | Opcode.VFNMADD231PD -> "vfnmadd231pd"
  | Opcode.VFNMADD231PS -> "vfnmadd231ps"
  | Opcode.VFNMADD231SD -> "vfnmadd231sd"
  | Opcode.VFNMADD231SS -> "vfnmadd231ss"
  | Opcode.VFNMSUB132PD -> "vfnmsub132pd"
  | Opcode.VFNMSUB132PS -> "vfnmsub132ps"
  | Opcode.VFNMSUB132SD -> "vfnmsub132sd"
  | Opcode.VFNMSUB132SS -> "vfnmsub132ss"
  | Opcode.VFNMSUB213PD -> "vfnmsub213pd"
  | Opcode.VFNMSUB213PS -> "vfnmsub213ps"
  | Opcode.VFNMSUB213SD -> "vfnmsub213sd"
  | Opcode.VFNMSUB213SS -> "vfnmsub213ss"
  | Opcode.VFNMSUB231PD -> "vfnmsub231pd"
  | Opcode.VFNMSUB231PS -> "vfnmsub231ps"
  | Opcode.VFNMSUB231SD -> "vfnmsub231sd"
  | Opcode.VFNMSUB231SS -> "vfnmsub231ss"
  | Opcode.VFPCLASSPD -> "vfpclasspd"
  | Opcode.VFPCLASSPS -> "vfpclassps"
  | Opcode.VFPCLASSSD -> "vfpclasssd"
  | Opcode.VFPCLASSSS -> "vfpclassss"
  | Opcode.VGATHERDPD -> "vgatherdpd"
  | Opcode.VGATHERDPS -> "vgatherdps"
  | Opcode.VGATHERPF0DPD -> "vgatherpf0dpd"
  | Opcode.VGATHERPF0DPS -> "vgatherpf0dps"
  | Opcode.VGATHERPF0QPD -> "vgatherpf0qpd"
  | Opcode.VGATHERPF0QPS -> "vgatherpf0qps"
  | Opcode.VGATHERPF1DPD -> "vgatherpf1dpd"
  | Opcode.VGATHERPF1DPS -> "vgatherpf1dps"
  | Opcode.VGATHERPF1QPD -> "vgatherpf1qpd"
  | Opcode.VGATHERPF1QPS -> "vgatherpf1qps"
  | Opcode.VGATHERQPD -> "vgatherqpd"
  | Opcode.VGATHERQPS -> "vgatherqps"
  | Opcode.VGETEXPPD -> "vgetexppd"
  | Opcode.VGETEXPPS -> "vgetexpps"
  | Opcode.VGETEXPSD -> "vgetexpsd"
  | Opcode.VGETEXPSS -> "vgetexpss"
  | Opcode.VGETMANTPD -> "vgetmantpd"
  | Opcode.VGETMANTPS -> "vgetmantps"
  | Opcode.VGETMANTSD -> "vgetmantsd"
  | Opcode.VGETMANTSS -> "vgetmantss"
  | Opcode.VGF2P8AFFINEINVQB -> "vgf2p8affineinvqb"
  | Opcode.VGF2P8AFFINEQB -> "vgf2p8affineqb"
  | Opcode.VGF2P8MULB -> "vgf2p8mulb"
  | Opcode.VHADDPD -> "vhaddpd"
  | Opcode.VHADDPS -> "vhaddps"
  | Opcode.VHSUBPD -> "vhsubpd"
  | Opcode.VHSUBPS -> "vhsubps"
  | Opcode.VINSERTF128 -> "vinsertf128"
  | Opcode.VINSERTF32X4 -> "vinsertf32x4"
  | Opcode.VINSERTF64X2 -> "vinsertf64x2"
  | Opcode.VINSERTF64X4 -> "vinsertf64x4"
  | Opcode.VINSERTI128 -> "vinserti128"
  | Opcode.VINSERTI32X8 -> "vinserti32x8"
  | Opcode.VINSERTI64X2 -> "vinserti64x2"
  | Opcode.VINSERTI64X4 -> "vinserti64x4"
  | Opcode.VINSERTPS -> "vinsertps"
  | Opcode.VLDDQU -> "vlddqu"
  | Opcode.VMASKMOVPD -> "vmaskmovpd"
  | Opcode.VMASKMOVPS -> "vmaskmovps"
  | Opcode.VMAXPD -> "vmaxpd"
  | Opcode.VMAXPS -> "vmaxps"
  | Opcode.VMAXSD -> "vmaxsd"
  | Opcode.VMAXSS -> "vmaxss"
  | Opcode.VMCALL -> "vmcall"
  | Opcode.VMCLEAR -> "vmclear"
  | Opcode.VMFUNC -> "vmfunc"
  | Opcode.VMINPD -> "vminpd"
  | Opcode.VMINPS -> "vminps"
  | Opcode.VMINSD -> "vminsd"
  | Opcode.VMINSS -> "vminss"
  | Opcode.VMLAUNCH -> "vmlaunch"
  | Opcode.VMOVAPD -> "vmovapd"
  | Opcode.VMOVAPS -> "vmovaps"
  | Opcode.VMOVD -> "vmovd"
  | Opcode.VMOVDDUP -> "vmovddup"
  | Opcode.VMOVDQA -> "vmovdqa"
  | Opcode.VMOVDQA32 -> "vmovdqa32"
  | Opcode.VMOVDQA64 -> "vmovdqa64"
  | Opcode.VMOVDQU -> "vmovdqu"
  | Opcode.VMOVDQU16 -> "vmovdqu16"
  | Opcode.VMOVDQU32 -> "vmovdqu32"
  | Opcode.VMOVDQU64 -> "vmovdqu64"
  | Opcode.VMOVDQU8 -> "vmovdqu8"
  | Opcode.VMOVHLPS -> "vmovhlps"
  | Opcode.VMOVHPD -> "vmovhpd"
  | Opcode.VMOVHPS -> "vmovhps"
  | Opcode.VMOVLHPS -> "vmovlhps"
  | Opcode.VMOVLPD -> "vmovlpd"
  | Opcode.VMOVLPS -> "vmovlps"
  | Opcode.VMOVMSKPD -> "vmovmskpd"
  | Opcode.VMOVMSKPS -> "vmovmskps"
  | Opcode.VMOVNTDQ -> "vmovntdq"
  | Opcode.VMOVNTPD -> "vmovntpd"
  | Opcode.VMOVNTPS -> "vmovntps"
  | Opcode.VMOVQ -> "vmovq"
  | Opcode.VMOVSD -> "vmovsd"
  | Opcode.VMOVSHDUP -> "vmovshdup"
  | Opcode.VMOVSLDUP -> "vmovsldup"
  | Opcode.VMOVSS -> "vmovss"
  | Opcode.VMOVUPD -> "vmovupd"
  | Opcode.VMOVUPS -> "vmovups"
  | Opcode.VMPTRLD -> "vmptrld"
  | Opcode.VMPTRST -> "vmptrst"
  | Opcode.VMREAD -> "vmread"
  | Opcode.VMRESUME -> "vmresume"
  | Opcode.VMULPD -> "vmulpd"
  | Opcode.VMULPS -> "vmulps"
  | Opcode.VMULSD -> "vmulsd"
  | Opcode.VMULSS -> "vmulss"
  | Opcode.VMWRITE -> "vmwrite"
  | Opcode.VMXOFF -> "vmxoff"
  | Opcode.VMXON -> "vmxon"
  | Opcode.VORPD -> "vorpd"
  | Opcode.VORPS -> "vorps"
  | Opcode.VP2INTERSECTD -> "vp2intersectd"
  | Opcode.VP2INTERSECTQ -> "vp2intersectq"
  | Opcode.VP4DPWSSD -> "vp4dpwssd"
  | Opcode.VP4DPWSSDS -> "vp4dpwssds"
  | Opcode.VPABSB -> "vpabsb"
  | Opcode.VPABSD -> "vpabsd"
  | Opcode.VPABSQ -> "vpabsq"
  | Opcode.VPABSW -> "vpabsw"
  | Opcode.VPACKSSDW -> "vpackssdw"
  | Opcode.VPACKSSWB -> "vpacksswb"
  | Opcode.VPACKUSDW -> "vpackusdw"
  | Opcode.VPACKUSWB -> "vpackuswb"
  | Opcode.VPADDB -> "vpaddb"
  | Opcode.VPADDD -> "vpaddd"
  | Opcode.VPADDQ -> "vpaddq"
  | Opcode.VPADDSB -> "vpaddsb"
  | Opcode.VPADDSW -> "vpaddsw"
  | Opcode.VPADDUSB -> "vpaddusb"
  | Opcode.VPADDUSW -> "vpaddusw"
  | Opcode.VPADDW -> "vpaddw"
  | Opcode.VPALIGNR -> "vpalignr"
  | Opcode.VPAND -> "vpand"
  | Opcode.VPANDN -> "vpandn"
  | Opcode.VPAVGB -> "vpavgb"
  | Opcode.VPAVGW -> "vpavgw"
  | Opcode.VPBLENDD -> "vpblendd"
  | Opcode.VPBLENDMB -> "vpblendmb"
  | Opcode.VPBLENDMD -> "vpblendmd"
  | Opcode.VPBLENDMQ -> "vpblendmq"
  | Opcode.VPBLENDMW -> "vpblendmw"
  | Opcode.VPBLENDVB -> "vpblendvb"
  | Opcode.VPBLENDW -> "vpblendw"
  | Opcode.VPBROADCASTB -> "vpbroadcastb"
  | Opcode.VPBROADCASTD -> "vpbroadcastd"
  | Opcode.VPBROADCASTM -> "vpbroadcastm"
  | Opcode.VPBROADCASTMB2Q -> "vpbroadcastmb2q"
  | Opcode.VPBROADCASTMW2D -> "vpbroadcastmw2d"
  | Opcode.VPBROADCASTQ -> "vpbroadcastq"
  | Opcode.VPBROADCASTW -> "vpbroadcastw"
  | Opcode.VPCLMULQDQ -> "vpclmulqdq"
  | Opcode.VPCMPB -> "vpcmpb"
  | Opcode.VPCMPD -> "vpcmpd"
  | Opcode.VPCMPEQB -> "vpcmpeqb"
  | Opcode.VPCMPEQD -> "vpcmpeqd"
  | Opcode.VPCMPEQQ -> "vpcmpeqq"
  | Opcode.VPCMPEQW -> "vpcmpeqw"
  | Opcode.VPCMPESTRI -> "vpcmpestri"
  | Opcode.VPCMPESTRM -> "vpcmpestrm"
  | Opcode.VPCMPGTB -> "vpcmpgtb"
  | Opcode.VPCMPGTD -> "vpcmpgtd"
  | Opcode.VPCMPGTQ -> "vpcmpgtq"
  | Opcode.VPCMPGTW -> "vpcmpgtw"
  | Opcode.VPCMPISTRI -> "vpcmpistri"
  | Opcode.VPCMPISTRM -> "vpcmpistrm"
  | Opcode.VPCMPQ -> "vpcmpq"
  | Opcode.VPCMPUB -> "vpcmpub"
  | Opcode.VPCMPUD -> "vpcmpud"
  | Opcode.VPCMPUQ -> "vpcmpuq"
  | Opcode.VPCMPUW -> "vpcmpuw"
  | Opcode.VPCMPW -> "vpcmpw"
  | Opcode.VPCMUB -> "vpcmub"
  | Opcode.VPCMUD -> "vpcmud"
  | Opcode.VPCMUQ -> "vpcmuq"
  | Opcode.VPCMUW -> "vpcmuw"
  | Opcode.VPCOMPRESSB -> "vpcompressb"
  | Opcode.VPCOMPRESSD -> "vpcompressd"
  | Opcode.VPCOMPRESSQ -> "vpcompressq"
  | Opcode.VPCOMPRESSW -> "vpcompressw"
  | Opcode.VPCONFLICTD -> "vpconflictd"
  | Opcode.VPCONFLICTQ -> "vpconflictq"
  | Opcode.VPDPBUSD -> "vpdpbusd"
  | Opcode.VPDPBUSDS -> "vpdpbusds"
  | Opcode.VPDPWSSD -> "vpdpwssd"
  | Opcode.VPDPWSSDS -> "vpdpwssds"
  | Opcode.VPERM2F128 -> "vperm2f128"
  | Opcode.VPERM2I128 -> "vperm2i128"
  | Opcode.VPERMB -> "vpermb"
  | Opcode.VPERMD -> "vpermd"
  | Opcode.VPERMI2B -> "vpermi2b"
  | Opcode.VPERMI2D -> "vpermi2d"
  | Opcode.VPERMI2PD -> "vpermi2pd"
  | Opcode.VPERMI2PS -> "vpermi2ps"
  | Opcode.VPERMI2Q -> "vpermi2q"
  | Opcode.VPERMI2W -> "vpermi2w"
  | Opcode.VPERMILPD -> "vpermilpd"
  | Opcode.VPERMILPS -> "vpermilps"
  | Opcode.VPERMPD -> "vpermpd"
  | Opcode.VPERMPS -> "vpermps"
  | Opcode.VPERMQ -> "vpermq"
  | Opcode.VPERMT2B -> "vpermt2b"
  | Opcode.VPERMT2D -> "vpermt2d"
  | Opcode.VPERMT2PD -> "vpermt2pd"
  | Opcode.VPERMT2PS -> "vpermt2ps"
  | Opcode.VPERMT2Q -> "vpermt2q"
  | Opcode.VPERMT2W -> "vpermt2w"
  | Opcode.VPERMW -> "vpermw"
  | Opcode.VPEXPANDB -> "vpexpandb"
  | Opcode.VPEXPANDD -> "vpexpandd"
  | Opcode.VPEXPANDQ -> "vpexpandq"
  | Opcode.VPEXPANDW -> "vpexpandw"
  | Opcode.VPEXTRB -> "vpextrb"
  | Opcode.VPEXTRD -> "vpextrd"
  | Opcode.VPEXTRW -> "vpextrw"
  | Opcode.VPGATHERDD -> "vpgatherdd"
  | Opcode.VPGATHERDQ -> "vpgatherdq"
  | Opcode.VPGATHERQD -> "vpgatherqd"
  | Opcode.VPGATHERQQ -> "vpgatherqq"
  | Opcode.VPHADDD -> "vphaddd"
  | Opcode.VPHADDSW -> "vphaddsw"
  | Opcode.VPHADDW -> "vphaddw"
  | Opcode.VPHMINPOSUW -> "vphminposuw"
  | Opcode.VPHSUBD -> "vphsubd"
  | Opcode.VPHSUBSW -> "vphsubsw"
  | Opcode.VPHSUBW -> "vphsubw"
  | Opcode.VPINSRB -> "vpinsrb"
  | Opcode.VPINSRD -> "vpinsrd"
  | Opcode.VPINSRQ -> "vpinsrq"
  | Opcode.VPINSRW -> "vpinsrw"
  | Opcode.VPLZCNTD -> "vplzcntd"
  | Opcode.VPLZCNTQ -> "vplzcntq"
  | Opcode.VPMADD52HUQ -> "vpmadd52huq"
  | Opcode.VPMADD52LUQ -> "vpmadd52luq"
  | Opcode.VPMADDWD -> "vpmaddwd"
  | Opcode.VPMASKMOVD -> "vpmaskmovd"
  | Opcode.VPMASKMOVQ -> "vpmaskmovq"
  | Opcode.VPMAXSB -> "vpmaxsb"
  | Opcode.VPMAXSD -> "vpmaxsd"
  | Opcode.VPMAXSQ -> "vpmaxsq"
  | Opcode.VPMAXSW -> "vpmaxsw"
  | Opcode.VPMAXUB -> "vpmaxub"
  | Opcode.VPMAXUD -> "vpmaxud"
  | Opcode.VPMAXUQ -> "vpmaxuq"
  | Opcode.VPMAXUW -> "vpmaxuw"
  | Opcode.VPMINSB -> "vpminsb"
  | Opcode.VPMINSD -> "vpminsd"
  | Opcode.VPMINSQ -> "vpminsq"
  | Opcode.VPMINSW -> "vpminsw"
  | Opcode.VPMINUB -> "vpminub"
  | Opcode.VPMINUD -> "vpminud"
  | Opcode.VPMINUQ -> "vpminuq"
  | Opcode.VPMINUW -> "vpminuw"
  | Opcode.VPMOVB2D -> "vpmovb2d"
  | Opcode.VPMOVB2M -> "vpmovb2m"
  | Opcode.VPMOVD2M -> "vpmovd2m"
  | Opcode.VPMOVDB -> "vpmovdb"
  | Opcode.VPMOVDW -> "vpmovdw"
  | Opcode.VPMOVM2B -> "vpmovm2b"
  | Opcode.VPMOVM2D -> "vpmovm2d"
  | Opcode.VPMOVM2Q -> "vpmovm2q"
  | Opcode.VPMOVM2W -> "vpmovm2w"
  | Opcode.VPMOVMSKB -> "vpmovmskb"
  | Opcode.VPMOVQ2M -> "vpmovq2m"
  | Opcode.VPMOVQB -> "vpmovqb"
  | Opcode.VPMOVQD -> "vpmovqd"
  | Opcode.VPMOVQW -> "vpmovqw"
  | Opcode.VPMOVSDB -> "vpmovsdb"
  | Opcode.VPMOVSDW -> "vpmovsdw"
  | Opcode.VPMOVSQB -> "vpmovsqb"
  | Opcode.VPMOVSQD -> "vpmovsqd"
  | Opcode.VPMOVSQW -> "vpmovsqw"
  | Opcode.VPMOVSWB -> "vpmovswb"
  | Opcode.VPMOVSXBD -> "vpmovsxbd"
  | Opcode.VPMOVSXBQ -> "vpmovsxbq"
  | Opcode.VPMOVSXBW -> "vpmovsxbw"
  | Opcode.VPMOVSXDQ -> "vpmovsxdq"
  | Opcode.VPMOVSXWD -> "vpmovsxwd"
  | Opcode.VPMOVSXWQ -> "vpmovsxwq"
  | Opcode.VPMOVUSDB -> "vpmovusdb"
  | Opcode.VPMOVUSDW -> "vpmovusdw"
  | Opcode.VPMOVUSQB -> "vpmovusqb"
  | Opcode.VPMOVUSQD -> "vpmovusqd"
  | Opcode.VPMOVUSQW -> "vpmovusqw"
  | Opcode.VPMOVUSWB -> "vpmovuswb"
  | Opcode.VPMOVW2M -> "vpmovw2m"
  | Opcode.VPMOVWB -> "vpmovwb"
  | Opcode.VPMOVZXBD -> "vpmovzxbd"
  | Opcode.VPMOVZXBQ -> "vpmovzxbq"
  | Opcode.VPMOVZXBW -> "vpmovzxbw"
  | Opcode.VPMOVZXDQ -> "vpmovzxdq"
  | Opcode.VPMOVZXWD -> "vpmovzxwd"
  | Opcode.VPMOVZXWQ -> "vpmovzxwq"
  | Opcode.VPMULDQ -> "vpmuldq"
  | Opcode.VPMULHRSW -> "vpmulhrsw"
  | Opcode.VPMULHUW -> "vpmulhuw"
  | Opcode.VPMULHW -> "vpmulhw"
  | Opcode.VPMULLD -> "vpmulld"
  | Opcode.VPMULLQ -> "vpmullq"
  | Opcode.VPMULLW -> "vpmullw"
  | Opcode.VPMULTISHIFTQB -> "vpmultishiftqb"
  | Opcode.VPMULUDQ -> "vpmuludq"
  | Opcode.VPOPCNTB -> "vpopcntb"
  | Opcode.VPOPCNTD -> "vpopcntd"
  | Opcode.VPOPCNTQ -> "vpopcntq"
  | Opcode.VPOPCNTW -> "vpopcntw"
  | Opcode.VPOR -> "vpor"
  | Opcode.VPROLD -> "vprold"
  | Opcode.VPROLQ -> "vprolq"
  | Opcode.VPROLVD -> "vprolvd"
  | Opcode.VPROLVQ -> "vprolvq"
  | Opcode.VPRORD -> "vprord"
  | Opcode.VPRORQ -> "vprorq"
  | Opcode.VPRORRD -> "vprorrd"
  | Opcode.VPRORRQ -> "vprorrq"
  | Opcode.VPRORVD -> "vprorvd"
  | Opcode.VPRORVQ -> "vprorvq"
  | Opcode.VPSADBW -> "vpsadbw"
  | Opcode.VPSCATTERDD -> "vpscatterdd"
  | Opcode.VPSCATTERDQ -> "vpscatterdq"
  | Opcode.VPSCATTERQD -> "vpscatterqd"
  | Opcode.VPSCATTERQQ -> "vpscatterqq"
  | Opcode.VPSHLDD -> "vpshldd"
  | Opcode.VPSHLDQ -> "vpshldq"
  | Opcode.VPSHLDVD -> "vpshldvd"
  | Opcode.VPSHLDVQ -> "vpshldvq"
  | Opcode.VPSHLDVW -> "vpshldvw"
  | Opcode.VPSHLDW -> "vpshldw"
  | Opcode.VPSHRDD -> "vpshrdd"
  | Opcode.VPSHRDQ -> "vpshrdq"
  | Opcode.VPSHRDVD -> "vpshrdvd"
  | Opcode.VPSHRDVQ -> "vpshrdvq"
  | Opcode.VPSHRDVW -> "vpshrdvw"
  | Opcode.VPSHRDW -> "vpshrdw"
  | Opcode.VPSHUFB -> "vpshufb"
  | Opcode.VPSHUFBITQMB -> "vpshufbitqmb"
  | Opcode.VPSHUFD -> "vpshufd"
  | Opcode.VPSHUFHW -> "vpshufhw"
  | Opcode.VPSHUFLW -> "vpshuflw"
  | Opcode.VPSIGNB -> "vpsignb"
  | Opcode.VPSIGND -> "vpsignd"
  | Opcode.VPSIGNW -> "vpsignw"
  | Opcode.VPSLLD -> "vpslld"
  | Opcode.VPSLLDQ -> "vpslldq"
  | Opcode.VPSLLQ -> "vpsllq"
  | Opcode.VPSLLVD -> "vpsllvd"
  | Opcode.VPSLLVQ -> "vpsllvq"
  | Opcode.VPSLLVW -> "vpsllvw"
  | Opcode.VPSLLW -> "vpsllw"
  | Opcode.VPSRAD -> "vpsrad"
  | Opcode.VPSRAQ -> "vpsraq"
  | Opcode.VPSRAVD -> "vpsravd"
  | Opcode.VPSRAVQ -> "vpsravq"
  | Opcode.VPSRAVW -> "vpsravw"
  | Opcode.VPSRAW -> "vpsraw"
  | Opcode.VPSRLD -> "vpsrld"
  | Opcode.VPSRLDQ -> "vpsrldq"
  | Opcode.VPSRLQ -> "vpsrlq"
  | Opcode.VPSRLVD -> "vpsrlvd"
  | Opcode.VPSRLVQ -> "vpsrlvq"
  | Opcode.VPSRLVW -> "vpsrlvw"
  | Opcode.VPSRLW -> "vpsrlw"
  | Opcode.VPSUBB -> "vpsubb"
  | Opcode.VPSUBD -> "vpsubd"
  | Opcode.VPSUBQ -> "vpsubq"
  | Opcode.VPSUBSB -> "vpsubsb"
  | Opcode.VPSUBSW -> "vpsubsw"
  | Opcode.VPSUBUSB -> "vpsubusb"
  | Opcode.VPSUBUSW -> "vpsubusw"
  | Opcode.VPSUBW -> "vpsubw"
  | Opcode.VPTERLOGD -> "vpterlogd"
  | Opcode.VPTERLOGQ -> "vpterlogq"
  | Opcode.VPTERNLOGD -> "vpternlogd"
  | Opcode.VPTERNLOGQ -> "vpternlogq"
  | Opcode.VPTEST -> "vptest"
  | Opcode.VPTESTMB -> "vptestmb"
  | Opcode.VPTESTMD -> "vptestmd"
  | Opcode.VPTESTMQ -> "vptestmq"
  | Opcode.VPTESTMW -> "vptestmw"
  | Opcode.VPTESTNMB -> "vptestnmb"
  | Opcode.VPTESTNMD -> "vptestnmd"
  | Opcode.VPTESTNMQ -> "vptestnmq"
  | Opcode.VPTESTNMW -> "vptestnmw"
  | Opcode.VPUNPCKHBW -> "vpunpckhbw"
  | Opcode.VPUNPCKHDQ -> "vpunpckhdq"
  | Opcode.VPUNPCKHQDQ -> "vpunpckhqdq"
  | Opcode.VPUNPCKHWD -> "vpunpckhwd"
  | Opcode.VPUNPCKLBW -> "vpunpcklbw"
  | Opcode.VPUNPCKLDQ -> "vpunpckldq"
  | Opcode.VPUNPCKLQDQ -> "vpunpcklqdq"
  | Opcode.VPUNPCKLWD -> "vpunpcklwd"
  | Opcode.VPXOR -> "vpxor"
  | Opcode.VPXORD -> "vpxord"
  | Opcode.VPXORQ -> "vpxorq"
  | Opcode.VRANGEPD -> "vrangepd"
  | Opcode.VRANGEPS -> "vrangeps"
  | Opcode.VRANGESD -> "vrangesd"
  | Opcode.VRANGESS -> "vrangess"
  | Opcode.VRCP14PD -> "vrcp14pd"
  | Opcode.VRCP14PS -> "vrcp14ps"
  | Opcode.VRCP14SD -> "vrcp14sd"
  | Opcode.VRCP14SS -> "vrcp14ss"
  | Opcode.VRCP28PD -> "vrcp28pd"
  | Opcode.VRCP28PS -> "vrcp28ps"
  | Opcode.VRCP28SD -> "vrcp28sd"
  | Opcode.VRCP28SS -> "vrcp28ss"
  | Opcode.VRCPPS -> "vrcpps"
  | Opcode.VRCPSS -> "vrcpss"
  | Opcode.VREDUCEPD -> "vreducepd"
  | Opcode.VREDUCEPS -> "vreduceps"
  | Opcode.VREDUCESD -> "vreducesd"
  | Opcode.VREDUCESS -> "vreducess"
  | Opcode.VRNDSCALEPD -> "vrndscalepd"
  | Opcode.VRNDSCALEPS -> "vrndscaleps"
  | Opcode.VRNDSCALESD -> "vrndscalesd"
  | Opcode.VRNDSCALESS -> "vrndscaless"
  | Opcode.VROUNDPD -> "vroundpd"
  | Opcode.VROUNDPS -> "vroundps"
  | Opcode.VROUNDSD -> "vroundsd"
  | Opcode.VROUNDSS -> "vroundss"
  | Opcode.VRSQRT14PD -> "vrsqrt14pd"
  | Opcode.VRSQRT14PS -> "vrsqrt14ps"
  | Opcode.VRSQRT14SD -> "vrsqrt14sd"
  | Opcode.VRSQRT14SS -> "vrsqrt14ss"
  | Opcode.VRSQRT28PD -> "vrsqrt28pd"
  | Opcode.VRSQRT28PS -> "vrsqrt28ps"
  | Opcode.VRSQRT28SD -> "vrsqrt28sd"
  | Opcode.VRSQRT28SS -> "vrsqrt28ss"
  | Opcode.VRSQRTPS -> "vrsqrtps"
  | Opcode.VRSQRTSS -> "vrsqrtss"
  | Opcode.VSCALEFPD -> "vscalefpd"
  | Opcode.VSCALEFPS -> "vscalefps"
  | Opcode.VSCALEFSD -> "vscalefsd"
  | Opcode.VSCALEFSS -> "vscalefss"
  | Opcode.VSCALEPD -> "vscalepd"
  | Opcode.VSCALEPS -> "vscaleps"
  | Opcode.VSCALESD -> "vscalesd"
  | Opcode.VSCALESS -> "vscaless"
  | Opcode.VSCATTERDD -> "vscatterdd"
  | Opcode.VSCATTERDPD -> "vscatterdpd"
  | Opcode.VSCATTERDPS -> "vscatterdps"
  | Opcode.VSCATTERDQ -> "vscatterdq"
  | Opcode.VSCATTERPF0DPD -> "vscatterpf0dpd"
  | Opcode.VSCATTERPF0DPS -> "vscatterpf0dps"
  | Opcode.VSCATTERPF0QPD -> "vscatterpf0qpd"
  | Opcode.VSCATTERPF0QPS -> "vscatterpf0qps"
  | Opcode.VSCATTERPF1DPD -> "vscatterpf1dpd"
  | Opcode.VSCATTERPF1DPS -> "vscatterpf1dps"
  | Opcode.VSCATTERPF1QPD -> "vscatterpf1qpd"
  | Opcode.VSCATTERPF1QPS -> "vscatterpf1qps"
  | Opcode.VSCATTERQD -> "vscatterqd"
  | Opcode.VSCATTERQPD -> "vscatterqpd"
  | Opcode.VSCATTERQPS -> "vscatterqps"
  | Opcode.VSCATTERQQ -> "vscatterqq"
  | Opcode.VSHUFF32X4 -> "vshuff32x4"
  | Opcode.VSHUFF64X2 -> "vshuff64x2"
  | Opcode.VSHUFI32X4 -> "vshufi32x4"
  | Opcode.VSHUFI64X2 -> "vshufi64x2"
  | Opcode.VSHUFPD -> "vshufpd"
  | Opcode.VSHUFPS -> "vshufps"
  | Opcode.VSQRTPD -> "vsqrtpd"
  | Opcode.VSQRTPS -> "vsqrtps"
  | Opcode.VSQRTSD -> "vsqrtsd"
  | Opcode.VSQRTSS -> "vsqrtss"
  | Opcode.VSUBPD -> "vsubpd"
  | Opcode.VSUBPS -> "vsubps"
  | Opcode.VSUBSD -> "vsubsd"
  | Opcode.VSUBSS -> "vsubss"
  | Opcode.VUCOMISD -> "vucomisd"
  | Opcode.VUCOMISS -> "vucomiss"
  | Opcode.VUNPCKHPD -> "vunpckhpd"
  | Opcode.VUNPCKHPS -> "vunpckhps"
  | Opcode.VUNPCKLPD -> "vunpcklpd"
  | Opcode.VUNPCKLPS -> "vunpcklps"
  | Opcode.VXORPD -> "vxorpd"
  | Opcode.VXORPS -> "vxorps"
  | Opcode.VZEROUPPER -> "vzeroupper"
  | Opcode.WAIT -> "wait"
  | Opcode.WBINVD -> "wbinvd"
  | Opcode.WRFSBASE -> "wrfsbase"
  | Opcode.WRGSBASE -> "wrgsbase"
  | Opcode.WRMSR -> "wrmsr"
  | Opcode.WRPKRU -> "wrpkru"
  | Opcode.WRSSD -> "wrssd"
  | Opcode.WRSSQ -> "wrssq"
  | Opcode.WRUSSD -> "wrussd"
  | Opcode.WRUSSQ -> "wrussq"
  | Opcode.XABORT -> "xabort"
  | Opcode.XACQUIRE -> "xacquire"
  | Opcode.XADD -> "xadd"
  | Opcode.XBEGIN -> "xbegin"
  | Opcode.XCHG -> "xchg"
  | Opcode.XEND -> "xend"
  | Opcode.XGETBV -> "xgetbv"
  | Opcode.XLAT -> "xlat"
  | Opcode.XLATB -> "xlatb"
  | Opcode.XOR -> "xor"
  | Opcode.XORPD -> "xorpd"
  | Opcode.XORPS -> "xorps"
  | Opcode.XRELEASE -> "xrelease"
  | Opcode.XRSTOR -> "xrstor"
  | Opcode.XRSTORS -> "xrstors"
  | Opcode.XRSTORS64 -> "xrstors64"
  | Opcode.XSAVE -> "xsave"
  | Opcode.XSAVEC -> "xsavec"
  | Opcode.XSAVEC64 -> "xsavec64"
  | Opcode.XSAVEOPT -> "xsaveopt"
  | Opcode.XSAVES -> "xsaves"
  | Opcode.XSAVES64 -> "xsaves64"
  | Opcode.XSETBV -> "xsetbv"
  | Opcode.XTEST -> "xtest"
  | _ -> raise InvalidOpcodeException

let inline private iToHexStr (i: int64) (builder: DisasmBuilder<_>) =
  builder.Accumulate AsmWordKind.Value (String.i64ToHex i)

let inline private uToHexStr (i: uint64) (builder: DisasmBuilder<_>) =
  builder.Accumulate AsmWordKind.Value (String.u64ToHex i)

let private ptrDirectiveString isFar = function
  | 8<rt> -> "byte ptr"
  | 16<rt> -> "word ptr"
  | 32<rt> -> if isFar then "word far ptr" else "dword ptr"
  | 48<rt> -> "dword far ptr"
  | 64<rt> -> "qword ptr"
  | 80<rt> -> if isFar then "qword far ptr" else "tword ptr"
  | 128<rt> -> "xmmword ptr"
  | 256<rt> -> "ymmword ptr"
  | 512<rt> -> "zmmword ptr"
  | 224<rt> | 864<rt> -> "" (* x87 FPU state *)
  | _ -> Utils.impossible ()

let dispToString showSign (disp: Disp) (builder: DisasmBuilder<_>) =
  let mask = WordSize.toRegType builder.WordSize |> RegType.getMask |> uint64
  if showSign && disp < 0L then
    builder.Accumulate AsmWordKind.String "-"
    iToHexStr (- disp) builder
  elif showSign then
    builder.Accumulate AsmWordKind.String "+"
    iToHexStr disp builder
  else
    uToHexStr (uint64 disp &&& mask) builder

let inline private memDispToStr showSign disp builder =
  match disp with
  | None -> ()
  | Some d -> dispToString showSign d builder

let inline scaleToString (scale: Scale) (builder: DisasmBuilder<_>) =
  if scale = Scale.X1 then ()
  else
    builder.Accumulate AsmWordKind.String "*"
    builder.Accumulate AsmWordKind.Value ((int scale).ToString())

let private memScaleDispToStr emptyBase si d builder =
  match si with
  | None -> memDispToStr (not emptyBase) d builder
  | Some (i, scale) ->
    if emptyBase then () else builder.Accumulate AsmWordKind.String "+"
    builder.Accumulate AsmWordKind.Variable (Register.toString i)
    scaleToString scale builder
    memDispToStr true d builder

let private memAddrToStr b si disp builder =
  match b with
  | None -> memScaleDispToStr true si disp builder
  | Some b ->
    builder.Accumulate AsmWordKind.Variable (Register.toString b)
    memScaleDispToStr false si disp builder

let inline isFar (ins: InsInfo) =
  match ins.Opcode with
  | Opcode.JMPFar | Opcode.CALLFar -> true
  | _ -> false

let mToString (ins: InsInfo) (builder: DisasmBuilder<_>) b si d oprSz =
  let ptrDirective = ptrDirectiveString (isFar ins) oprSz
  match Helper.getSegment ins.Prefixes with
  | None ->
    builder.Accumulate AsmWordKind.String ptrDirective
    builder.Accumulate AsmWordKind.String (" [")
    memAddrToStr b si d builder
    builder.Accumulate AsmWordKind.String "]"
  | Some seg ->
    builder.Accumulate AsmWordKind.String ptrDirective
    builder.Accumulate AsmWordKind.String (" [")
    builder.Accumulate AsmWordKind.Variable (Register.toString seg)
    builder.Accumulate AsmWordKind.String ":"
    memAddrToStr b si d builder
    builder.Accumulate AsmWordKind.String "]"

let commentWithSymbol (helper: DisasmHelper) targetAddr builder =
  if (builder: DisasmBuilder<_>).ResolveSymbol then
    match helper.FindFunctionSymbol (targetAddr) with
    | Error _ ->
      (builder: DisasmBuilder<_>).Accumulate AsmWordKind.String " ; "
      uToHexStr targetAddr builder
    | Ok "" -> ()
    | Ok name ->
      builder.Accumulate AsmWordKind.String " ; <"
      builder.Accumulate AsmWordKind.Value name
      builder.Accumulate AsmWordKind.String ">"
  else ()

let inline relToString offset hlp (builder: DisasmBuilder<_>) =
  if offset < 0L then builder.Accumulate AsmWordKind.String "-"
  else builder.Accumulate AsmWordKind.String "+"
  iToHexStr (abs offset) builder
  commentWithSymbol hlp (builder.Address + uint64 offset) builder

let inline absToString selector (offset: Addr) builder =
  uToHexStr (uint64 selector) builder
  builder.Accumulate AsmWordKind.String ":"
  uToHexStr offset builder

let getOpmaskRegister = function
  | 0x0uy -> Register.K0
  | 0x1uy -> Register.K1
  | 0x2uy -> Register.K2
  | 0x3uy -> Register.K3
  | 0x4uy -> Register.K4
  | 0x5uy -> Register.K5
  | 0x6uy -> Register.K6
  | 0x7uy -> Register.K7
  | _ -> raise InvalidRegisterException

/// Zeroing/Merging (EVEX.z)
let maskZtoString ev (builder: DisasmBuilder<_>) =
  if ev.Z = Zeroing then ()
  else builder.Accumulate AsmWordKind.String "{z}"

/// Opmask register
let maskRegToString ePrx (builder: DisasmBuilder<_>) =
  if ePrx.AAA = 0uy then ()
  else
    builder.Accumulate AsmWordKind.String " {"
    builder.Accumulate AsmWordKind.Variable
      (getOpmaskRegister ePrx.AAA |> Register.toString)
    builder.Accumulate AsmWordKind.String "}"

let buildMask (ins: InsInfo) builder =
  match ins.VEXInfo with
  | Some { EVEXPrx = Some ePrx }->
    maskRegToString ePrx builder
    maskZtoString ePrx builder
  | _ -> ()

let inline private getMask sz =
  match sz with
  | 8<rt> -> 0xFFL
  | 16<rt> -> 0xFFFFL
  | 32<rt> -> 0xFFFFFFFFL
  | _ -> 0xFFFFFFFFFFFFFFFFL

let oprToString ins hlp opr isFst (builder: DisasmBuilder<_>) =
  match opr with
  | OprReg reg ->
    builder.Accumulate AsmWordKind.Variable (Register.toString reg)
    if isFst then buildMask ins builder else ()
  | OprMem (b, si, disp, oprSz) ->
    mToString ins builder b si disp oprSz
    if isFst then buildMask ins builder else ()
  | OprImm (imm, _) -> iToHexStr (imm &&& getMask ins.MainOperationSize) builder
  | OprDirAddr (Absolute (sel, offset, _)) -> absToString sel offset builder
  | OprDirAddr (Relative (offset)) -> relToString offset hlp builder
  | Label _ -> Utils.impossible ()

let inline buildPref (prefs: Prefix) (builder: DisasmBuilder<_>) =
  if prefs = Prefix.PrxNone then ()
  elif (prefs &&& Prefix.PrxLOCK) <> Prefix.PrxNone then
    builder.Accumulate AsmWordKind.String "lock "
  elif (prefs &&& Prefix.PrxREPNZ) <> Prefix.PrxNone then
    builder.Accumulate AsmWordKind.String "repnz "
  elif (prefs &&& Prefix.PrxREPZ) <> Prefix.PrxNone then
    builder.Accumulate AsmWordKind.String "repz "
  elif (prefs &&& Prefix.PrxBND) <> Prefix.PrxNone then
    builder.Accumulate AsmWordKind.String "bnd "
  else ()

let inline buildOpcode opcode (builder: DisasmBuilder<_>) =
  builder.Accumulate AsmWordKind.Mnemonic (opCodeToString opcode)

let recomputeRIPRel disp oprSize builder =
  let dir = ptrDirectiveString false oprSize
  (builder: DisasmBuilder<_>).Accumulate AsmWordKind.String dir
  builder.Accumulate AsmWordKind.String " ["
  uToHexStr (builder.Address + uint64 disp + uint64 builder.InsLength) builder
  builder.Accumulate AsmWordKind.String "]"

let buildOprs (ins: InsInfo) hlp (builder: DisasmBuilder<_>) =
  match ins.Operands with
  | NoOperand -> ()
  | OneOperand (OprMem (Some Register.RIP, None, Some off, 64<rt>)) ->
    builder.Accumulate AsmWordKind.String (" ")
    mToString ins builder (Some Register.RIP) None (Some off) 64<rt>
    commentWithSymbol hlp
      (builder.Address + uint64 builder.InsLength + uint64 off) builder
  | OneOperand opr ->
    builder.Accumulate AsmWordKind.String " "
    oprToString ins hlp opr true builder
  | TwoOperands (OprMem (Some R.RIP, None, Some disp, sz), opr) ->
    builder.Accumulate AsmWordKind.String " "
    recomputeRIPRel disp sz builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr false builder
  | TwoOperands (opr, OprMem (Some R.RIP, None, Some disp, sz)) ->
    builder.Accumulate AsmWordKind.String " "
    oprToString ins hlp opr true builder
    builder.Accumulate AsmWordKind.String ", "
    recomputeRIPRel disp sz builder
  | TwoOperands (opr1, opr2) ->
    builder.Accumulate AsmWordKind.String " "
    oprToString ins hlp opr1 true builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr2 false builder
  | ThreeOperands (opr1, opr2, opr3) ->
    builder.Accumulate AsmWordKind.String " "
    oprToString ins hlp opr1 true builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr2 false builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr3 false builder
  | FourOperands (opr1, opr2, opr3, opr4) ->
    builder.Accumulate AsmWordKind.String " "
    oprToString ins hlp opr1 true builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr2 false builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr3 false builder
    builder.Accumulate AsmWordKind.String ", "
    oprToString ins hlp opr4 false builder

let disasm hlp ins (builder: DisasmBuilder<_>) =
  if builder.ShowAddr then builder.AccumulateAddr () else ()
  buildPref (ins: InsInfo).Prefixes builder
  buildOpcode ins.Opcode builder
  buildOprs ins hlp builder

// vim: set tw=80 sts=2 sw=2:

IntelGeneralLifter.fs
//这个模块实现了x86/x64通用指令的翻译逻辑。
//主要功能点:
//1. 指令操作数的翻译到中间表达式。 
//2. 指令影响标志位的更新逻辑。
//3. 指令底层实现,如寄存器读写、内存读写等细节。
//4. 调用辅助函数实现复杂指令翻译,如IMUL等。
//5. 指令副作用处理,如LOCK前缀。
//翻译过程:
//1. 根据InsInfo解析操作数。
//2. 调用翻译函数转换成中间表达式。
//3. 实现指令语义,如算术逻辑操作。
//4. 更新标志位状态。
//5. 底层细节如寄存器、内存访问。
//6. 返回翻译后的IRBuilder。
//它给上层提供通用和一致的翻译接口,实现从机器码到中间表示的统一转换。
//与其他模块配合,完成从二进制到汇编的整个翻译流程。是Intel体系结构翻译关键部分。

module internal B2R2.FrontEnd.BinLifter.Intel.GeneralLifter

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.RegGroup
open B2R2.FrontEnd.BinLifter.Intel.Helper
open B2R2.FrontEnd.BinLifter.Intel.LiftingUtils

open type BinOpType

#if !EMULATION
let private undefCF = AST.undef 1<rt> "CF is undefined."

let private undefOF = AST.undef 1<rt> "OF is undefined."

let private undefAF = AST.undef 1<rt> "AF is undefined."

let private undefSF = AST.undef 1<rt> "SF is undefined."

let private undefZF = AST.undef 1<rt> "ZF is undefined."

let private undefPF = AST.undef 1<rt> "PF is undefined."
#endif

let private buildAF ctxt e1 e2 r size =
  let t1 = r <+> e1
  let t2 = t1 <+> e2
  let t3 = (AST.num1 size) << (numU32 4ul size)
  let t4 = t2 .& t3
  !.ctxt R.AF := t4 == t3

let private buildPF ctxt r size cond ir =
  let struct (t1, t2) = tmpVars2 ir size
  let s2 = r <+> (r >> (AST.zext size (numU32 4ul 8<rt>)))
  let s4 = s2 <+> (t1 >> (AST.zext size (numU32 2ul 8<rt>)))
  let s5 = s4 <+> (t2 >> (AST.zext size (AST.num1 8<rt>)))
  let pf = !.ctxt R.PF
  let computedPF = AST.unop UnOpType.NOT (AST.xtlo 1<rt> s5)
  !!ir (t1 := s2)
  !!ir (t2 := s4)
  !!ir (match cond with
         | None -> pf := computedPF
         | Some cond -> pf := AST.ite cond pf computedPF)

let private enumSZPFlags ctxt r size ir =
  !!ir (!.ctxt R.SF := AST.xthi 1<rt> r)
  !!ir (!.ctxt R.ZF := r == (AST.num0 size))
  !?ir (buildPF ctxt r size None)

let private enumASZPFlags ctxt e1 e2 r size ir =
  !!ir (buildAF ctxt e1 e2 r size)
  !?ir (enumSZPFlags ctxt r size)

let private enumEFLAGS ctxt e1 e2 e3 size cf ofl ir =
  !!ir (!.ctxt R.CF := cf)
  !!ir (!.ctxt R.OF := ofl)
  !!ir (buildAF ctxt e1 e2 e3 size)
  !!ir (!.ctxt R.SF := AST.xthi 1<rt> e3)
  !!ir (!.ctxt R.ZF := e3 == (AST.num0 size))
  !?ir (buildPF ctxt e3 size None)

/// CF on add.
let private cfOnAdd e1 r = AST.lt r e1

/// CF on sub.
let private cfOnSub e1 e2 = AST.lt e1 e2

/// OF on add.
let private ofOnAdd e1 e2 r =
  let e1High = AST.xthi 1<rt> e1
  let e2High = AST.xthi 1<rt> e2
  let rHigh = AST.xthi 1<rt> r
  (e1High == e2High) .& (e1High <+> rHigh)

/// OF on sub.
let private ofOnSub e1 e2 r =
  AST.xthi 1<rt> ((e1 <+> e2) .& (e1 <+> r))

let private getInstrPtr ctxt =
  !.ctxt (if is64bit ctxt then R.RIP else R.EIP)

let private getStackPtr ctxt =
  !.ctxt (if is64bit ctxt then R.RSP else R.ESP)

let private getBasePtr ctxt =
  !.ctxt (if is64bit ctxt then R.RBP else R.EBP)

let private getRegOfSize ctxt oprSize regGrp =
  regGrp oprSize |> !.ctxt

let inline private getStackWidth wordSize oprSize =
  numI32 (RegType.toByteWidth oprSize) wordSize

let private auxPush oprSize ctxt expr ir =
  let t = !*ir oprSize
  let sp = getStackPtr ctxt
  !!ir (t := expr)
  !!ir (sp := sp .- (getStackWidth ctxt.WordBitSize oprSize))
  !!ir (AST.loadLE oprSize sp := t)

let private computePopSize oprSize = function
  | Var (_, id, _, _) when isSegReg (Register.ofRegID id) -> 16<rt>
  | _ -> oprSize

let private auxPop oprSize ctxt dst ir =
  let sp = getStackPtr ctxt
  !!ir (dst := AST.loadLE (computePopSize oprSize dst.E) sp)
  !!ir (sp := sp .+ (getStackWidth ctxt.WordBitSize oprSize))

let private maskOffset offset oprSize =
  let offset = AST.zext oprSize offset
  match oprSize with
  | 16<rt> -> offset .& numU32 0xFu 16<rt>
  | 32<rt> -> offset .& numU32 0x1Fu 32<rt>
  | 64<rt> -> offset .& numU32 0x3Fu 64<rt>
  | _ -> raise InvalidOperandSizeException

let rec private isVar = function
  | Var _ | TempVar _ -> true
  | Extract (e, _, _, _) -> isVar e.E
  | _ -> false

let private calculateOffset offset oprSize =
  let offset = AST.zext oprSize offset
  match oprSize with
  | 16<rt> -> numU32 2u 16<rt> .* (offset ./ numU32 16u 16<rt>),
              offset .& numU32 15u 16<rt>
  | 32<rt> -> numU32 4u 32<rt> .* (offset ./ numU32 32u 32<rt>),
              offset .& numU32 31u 32<rt>
  | 64<rt> -> numU32 4u 64<rt> .* (offset ./ numU32 32u 64<rt>),
              offset .& numU32 31u 64<rt>
  | _ -> raise InvalidOperandSizeException

let private strRepeat ins insLen ctxt body cond (ir: IRBuilder) =
  let lblExit = ir.NewSymbol "Exit"
  let lblCont = ir.NewSymbol "Continue"
  let lblNext = ir.NewSymbol "Next"
  let n0 = AST.num0 (ctxt: TranslationContext).WordBitSize
  let cx = !.ctxt (if is64bit ctxt then R.RCX else R.ECX)
  let pc = getInstrPtr ctxt
  let ninstAddr = pc .+ numInsLen insLen ctxt
  !!ir (AST.cjmp (cx == n0) (AST.name lblExit) (AST.name lblCont))
  !!ir (AST.lmark lblCont)
  !?ir (body ins ctxt)
  !!ir (cx := cx .- AST.num1 ctxt.WordBitSize)
  match cond with
  | None -> !!ir (AST.interjmp pc InterJmpKind.Base)
  | Some cond ->
    !!ir (AST.cjmp (cx == n0) (AST.name lblExit) (AST.name lblNext))
    !!ir (AST.lmark lblNext)
    !!ir (AST.intercjmp cond ninstAddr pc)
  !!ir (AST.lmark lblExit)
  (* We consider each individual loop from a REP-prefixed instruction as an
     independent basic block, because it is more intuitive and matches with
     the definition of basic block from text books. *)
  !!ir (AST.interjmp ninstAddr InterJmpKind.Base)

let aaa insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let ir = IRBuilder (16)
  let al = !.ctxt R.AL
  let af = !.ctxt R.AF
  let ax = !.ctxt R.AX
  let cf = !.ctxt R.CF
  let alAnd0f = al .& numI32 0x0f 8<rt>
  let cond1 = AST.gt alAnd0f (numI32 9 8<rt>)
  let cond2 = af == AST.b1
  let cond = !*ir 1<rt>
  !<ir insLen
  !!ir (cond := cond1 .| cond2)
  !!ir (ax := AST.ite cond (ax .+ numI32 0x106 16<rt>) ax)
  !!ir (af := AST.ite cond AST.b1 AST.b0)
  !!ir (cf := AST.ite cond AST.b1 AST.b0)
  !!ir (al := alAnd0f)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.ZF := undefZF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let aad ins insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let imm8 = transOneOpr ins insLen ctxt |> AST.xtlo 8<rt>
  let al = !.ctxt R.AL
  let ah = !.ctxt R.AH
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (al := (al .+ (ah .* imm8)) .& (numI32 0xff 8<rt>))
  !!ir (ah := AST.num0 8<rt>)
  !?ir (enumSZPFlags ctxt al 8<rt>)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.CF := undefCF)
#endif
  !>ir insLen

let aam ins insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let imm8 = transOneOpr ins insLen ctxt |>  AST.xtlo 8<rt>
  let al = !.ctxt R.AL
  let ah = !.ctxt R.AH
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (ah := al ./ imm8)
  !!ir (al := al .% imm8)
  !?ir (enumSZPFlags ctxt al 8<rt>)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.CF := undefCF)
#endif
  !>ir insLen

let aas insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let ax = !.ctxt R.AX
  let al = !.ctxt R.AL
  let af = !.ctxt R.AF
  let cf = !.ctxt R.CF
  let ah = !.ctxt R.AH
  let alAnd0f = al .& numI32 0x0f 8<rt>
  let cond1 = AST.gt alAnd0f (numI32 9 8<rt>)
  let cond2 = af == AST.b1
  let ir = IRBuilder (16)
  let cond = !*ir 1<rt>
  !<ir insLen
  !!ir (cond := cond1 .| cond2)
  !!ir (ax := AST.ite cond (ax .- numI32 6 16<rt>) ax)
  !!ir (ah := AST.ite cond (ah .- AST.num1 8<rt>) ah)
  !!ir (af := AST.ite cond AST.b1 AST.b0)
  !!ir (cf := AST.ite cond AST.b1 AST.b0)
  !!ir (al := alAnd0f)
  !>ir insLen

let adc ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cf = !.ctxt R.CF
  let ir = IRBuilder (16)
  let struct (t1, t2, t3, t4) = tmpVars4 ir oprSize
  !<ir insLen
  !!ir (t1 := dst)
  !!ir (t2 := AST.sext oprSize src)
  !!ir (t3 := t2 .+ AST.zext oprSize cf)
  !!ir (t4 := t1 .+ t3)
  !!ir (dstAssign oprSize dst t4)
  !!ir (cf := AST.lt t3 t2 .| AST.lt t4 t1)
  !!ir (!.ctxt R.OF := ofOnAdd t1 t2 t4)
  !?ir (enumASZPFlags ctxt t1 t2 t4 oprSize)
  !>ir insLen

let add ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t1 := dst)
  !!ir (t2 := src)
  !!ir (t3 := t1 .+ t2)
  !!ir (dstAssign oprSize dst t3)
  !?ir (enumEFLAGS ctxt t1 t2 t3 oprSize (cfOnAdd t1 t3) (ofOnAdd t1 t2 t3))
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let ``and`` ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let t = !*ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t := dst .& AST.sext oprSize src)
  !!ir (dstAssign oprSize dst t)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.CF := AST.b0)
#if !EMULATION
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !?ir (enumSZPFlags ctxt t oprSize)
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let andn ins insLen ctxt =
  let struct (dst, src1, src2) = transThreeOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let t = !*ir oprSize
  !<ir insLen
  !!ir (t := (AST.not src1) .& src2)
  !!ir (dstAssign oprSize dst t)
  !!ir (!.ctxt R.SF := AST.extract dst 1<rt> (int oprSize - 1))
  !!ir (!.ctxt R.ZF := AST.eq dst (AST.num0 oprSize))
  !>ir insLen

let arpl ins insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let ir = IRBuilder (8)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let struct (t1, t2) = tmpVars2 ir 16<rt>
  let mask = numI32 0xfffc 16<rt>
  let zF = !.ctxt R.ZF
  !<ir insLen
  !!ir (t1 := dst .& numI32 0x3 16<rt>)
  !!ir (t2 := src .& numI32 0x3 16<rt>)
  !!ir (dst := AST.ite (AST.lt t1 t2) ((dst .& mask) .| t2) dst)
  !!ir (zF := AST.lt t1 t2)
  !>ir insLen

let private bndmov64 ins insLen ctxt =
  let struct (dst, src) = getTwoOprs ins
  let dst1, dst2 = transOprToExpr128 ins insLen ctxt dst
  let src1, src2 = transOprToExpr128 ins insLen ctxt src
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (dst1 := src1)
  !!ir (dst2 := src2)
  !>ir insLen

let private bndmov32Aux ins insLen ctxt ir =
  let struct (dst, src) = getTwoOprs ins
  match dst, src with
  | OprReg _, OprMem _ ->
    let dst1, dst2 = transOprToExpr128 ins insLen ctxt dst
    let src = transOprToExpr ins insLen ctxt src
    !!ir (dst1 := AST.xthi 32<rt> src |> AST.zext 64<rt>)
    !!ir (dst2 := AST.xtlo 32<rt> src |> AST.zext 64<rt>)
  | OprMem _, OprReg _ ->
    let src1, src2 = transOprToExpr128 ins insLen ctxt src
    let dst = transOprToExpr ins insLen ctxt dst
    !!ir (dst := AST.concat (AST.xtlo 32<rt> src1) (AST.xtlo 32<rt> src2))
  | _ -> raise InvalidOperandException

let bndmov32 ins insLen ctxt =
  let ir = IRBuilder (4)
  !<ir insLen
  bndmov32Aux ins insLen ctxt ir
  !>ir insLen

let bndmov ins insLen ctxt =
  if is64bit ctxt then bndmov64 ins insLen ctxt
  else bndmov32 ins insLen ctxt

let bsf ins insLen ctxt =
  let ir = IRBuilder (26)
  let lblL0 = ir.NewSymbol "L0"
  let lblL1 = ir.NewSymbol "L1"
  let lblEnd = ir.NewSymbol "End"
  let lblLoopCond = ir.NewSymbol "LoopCond"
  let lblLE = ir.NewSymbol "LoopEnd"
  let lblLoop = ir.NewSymbol "Loop"
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cond = src == AST.num0 oprSize
  let zf = !.ctxt R.ZF
  let t = !*ir oprSize
  !<ir insLen
  !!ir (AST.cjmp cond (AST.name lblL0) (AST.name lblL1))
  !!ir (AST.lmark lblL0)
  !!ir (zf := AST.b1)
  !!ir (dst := AST.undef oprSize "DEST is undefined.")
  !!ir (AST.jmp (AST.name lblEnd))
  !!ir (AST.lmark lblL1)
  !!ir (zf := AST.b0)
  !!ir (t := AST.num0 oprSize)
  !!ir (AST.lmark lblLoopCond)
  !!ir (AST.cjmp ((AST.xtlo 1<rt> (src >> t)) == AST.b0)
                 (AST.name lblLoop) (AST.name lblLE))
  !!ir (AST.lmark lblLoop)
  !!ir (t := t .+ AST.num1 oprSize)
  !!ir (AST.jmp (AST.name lblLoopCond))
  !!ir (AST.lmark lblLE)
  !!ir (dstAssign oprSize dst t)
  !!ir (AST.lmark lblEnd)
#if !EMULATION
  !!ir (!.ctxt R.CF := undefCF)
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let bsr ins insLen ctxt =
  let ir = IRBuilder (26)
  let lblL0 = ir.NewSymbol "L0"
  let lblL1 = ir.NewSymbol "L1"
  let lblEnd = ir.NewSymbol "End"
  let lblLoopCond = ir.NewSymbol "LoopCond"
  let lblLE = ir.NewSymbol "LoopEnd"
  let lblLoop = ir.NewSymbol "Loop"
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cond = src == AST.num0 oprSize
  let zf = !.ctxt R.ZF
  let t = !*ir oprSize
  !<ir insLen
  !!ir (AST.cjmp cond (AST.name lblL0) (AST.name lblL1))
  !!ir (AST.lmark lblL0)
  !!ir (zf := AST.b1)
  !!ir (dst := AST.undef oprSize "DEST is undefined.")
  !!ir (AST.jmp (AST.name lblEnd))
  !!ir (AST.lmark lblL1)
  !!ir (zf := AST.b0)
  !!ir (t := numOprSize oprSize .- AST.num1 oprSize)
  !!ir (AST.lmark lblLoopCond)
  !!ir (AST.cjmp ((AST.xtlo 1<rt> (src >> t)) == AST.b0)
                 (AST.name lblLoop) (AST.name lblLE))
  !!ir (AST.lmark lblLoop)
  !!ir (t := t .- AST.num1 oprSize)
  !!ir (AST.jmp (AST.name lblLoopCond))
  !!ir (AST.lmark lblLE)
  !!ir (dst := t)
  !!ir (AST.lmark lblEnd)
#if !EMULATION
  !!ir (!.ctxt R.CF := undefCF)
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let bswap ins insLen ctxt =
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let cnt = RegType.toByteWidth oprSize |> int
  let ir = IRBuilder (2 * cnt)
  let t = !*ir oprSize
  let tmps = Array.init cnt (fun _ -> !*ir 8<rt>)
  !<ir insLen
  !!ir (t := dst)
  for i in 0 .. cnt - 1 do
    !!ir (tmps[i] := AST.extract t 8<rt> (i * 8))
  done
  !!ir (dstAssign oprSize dst (AST.concatArr (Array.rev tmps)))
  !>ir insLen

let private bit ins bitBase bitOffset oprSize =
  match bitBase.E with
  | Load (e, t, expr, _) ->
    let effAddrSz = getEffAddrSz ins
    let addrOffset, bitOffset = calculateOffset bitOffset oprSize
    let addrOffset = AST.zext effAddrSz addrOffset
    AST.xtlo 1<rt> ((AST.load e t (expr .+ addrOffset)) >> bitOffset)
  | _ -> if isVar bitBase.E
         then AST.xtlo 1<rt> (bitBase >> maskOffset bitOffset oprSize)
         else raise InvalidExprException

let bt ins insLen ctxt =
  let struct (bitBase, bitOffset) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (!.ctxt R.CF := bit ins bitBase bitOffset oprSize)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let private setBit ins bitBase bitOffset oprSize setValue =
  match bitBase.E with
  | Load (e, t, expr, _) ->
    let effAddrSz = getEffAddrSz ins
    let addrOffset, bitOffset = calculateOffset bitOffset oprSize
    let addrOffset = AST.zext effAddrSz addrOffset
    let mask = setValue << bitOffset
    let loadMem = AST.load e t (expr .+ addrOffset)
    loadMem := (loadMem .& (getMask oprSize .- mask)) .| mask
  | _ -> if isVar bitBase.E
         then let mask = setValue << maskOffset bitOffset oprSize
              bitBase := (bitBase .& (getMask oprSize .- mask)) .| mask
         else raise InvalidExprException

let bitTest ins insLen ctxt setValue =
  let struct (bitBase, bitOffset) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let setValue = AST.zext oprSize setValue
  let ir = IRBuilder (8)
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (!.ctxt R.CF := bit ins bitBase bitOffset oprSize)
  !!ir (setBit ins bitBase bitOffset oprSize setValue)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let btc ins insLen ctxt =
  bitTest ins insLen ctxt (!.ctxt R.CF |> AST.not)

let btr ins insLen ctxt =
  bitTest ins insLen ctxt AST.b0

let bts ins insLen ctxt =
  bitTest ins insLen ctxt AST.b1

let call ins insLen ctxt =
  let pc = getInstrPtr ctxt
  let oprSize = getOperationSize ins
  let struct (target, ispcrel) = transJumpTargetOpr ins pc insLen ctxt
  let ir = IRBuilder (8)
  !<ir insLen
  if ispcrel then
    !?ir (auxPush oprSize ctxt (pc .+ numInsLen insLen ctxt))
    !!ir (AST.interjmp target InterJmpKind.IsCall)
  else
    let t = !*ir oprSize (* Use tmpvar because the target can use RSP *)
    !!ir (t := target)
    !?ir (auxPush oprSize ctxt (pc .+ numInsLen insLen ctxt))
    !!ir (AST.interjmp t InterJmpKind.IsCall)
  !>ir insLen

let convBWQ ins insLen ctxt =
  let opr = !.ctxt (if is64bit ctxt then R.RAX else R.EAX)
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (
    match getOperationSize ins with
    | 16<rt> -> AST.xtlo 16<rt> opr := AST.sext 16<rt> (AST.xtlo 8<rt> opr)
    | 32<rt> -> AST.xtlo 32<rt> opr := AST.sext 32<rt> (AST.xtlo 16<rt> opr)
    | 64<rt> -> opr := AST.sext 64<rt> (AST.xtlo 32<rt> opr)
    | _ -> raise InvalidOperandSizeException)
  !>ir insLen

let clearFlag insLen ctxt flagReg =
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (!.ctxt flagReg := AST.b0)
  !>ir insLen

let cmc ins insLen ctxt =
  let cf = !.ctxt R.CF
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (cf := AST.not cf)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.ZF := undefZF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let private getCondOfCMov (ins: IntelInternalInstruction) ctxt =
  match ins.Opcode with
  | Opcode.CMOVO -> !.ctxt R.OF
  | Opcode.CMOVNO -> !.ctxt R.OF == AST.b0
  | Opcode.CMOVB -> !.ctxt R.CF
  | Opcode.CMOVAE -> !.ctxt R.CF == AST.b0
  | Opcode.CMOVZ -> !.ctxt R.ZF
  | Opcode.CMOVNZ -> !.ctxt R.ZF == AST.b0
  | Opcode.CMOVBE -> (!.ctxt R.CF) .| (!.ctxt R.ZF)
  | Opcode.CMOVA -> ((!.ctxt R.CF) .| (!.ctxt R.ZF)) == AST.b0
  | Opcode.CMOVS -> !.ctxt R.SF
  | Opcode.CMOVNS -> !.ctxt R.SF == AST.b0
  | Opcode.CMOVP -> !.ctxt R.PF
  | Opcode.CMOVNP -> !.ctxt R.PF == AST.b0
  | Opcode.CMOVL -> !.ctxt R.SF != !.ctxt R.OF
  | Opcode.CMOVGE -> !.ctxt R.SF == !.ctxt R.OF
  | Opcode.CMOVLE -> !.ctxt R.ZF .|
                     (!.ctxt R.SF != !.ctxt R.OF)
  | Opcode.CMOVG -> !.ctxt R.ZF == AST.b0 .&
                    (!.ctxt R.SF == !.ctxt R.OF)
  | _ -> raise InvalidOpcodeException

let cmovcc ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (dstAssign oprSize dst (AST.ite (getCondOfCMov ins ctxt) src dst))
  !>ir insLen

let cmp ins insLen ctxt =
  let oprSize = getOperationSize ins
  let struct (src1, src2) = transTwoOprs ins insLen ctxt
  let ir = IRBuilder (16)
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  !<ir insLen
  !!ir (t1 := src1)
  !!ir (t2 := AST.sext oprSize src2)
  !!ir (t3 := t1 .- t2)
  !?ir (enumEFLAGS ctxt t1 t2 t3 oprSize (cfOnSub t1 t2) (ofOnSub t1 t2 t3))
  !>ir insLen

let private cmpsBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let si = !.ctxt (if is64bit ctxt then R.RSI else R.ESI)
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let src1 = AST.loadLE oprSize si
  let src2 = AST.loadLE oprSize di
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (t1 := src1)
  !!ir (t2 := src2)
  !!ir (t3 := t1 .- t2)
  !!ir (si := AST.ite df (si .- amount) (si .+ amount))
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))
  !?ir (enumEFLAGS ctxt t1 t2 t3 oprSize (cfOnSub t1 t2) (ofOnSub t1 t2 t3))

let cmps (ins: InsInfo) insLen ctxt =
  let pref = ins.Prefixes
  let zf = !.ctxt R.ZF
  let ir = IRBuilder (32)
  !<ir insLen
  (if hasREPZ pref then
     strRepeat ins insLen ctxt cmpsBody (Some (zf == AST.b0)) ir
   elif hasREPNZ pref then
     strRepeat ins insLen ctxt cmpsBody (Some (zf)) ir
   else cmpsBody ins ctxt ir)
  !>ir insLen

let cmpxchg ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (32)
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  let t = !*ir oprSize
  let r = !*ir oprSize
  let acc = getRegOfSize ctxt oprSize grpEAX
  let cond = !*ir 1<rt>
  let lblEq = ir.NewSymbol "Equal"
  let lblNeq = ir.NewSymbol "NotEqual"
  let lblEnd = ir.NewSymbol "End"
  !!ir (t := dst)
  !!ir (r := acc .- t)
  !!ir (cond := acc == t)
  !!ir (AST.cjmp cond (AST.name lblEq) (AST.name lblNeq))
  !!ir (AST.lmark lblEq)
  !!ir (!.ctxt R.ZF := AST.b1)
  !!ir (dstAssign oprSize dst src)
  !!ir (AST.jmp (AST.name lblEnd))
  !!ir (AST.lmark lblNeq)
  !!ir (!.ctxt R.ZF := AST.b0)
  !!ir (dstAssign oprSize acc t)
  !!ir (AST.lmark lblEnd)
  !!ir (!.ctxt R.OF := ofOnSub acc t r)
  !!ir (!.ctxt R.SF := AST.xthi 1<rt> r)
  !!ir (buildAF ctxt acc t r oprSize)
  !?ir (buildPF ctxt r oprSize None)
  !!ir (!.ctxt R.CF := AST.lt (acc .+ t) acc)
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let compareExchangeBytes ins insLen ctxt =
  let ir = IRBuilder (8)
  let oprSize = getOperationSize ins
  let zf = !.ctxt R.ZF
  let cond = !*ir 1<rt>
  !<ir insLen
  match oprSize with
  | 64<rt> ->
    let dst = transOneOpr ins insLen ctxt
    let edx = getRegOfSize ctxt 32<rt> grpEDX
    let eax = getRegOfSize ctxt 32<rt> grpEAX
    let ecx = getRegOfSize ctxt 32<rt> grpECX
    let ebx = getRegOfSize ctxt 32<rt> grpEBX
    let t = !*ir oprSize
    !!ir (t := dst)
    !!ir (cond := AST.concat edx eax == t)
    !!ir (zf := cond)
    !!ir (eax := AST.ite cond eax (AST.extract t 32<rt> 0))
    !!ir (edx := AST.ite cond edx (AST.extract t 32<rt> 32))
    !!ir (dst := AST.ite cond (AST.concat ecx ebx) t)
  | 128<rt> ->
    let dstB, dstA =
      match ins.Operands with
      | OneOperand opr -> transOprToExpr128 ins insLen ctxt opr
      | _ -> raise InvalidOperandException
    let rdx = getRegOfSize ctxt 64<rt> grpEDX
    let rax = getRegOfSize ctxt 64<rt> grpEAX
    let rcx = getRegOfSize ctxt 64<rt> grpECX
    let rbx = getRegOfSize ctxt 64<rt> grpEBX
    !!ir (cond := (dstB == rdx) .& (dstA == rax))
    !!ir (zf := cond)
    !!ir (rax := AST.ite cond rax dstA)
    !!ir (rdx := AST.ite cond rdx dstB)
    !!ir (dstA := AST.ite cond rbx dstA)
    !!ir (dstB := AST.ite cond rcx dstB)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let convWDQ ins insLen (ctxt: TranslationContext) =
  let ir = IRBuilder (8)
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize, ctxt.WordBitSize with
  | 16<rt>, _ ->
    let t = !*ir 32<rt>
    let ax = !.ctxt R.AX
    let dx = !.ctxt R.DX
    !!ir (t := AST.sext 32<rt> ax)
    !!ir (dx := AST.xthi 16<rt> t)
    !!ir (ax := AST.xtlo 16<rt> t)
  | 32<rt>, _ ->
    let t = !*ir 64<rt>
    let eax = !.ctxt R.EAX
    let edx = !.ctxt R.EDX
    !!ir (t := AST.sext 64<rt> eax)
    !!ir (edx := AST.xthi 32<rt> t)
    !!ir (eax := AST.xtlo 32<rt> t)
  | 64<rt>, 64<rt> ->
    let rdx = !.ctxt R.RDX
    let rax = !.ctxt R.RAX
    let cond = AST.extract rax 1<rt> 63
    !!ir (rdx := AST.ite cond (numI32 -1 64<rt>) (AST.num0 64<rt>))
  | _, _ -> raise InvalidOperandSizeException
  !>ir insLen

let daa insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let ir = IRBuilder (16)
  let al = !.ctxt R.AL
  let cf = !.ctxt R.CF
  let af = !.ctxt R.AF
  let oldAl = !*ir 8<rt>
  let oldCf = !*ir 1<rt>
  let alAnd0f = al .& numI32 0x0f 8<rt>
  let subCond1 = AST.gt alAnd0f (numI32 9 8<rt>)
  let subCond2 = af == AST.b1
  let cond1 = !*ir 1<rt>
  let subCond3 = AST.gt oldAl (numI32 0x99 8<rt>)
  let subCond4 = oldCf == AST.b1
  let cond2 = !*ir 1<rt>
  !<ir insLen
  !!ir (oldAl := al)
  !!ir (oldCf := cf)
  !!ir (cf := AST.b0)
  !!ir (cond1 := subCond1 .| subCond2)
  !!ir (al := AST.ite cond1 (al .+ numI32 6 8<rt>) al)
  !!ir (cf := AST.ite cond1 oldCf cf)
  !!ir (af := cond1)
  !!ir (cond2 := subCond3 .| subCond4)
  !!ir (al := AST.ite cond2 (al .+ numI32 0x60 8<rt>) al)
  !!ir (cf := cond2)
  !?ir (enumSZPFlags ctxt al 8<rt>)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
#endif
  !>ir insLen

let das insLen ctxt =
#if DEBUG
  assert32 ctxt
#endif
  let ir = IRBuilder (16)
  let al = !.ctxt R.AL
  let cf = !.ctxt R.CF
  let af = !.ctxt R.AF
  let oldAl = !*ir 8<rt>
  let oldCf = !*ir 1<rt>
  let alAnd0f = al .& numI32 0x0f 8<rt>
  let subCond1 = AST.gt alAnd0f (numI32 9 8<rt>)
  let subCond2 = af == AST.b1
  let cond1 = !*ir 1<rt>
  let subCond3 = AST.gt oldAl (numI32 0x99 8<rt>)
  let subCond4 = oldCf == AST.b1
  let cond2 = !*ir 1<rt>
  !<ir insLen
  !!ir (oldAl := al)
  !!ir (oldCf := cf)
  !!ir (cf := AST.b0)
  !!ir (cond1 := subCond1 .| subCond2)
  !!ir (al := AST.ite cond1 (al .- numI32 6 8<rt>) al)
  !!ir (cf := AST.ite cond1 oldCf cf)
  !!ir (af := cond1)
  !!ir (cond2 := subCond3 .| subCond4)
  !!ir (al := AST.ite cond2 (al .- numI32 0x60 8<rt>) al)
  !!ir (cf := cond2)
  !?ir (enumSZPFlags ctxt al 8<rt>)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
#endif
  !>ir insLen

let dec ins insLen ctxt =
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t1 := dst)
  !!ir (t2 := AST.num1 oprSize)
  !!ir (t3 := (t1 .- t2))
  !!ir (dstAssign oprSize dst t3)
  !!ir (!.ctxt R.OF := ofOnSub t1 t2 t3)
  !?ir (enumASZPFlags ctxt t1 t2 t3 oprSize)
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let divideWithoutConcat opcode oprSize divisor lblAssign lblErr ctxt ir =
  let rdx, rax = !.ctxt R.RDX, !.ctxt R.RAX
  let struct (trdx, trax, tdivisor) = tmpVars3 ir oprSize
  let updateSign = !*ir 1<rt>
  let lblComputable = (ir: IRBuilder).NewSymbol "Computable"
  let lblEasy = (ir: IRBuilder).NewSymbol "Easy"
  let lblHard = (ir: IRBuilder).NewSymbol "Hard"
  let isEasy = trdx == AST.num0 oprSize
  let errChk = AST.gt tdivisor trdx
  let quotient = !*ir oprSize
  let remainder = !*ir oprSize
  let bignum = numI64 0x8000000000000000L oprSize
  match opcode with
  | Opcode.DIV ->
    !!ir (trdx := rdx)
    !!ir (trax := rax)
    !!ir (tdivisor := divisor)
  | Opcode.IDIV ->
    let struct (dividendIsNeg, divisorIsNeg) = tmpVars2 ir 1<rt>
    !!ir (dividendIsNeg := (AST.xthi 1<rt> rdx == AST.b1))
    !!ir (divisorIsNeg := (AST.xthi 1<rt> divisor == AST.b1))
    !!ir (trdx := AST.ite dividendIsNeg (AST.not rdx) rdx)
    !!ir (trax := AST.ite dividendIsNeg (AST.not rax .+ numI32 1 oprSize) rax)
    !!ir (tdivisor := AST.ite divisorIsNeg (AST.neg divisor) divisor)
    !!ir (updateSign := dividendIsNeg <+> divisorIsNeg)
  | _ -> raise InvalidOpcodeException
  !!ir (AST.cjmp errChk (AST.name lblComputable) (AST.name lblErr))
  !!ir (AST.lmark lblComputable)
  !!ir (AST.cjmp isEasy (AST.name lblEasy) (AST.name lblHard))
  !!ir (AST.lmark lblEasy)
  !!ir (quotient := trax ./ tdivisor)
  !!ir (remainder := trax .% tdivisor)
  !!ir (AST.jmp (AST.name lblAssign))
  !!ir (AST.lmark lblHard)
  !!ir (quotient := (bignum ./ (tdivisor ./ trdx)) .+ (trax ./ tdivisor))
  !!ir (remainder := trax .- (quotient .* tdivisor))
  !!ir (AST.lmark lblAssign)
  match opcode with
  | Opcode.DIV ->
    !!ir (dstAssign oprSize rax quotient)
    !!ir (dstAssign oprSize rdx remainder)
  | Opcode.IDIV ->
    !!ir (rax := (AST.ite updateSign (AST.neg quotient) quotient))
    !!ir (rdx := (AST.ite updateSign (AST.neg remainder) remainder))
  | _ -> raise InvalidOpcodeException

let private getDividend ctxt = function
  | 8<rt> -> !.ctxt R.AX
  | 16<rt> -> AST.concat (!.ctxt R.DX) (!.ctxt R.AX)
  | 32<rt> -> AST.concat (!.ctxt R.EDX) (!.ctxt R.EAX)
  | _ -> raise InvalidOperandSizeException

let private checkQuotientDIV oprSize lblAssign lblErr q =
  AST.cjmp (AST.xthi oprSize q == AST.num0 oprSize)
           (AST.name lblAssign) (AST.name lblErr)

let private checkQuotientIDIV oprSize sz lblAssign lblErr q =
  let amount = numI32 (RegType.toBitWidth oprSize - 1) oprSize
  let mask = AST.num1 oprSize << amount
  let msb = AST.xthi 1<rt> q
  let negRes = AST.lt q (AST.zext sz mask)
  let posRes = AST.gt q (AST.zext sz (mask .- (AST.num1 oprSize)))
  let cond = AST.ite (msb == AST.b1) negRes posRes
  AST.cjmp cond (AST.name lblErr) (AST.name lblAssign)

let divideWithConcat opcode oprSize divisor lblAssign lblErr ctxt ir =
  let dividend = getDividend ctxt oprSize
  let sz = TypeCheck.typeOf dividend
  let quotient = !*ir sz
  let remainder = !*ir sz
  match opcode with
  | Opcode.DIV ->
    let divisor = AST.zext sz divisor
    !!ir (quotient := dividend ./ divisor)
    !!ir (remainder := dividend .% divisor)
    !!ir (checkQuotientDIV oprSize lblAssign lblErr quotient)
  | Opcode.IDIV ->
    let divisor = AST.sext sz divisor
    !!ir (quotient := dividend ?/ divisor)
    !!ir (remainder := dividend ?% divisor)
    !!ir (checkQuotientIDIV oprSize sz lblAssign lblErr quotient)
  | _ -> raise InvalidOpcodeException
  !!ir (AST.lmark lblAssign)
  match oprSize with
  | 8<rt> ->
    !!ir (!.ctxt R.AL := AST.xtlo oprSize quotient)
    !!ir (!.ctxt R.AH := AST.xtlo oprSize remainder)
  | 16<rt> | 32<rt> ->
    let q = getRegOfSize ctxt oprSize grpEAX
    let r = getRegOfSize ctxt oprSize grpEDX
    !!ir (dstAssign oprSize q (AST.xtlo oprSize quotient))
    !!ir (dstAssign oprSize r (AST.xtlo oprSize remainder))
  | _ -> raise InvalidOperandSizeException

let div ins insLen ctxt =
  let ir = IRBuilder (16)
  let lblAssign = ir.NewSymbol "Assign"
  let lblChk = ir.NewSymbol "Check"
  let lblErr = ir.NewSymbol "DivErr"
  let divisor = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  !<ir insLen
  !!ir (AST.cjmp (divisor == AST.num0 oprSize)
                 (AST.name lblErr) (AST.name lblChk))
  !!ir (AST.lmark lblErr)
  !!ir (AST.sideEffect (Exception "DivErr"))
  !!ir (AST.lmark lblChk)
  match oprSize with
  | 64<rt> ->
    divideWithoutConcat ins.Opcode oprSize divisor lblAssign lblErr ctxt ir
  | _ ->
    divideWithConcat ins.Opcode oprSize divisor lblAssign lblErr ctxt ir
#if !EMULATION
  !!ir (!.ctxt R.CF := undefCF)
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.ZF := undefZF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let enter ins insLen ctxt =
  let oSz = getOperationSize ins
  let ir = IRBuilder (16)
  let struct (imm16, imm8) = transTwoOprs ins insLen ctxt
  let struct (allocSize, nestingLevel, cnt) = tmpVars3 ir oSz
  let struct (frameTemp, addrSize) = tmpVars2 ir ctxt.WordBitSize
  let bp = getBasePtr ctxt
  let sp = getStackPtr ctxt
  let lblLoop = ir.NewSymbol "Loop"
  let lblCont = ir.NewSymbol "Continue"
  let lblLevelCheck = ir.NewSymbol "NestingLevelCheck"
  let lblLv1 = ir.NewSymbol "NestingLevel1"
  let getAddrSize bitSize =
    if bitSize = 64<rt> then numI32 8 bitSize else numI32 4 bitSize
  !<ir insLen
  !!ir (allocSize := imm16)
  !!ir (nestingLevel := imm8 .% (numI32 32 oSz))
  !?ir (auxPush ctxt.WordBitSize ctxt bp)
  !!ir (frameTemp := sp)
  !!ir (addrSize := getAddrSize ctxt.WordBitSize)
  !!ir (AST.cjmp (nestingLevel == AST.num0 oSz)
                 (AST.name lblCont) (AST.name lblLevelCheck))
  !!ir (AST.lmark lblLevelCheck)
  !!ir (cnt := nestingLevel .- AST.num1 oSz)
  !!ir (AST.cjmp (AST.gt nestingLevel (AST.num1 oSz))
                 (AST.name lblLoop) (AST.name lblLv1))
  !!ir (AST.lmark lblLoop)
  !!ir (bp := bp .- addrSize)
  !?ir (auxPush ctxt.WordBitSize ctxt (AST.loadLE ctxt.WordBitSize bp))
  !!ir (cnt := cnt .- AST.num1 oSz)
  !!ir (AST.cjmp (cnt == AST.num0 oSz) (AST.name lblCont) (AST.name lblLoop))
  !!ir (AST.lmark lblLv1)
  !?ir (auxPush ctxt.WordBitSize ctxt frameTemp)
  !!ir (AST.lmark lblCont)
  !!ir (bp := frameTemp)
  !!ir (sp := sp .- AST.zext ctxt.WordBitSize allocSize)
  !>ir insLen

let private imul64Bit src1 src2 ir =
  let struct (hiSrc1, loSrc1, hiSrc2, loSrc2) = tmpVars4 ir 64<rt>
  let struct (tSrc1, tSrc2) = tmpVars2 ir 64<rt>
  let struct (tHigh, tLow) = tmpVars2 ir 64<rt>
  let n32 = numI32 32 64<rt>
  let mask = numI64 0xFFFFFFFFL 64<rt>
  let struct (src1IsNeg, src2IsNeg, isSign) = tmpVars3 ir 1<rt>
  !!ir (src1IsNeg := AST.xthi 1<rt> src1)
  !!ir (src2IsNeg := AST.xthi 1<rt> src2)
  !!ir (tSrc1 := AST.ite src1IsNeg (AST.neg src1) src1)
  !!ir (tSrc2 := AST.ite src2IsNeg (AST.neg src2) src2)
  !!ir (hiSrc1 := (tSrc1 >> n32) .& mask) (* SRC1[63:32] *)
  !!ir (loSrc1 := tSrc1 .& mask) (* SRC1[31:0] *)
  !!ir (hiSrc2 := (tSrc2 >> n32) .& mask) (* SRC2[63:32] *)
  !!ir (loSrc2 := tSrc2 .& mask) (* SRC2[31:0] *)
  let pHigh = hiSrc1 .* hiSrc1
  let pMid = (hiSrc1 .* loSrc2) .+ (loSrc1 .* hiSrc2)
  let pLow = (loSrc1 .* loSrc2)
  let high = pHigh .+ ((pMid .+ (pLow  >> n32)) >> n32)
  let low = pLow .+ ((pMid .& mask) << n32)
  !!ir (isSign := src1IsNeg <+> src2IsNeg)
  !!ir (tHigh := AST.ite isSign (AST.not high) high)
  !!ir (tLow := AST.ite isSign (AST.neg low) low)
  struct (tHigh, tLow)

let private oneOperandImul ctxt oprSize src ir =
  let sF = !.ctxt R.SF
  let shiftNum = RegType.toBitWidth oprSize
  match oprSize with
  | 8<rt> ->
    let mulSize = RegType.double oprSize
    let t = !*ir mulSize
    let cond = AST.sext mulSize (AST.xtlo oprSize t) == t
    !!ir (t := AST.sext mulSize (!.ctxt R.AL) .* AST.sext mulSize src)
    !!ir (dstAssign oprSize (!.ctxt R.AX) t)
    !!ir (sF := AST.extract t 1<rt> (shiftNum - 1))
    !!ir (!.ctxt R.CF := cond == AST.b0)
    !!ir (!.ctxt R.OF := cond == AST.b0)
  | 16<rt> | 32<rt> ->
    let mulSize = RegType.double oprSize
    let t = !*ir mulSize
    let cond = AST.sext mulSize (AST.xtlo oprSize t) == t
    let r1 = getRegOfSize ctxt oprSize grpEDX
    let r2 = getRegOfSize ctxt oprSize grpEAX
    !!ir (t := AST.sext mulSize r2 .* AST.sext mulSize src)
    !!ir (dstAssign oprSize r1 (AST.xthi oprSize t))
    !!ir (dstAssign oprSize r2 (AST.xtlo oprSize t))
    !!ir (sF := AST.extract t 1<rt> (shiftNum - 1))
    !!ir (!.ctxt R.CF := cond == AST.b0)
    !!ir (!.ctxt R.OF := cond == AST.b0)
  | 64<rt> ->
    let r1 = getRegOfSize ctxt oprSize grpEDX
    let r2 = getRegOfSize ctxt oprSize grpEAX
    let struct (high, low) = imul64Bit r2 src ir
    !!ir (dstAssign oprSize r1 high)
    !!ir (dstAssign oprSize r2 low)
    let num0 = AST.num0 64<rt>
    let numF = numI64 0xFFFFFFFFFFFFFFFFL 64<rt>
    let cond = !*ir 1<rt>
    !!ir (cond := AST.ite (AST.xthi 1<rt> low) (high == numF) (high == num0))
    !!ir (sF := AST.extract high 1<rt> (shiftNum - 1))
    !!ir (!.ctxt R.CF := cond == AST.b0)
    !!ir (!.ctxt R.OF := cond == AST.b0)
  | _ -> raise InvalidOperandSizeException

let private operandsImul ctxt oprSize dst src1 src2 ir =
  match oprSize with
  | 8<rt> | 16<rt> | 32<rt> ->
    let doubleWidth = RegType.double oprSize
    let t = !*ir doubleWidth
    let cond = (AST.sext doubleWidth dst) != t
    !!ir (t := AST.sext doubleWidth src1 .* AST.sext doubleWidth src2)
    !!ir (dstAssign oprSize dst (AST.xtlo oprSize t))
    !!ir (!.ctxt R.SF := AST.xthi 1<rt> dst)
    !!ir (!.ctxt R.CF := cond)
    !!ir (!.ctxt R.OF := cond)
  | 64<rt> ->
    let struct (high, low) = imul64Bit src1 src2 ir
    !!ir (dstAssign oprSize dst low)
    let num0 = AST.num0 64<rt>
    let numF = numI64 0xFFFFFFFFFFFFFFFFL 64<rt>
    let cond = !*ir 1<rt>
    !!ir (cond := AST.ite (AST.xthi 1<rt> low) (high != numF) (high != num0))
    !!ir (!.ctxt R.SF := AST.xthi 1<rt> dst)
    !!ir (!.ctxt R.CF := cond)
    !!ir (!.ctxt R.OF := cond)
  | _ -> raise InvalidOperandSizeException

let private buildMulBody ins insLen ctxt ir =
  let oprSize = getOperationSize ins
  match ins.Operands with
  | OneOperand op ->
    let src = transOprToExpr ins insLen ctxt op
    oneOperandImul ctxt oprSize src ir
  | TwoOperands (o1, o2) ->
    let dst = transOprToExpr ins insLen ctxt o1
    let src = transOprToExpr ins insLen ctxt o2
    operandsImul ctxt oprSize dst dst src ir
  | ThreeOperands (o1, o2, o3) ->
    let dst = transOprToExpr ins insLen ctxt o1
    let src1 = transOprToExpr ins insLen ctxt o2
    let src2 = transOprToExpr ins insLen ctxt o3
    operandsImul ctxt oprSize dst src1 src2 ir
  | _ -> raise InvalidOperandException

let imul ins insLen ctxt =
  let ir = IRBuilder (24)
  !<ir insLen
  !?ir (buildMulBody ins insLen ctxt)
#if !EMULATION
  !!ir (!.ctxt R.ZF := undefZF)
  !!ir (!.ctxt R.AF := undefAF)
  !!ir (!.ctxt R.PF := undefPF)
#endif
  !>ir insLen

let inc ins insLen ctxt =
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t1 := dst)
  !!ir (t2 := AST.num1 oprSize)
  !!ir (t3 := (t1 .+ t2))
  !!ir (dstAssign oprSize dst t3)
  !!ir (!.ctxt R.OF := ofOnAdd t1 t2 t3)
  !?ir (enumASZPFlags ctxt t1 t2 t3 oprSize)
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let private insBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let src = AST.zext ctxt.WordBitSize (!.ctxt R.DX)
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (AST.loadLE ctxt.WordBitSize di := src)
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))

let insinstr (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  if hasREPZ ins.Prefixes then
    strRepeat ins insLen ctxt insBody None ir
  elif hasREPNZ ins.Prefixes then Utils.impossible ()
  else insBody ins ctxt ir
  !>ir insLen

let interrupt ins insLen ctxt =
  match transOneOpr ins insLen ctxt with
  | { E = Num n } -> Interrupt (BitVector.toInt32 n) |> sideEffects insLen
  | _ -> raise InvalidOperandException

let private getCondOfJcc (ins: IntelInternalInstruction)
                         (ctxt: TranslationContext) =
#if DEBUG
  if ctxt.WordBitSize = 64<rt> && (getOperationSize ins) = 16<rt> then
    Utils.impossible ()
  else ()
#endif
  match ins.Opcode with
  | Opcode.JO -> !.ctxt R.OF
  | Opcode.JNO -> !.ctxt R.OF == AST.b0
  | Opcode.JB -> !.ctxt R.CF
  | Opcode.JNB -> !.ctxt R.CF == AST.b0
  | Opcode.JZ -> !.ctxt R.ZF
  | Opcode.JNZ -> !.ctxt R.ZF == AST.b0
  | Opcode.JBE -> (!.ctxt R.CF) .| (!.ctxt R.ZF)
  | Opcode.JA -> ((!.ctxt R.CF) .| (!.ctxt R.ZF)) == AST.b0
  | Opcode.JS -> !.ctxt R.SF
  | Opcode.JNS -> !.ctxt R.SF == AST.b0
  | Opcode.JP -> !.ctxt R.PF
  | Opcode.JNP -> !.ctxt R.PF == AST.b0
  | Opcode.JL -> !.ctxt R.SF != !.ctxt R.OF
  | Opcode.JNL -> !.ctxt R.SF == !.ctxt R.OF
  | Opcode.JLE -> (!.ctxt R.ZF) .|
                  (!.ctxt R.SF != !.ctxt R.OF)
  | Opcode.JG -> (!.ctxt R.ZF == AST.b0) .&
                 (!.ctxt R.SF == !.ctxt R.OF)
  | Opcode.JCXZ -> (!.ctxt R.CX) == (AST.num0 ctxt.WordBitSize)
  | Opcode.JECXZ ->
    let sz = ctxt.WordBitSize
    (AST.cast CastKind.ZeroExt sz (!.ctxt R.ECX)) == (AST.num0 sz)
  | Opcode.JRCXZ -> (!.ctxt R.RCX) == (AST.num0 ctxt.WordBitSize)
  | _ -> raise InvalidOpcodeException

let jcc ins insLen ctxt =
  let pc = getInstrPtr ctxt
  let jmpTarget = pc .+ transOneOpr ins insLen ctxt
  let cond = getCondOfJcc ins ctxt
  let fallThrough = pc .+ numInsLen insLen ctxt
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (AST.intercjmp cond jmpTarget fallThrough)
  !>ir insLen

let jmp ins insLen ctxt =
  let pc = getInstrPtr ctxt
  let struct (target, _) = transJumpTargetOpr ins pc insLen ctxt
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (AST.interjmp target InterJmpKind.Base)
  !>ir insLen

let private convertSrc = function
  | Load (_, _, expr, _) -> expr
  | _ -> Utils.impossible ()

let lea ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let src = convertSrc src.E
  let addrSize = getEffAddrSz ins
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir
    (match oprSize, addrSize with
     | 16<rt>, 16<rt> | 32<rt>, 32<rt> | 64<rt>, 64<rt> ->
       dstAssign oprSize dst src
     | 16<rt>, 32<rt> | 16<rt>, 64<rt> ->
       dstAssign oprSize dst (AST.xtlo 16<rt> src)
     | 32<rt>, 16<rt> -> dstAssign oprSize dst (AST.zext 32<rt> src)
     | 32<rt>, 64<rt> -> dstAssign oprSize dst (AST.xtlo 32<rt> src)
     | _ -> raise InvalidOperandSizeException)
  !>ir insLen

let leave _ins insLen ctxt =
  let sp = getStackPtr ctxt
  let bp = getBasePtr ctxt
  let ir = IRBuilder (8)
  !<ir insLen
  !!ir (sp := bp)
  !?ir (auxPop ctxt.WordBitSize ctxt bp)
  !>ir insLen

let private lodsBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let dst = getRegOfSize ctxt oprSize grpEAX
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (dst := AST.loadLE oprSize di)
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))

let lods (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  if hasREPZ ins.Prefixes then
    strRepeat ins insLen ctxt lodsBody None ir
  elif hasREPNZ ins.Prefixes then Utils.impossible ()
  else lodsBody ins ctxt ir
  !>ir insLen

let loop ins insLen ctxt =
  let ir = IRBuilder (8)
  let dst = transOneOpr ins insLen ctxt
  let addrSize = getEffAddrSz ins
  let pc = getInstrPtr ctxt
  let count, cntSize =
    if addrSize = 32<rt> then !.ctxt R.ECX, 32<rt>
    elif addrSize = 64<rt> then !.ctxt R.RCX, 64<rt>
    else !.ctxt R.CX, 16<rt>
  let zf = !.ctxt R.ZF
  !<ir insLen
  !!ir (count := count .- AST.num1 cntSize)
  let branchCond =
    match ins.Opcode with
    | Opcode.LOOP -> count != AST.num0 cntSize
    | Opcode.LOOPE -> (zf == AST.b1) .& (count != AST.num0 cntSize)
    | Opcode.LOOPNE -> (zf == AST.b0) .& (count != AST.num0 cntSize)
    | _ -> raise InvalidOpcodeException
  let fallThrough = pc .+ numInsLen insLen ctxt
  let jumpTarget = if addrSize = 16<rt> then pc .& numI32 0xFFFF 32<rt>
                   else pc .+ AST.sext addrSize dst
  !!ir (AST.intercjmp branchCond jumpTarget fallThrough)
  !>ir insLen

let lzcnt ins insLen ctxt =
  let ir = IRBuilder (16)
  let lblLoop = ir.NewSymbol "Loop"
  let lblExit = ir.NewSymbol "Exit"
  let lblLoopCond = ir.NewSymbol "LoopCond"
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let n = AST.num0 oprSize
  !<ir insLen
  let temp = !*ir oprSize
  !!ir (temp := numI32 (RegType.toBitWidth oprSize - 1) oprSize)
  !!ir (dst := n)
  !!ir (AST.lmark lblLoopCond)
  let cond1 = (AST.ge temp n) .& ((AST.xtlo 1<rt> (src >> temp)) == AST.b0)
  !!ir (AST.cjmp cond1 (AST.name lblLoop) (AST.name lblExit))
  !!ir (AST.lmark lblLoop)
  !!ir (temp := temp .- AST.num1 oprSize)
  !!ir (dst := dst .+ AST.num1 oprSize)
  !!ir (AST.jmp (AST.name lblLoopCond))
  !!ir (AST.lmark lblExit)
  let oprSize = numI32 (RegType.toBitWidth oprSize) oprSize
  !!ir (!.ctxt R.CF := dst == oprSize)
  !!ir (!.ctxt R.ZF := dst == n)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.PF := undefPF)
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !>ir insLen

let mov ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  !<ir insLen
  !!ir (dstAssign oprSize dst (AST.zext oprSize src))
  !>ir insLen

let movbe ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cnt = RegType.toByteWidth oprSize |> int
  let ir = IRBuilder (2 * cnt)
  let t = !*ir oprSize
  let tmps = Array.init cnt (fun _ -> !*ir 8<rt>)
  !<ir insLen
  !!ir (t := src)
  for i in 0 .. cnt - 1 do
    !!ir (tmps[i] := AST.extract t 8<rt> (i * 8))
  done
  !!ir (dstAssign oprSize dst (AST.concatArr (Array.rev tmps)))
  !>ir insLen

let private movsBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let si = !.ctxt (if is64bit ctxt then R.RSI else R.ESI)
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (AST.loadLE oprSize di := AST.loadLE oprSize si)
  !!ir (si := AST.ite df (si .- amount) (si .+ amount))
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))

let movs (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  if hasREPZ ins.Prefixes then
    strRepeat ins insLen ctxt movsBody None ir
  elif hasREPNZ ins.Prefixes then Utils.impossible ()
  else movsBody ins ctxt ir
  !>ir insLen

let movsx ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  !<ir insLen
  !!ir (dstAssign oprSize dst (AST.sext oprSize src))
  !>ir insLen

let movzx ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  !<ir insLen
  !!ir (dstAssign oprSize dst (AST.zext oprSize src))
  !>ir insLen

let mul ins insLen ctxt =
  let ir = IRBuilder (16)
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize with
  | 8<rt> ->
    let dblWidth = RegType.double oprSize
    let src1 = AST.zext dblWidth (getRegOfSize ctxt oprSize grpEAX)
    let src2 = AST.zext dblWidth (transOneOpr ins insLen ctxt)
    let t = !*ir dblWidth
    !!ir (t := src1 .* src2)
    let cond = !*ir 1<rt>
    !!ir (!.ctxt R.AX := t)
    !!ir (cond := AST.xthi oprSize t != (AST.num0 oprSize))
    !!ir (!.ctxt R.CF := cond)
    !!ir (!.ctxt R.OF := cond)
#if !EMULATION
    !!ir (!.ctxt R.SF := undefSF)
    !!ir (!.ctxt R.ZF := undefZF)
    !!ir (!.ctxt R.AF := undefAF)
    !!ir (!.ctxt R.PF := undefPF)
#endif
  | 16<rt> | 32<rt> ->
    let dblWidth = RegType.double oprSize
    let src1 = AST.zext dblWidth (getRegOfSize ctxt oprSize grpEAX)
    let src2 = AST.zext dblWidth (transOneOpr ins insLen ctxt)
    let t = !*ir dblWidth
    !!ir (t := src1 .* src2)
    let cond = !*ir 1<rt>
    !!ir (getRegOfSize ctxt oprSize grpEDX := AST.xthi oprSize t)
    !!ir (getRegOfSize ctxt oprSize grpEAX := AST.xtlo oprSize t)
    !!ir (cond := AST.xthi oprSize t != (AST.num0 oprSize))
    !!ir (!.ctxt R.CF := cond)
    !!ir (!.ctxt R.OF := cond)
#if !EMULATION
    !!ir (!.ctxt R.SF := undefSF)
    !!ir (!.ctxt R.ZF := undefZF)
    !!ir (!.ctxt R.AF := undefAF)
    !!ir (!.ctxt R.PF := undefPF)
#endif
  | 64<rt> ->
    let rax = getRegOfSize ctxt oprSize grpEAX
    let rdx = getRegOfSize ctxt oprSize grpEDX
    let src = transOneOpr ins insLen ctxt
    let struct (hiRAX, loRAX, hiSrc, loSrc) = tmpVars4 ir 64<rt>
    let struct (tHigh, tLow) = tmpVars2 ir 64<rt>
    let n32 = numI32 32 64<rt>
    let mask = numI64 0xFFFFFFFFL 64<rt>
    !!ir (hiRAX := (rax >> n32) .& mask) (* RAX[63:32] *)
    !!ir (loRAX := rax .& mask) (* RAX[31:0] *)
    !!ir (hiSrc := (src >> n32) .& mask) (* SRC[63:32] *)
    !!ir (loSrc := src .& mask) (* SRC[31:0] *)
    let pHigh = hiRAX .* hiSrc
    let pMid = (hiRAX .* loSrc) .+ (loRAX .* hiSrc)
    let pLow = (loRAX .* loSrc)
    let high = pHigh .+ ((pMid .+ (pLow  >> n32)) >> n32)
    let low = pLow .+ ((pMid .& mask) << n32)
    !!ir (tHigh := high)
    !!ir (tLow := low)
    !!ir (dstAssign oprSize rdx tHigh)
    !!ir (dstAssign oprSize rax tLow)
    let cond = !*ir 1<rt>
    !!ir (cond := tHigh != (AST.num0 oprSize))
    !!ir (!.ctxt R.CF := cond)
    !!ir (!.ctxt R.OF := cond)
#if !EMULATION
    !!ir (!.ctxt R.SF := undefSF)
    !!ir (!.ctxt R.ZF := undefZF)
    !!ir (!.ctxt R.AF := undefAF)
    !!ir (!.ctxt R.PF := undefPF)
#endif
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let neg ins insLen ctxt =
  let ir = IRBuilder (16)
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  let oFCond = t == (AST.num1 oprSize << (numU32 31u oprSize) )
  !<ir insLen
  !!ir (t := dst)
  !!ir (dstAssign oprSize dst (AST.neg t))
  !!ir (!.ctxt R.CF := t != AST.num0 oprSize)
  !!ir (!.ctxt R.OF := oFCond)
  !?ir (enumASZPFlags ctxt t (AST.num0 oprSize) dst oprSize)
  !>ir insLen

let nop insLen =
  let ir = IRBuilder (4)
  !<ir insLen
  !>ir insLen

let not ins insLen ctxt =
  let ir = IRBuilder (4)
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  !<ir insLen
  !!ir (dstAssign oprSize dst (AST.unop UnOpType.NOT dst))
  !>ir insLen

let logOr ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t := (dst .| AST.sext oprSize src))
  !!ir (dstAssign oprSize dst t)
  !!ir (!.ctxt R.CF := AST.b0)
  !!ir (!.ctxt R.OF := AST.b0)
#if !EMULATION
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !?ir (enumSZPFlags ctxt t oprSize)
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let private outsBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let si = !.ctxt (if is64bit ctxt then R.RSI else R.ESI)
  let src = !.ctxt R.DX
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  match oprSize with
  | 8<rt> ->
    !!ir (src := AST.zext 16<rt> (AST.loadLE oprSize si))
    !!ir (si := AST.ite df (si .- amount) (si .+ amount))
  | 16<rt> ->
    !!ir (src := AST.loadLE oprSize si)
    !!ir (si := AST.ite df (si .- amount) (si .+ amount))
  | 32<rt> ->
    !!ir (si := AST.ite df (si .- amount) (si .+ amount))
    !!ir (src := AST.xtlo 16<rt> (AST.loadLE oprSize si))
  | _ -> raise InvalidOperandSizeException

let outs (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  if hasREPZ ins.Prefixes then
    strRepeat ins insLen ctxt outsBody None ir
  elif hasREPNZ ins.Prefixes then Utils.impossible ()
  else outsBody ins ctxt ir
  !>ir insLen

let pop ins insLen ctxt =
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (4)
  !<ir insLen
  !?ir (auxPop oprSize ctxt dst)
  !>ir insLen

let popa insLen ctxt oprSize =
  let sp = !.ctxt R.ESP
  let di = if oprSize = 32<rt> then R.EDI else R.DI
  let si = if oprSize = 32<rt> then R.ESI else R.SI
  let bp = if oprSize = 32<rt> then R.EBP else R.BP
  let bx = if oprSize = 32<rt> then R.EBX else R.BX
  let dx = if oprSize = 32<rt> then R.EDX else R.DX
  let cx = if oprSize = 32<rt> then R.ECX else R.CX
  let ax = if oprSize = 32<rt> then R.EAX else R.AX
  let ir = IRBuilder (16)
  !<ir insLen
  !?ir (auxPop oprSize ctxt (!.ctxt di))
  !?ir (auxPop oprSize ctxt (!.ctxt si))
  !?ir (auxPop oprSize ctxt (!.ctxt bp))
  !!ir (sp := sp .+ (numI32 (int oprSize / 8) 32<rt>))
  !?ir (auxPop oprSize ctxt (!.ctxt bx))
  !?ir (auxPop oprSize ctxt (!.ctxt dx))
  !?ir (auxPop oprSize ctxt (!.ctxt cx))
  !?ir (auxPop oprSize ctxt (!.ctxt ax))
  !>ir insLen

let popcnt ins insLen ctxt =
  let ir = IRBuilder (16)
  let lblLoop = ir.NewSymbol "Loop"
  let lblExit = ir.NewSymbol "Exit"
  let lblLoopCond = ir.NewSymbol "LoopCond"
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let max = numI32 (RegType.toBitWidth oprSize) oprSize
  !<ir insLen
  let i = !*ir oprSize
  let count = !*ir oprSize
  !!ir (i := AST.num0 oprSize)
  !!ir (count := AST.num0 oprSize)
  !!ir (AST.lmark lblLoopCond)
  !!ir (AST.cjmp (AST.lt i max) (AST.name lblLoop) (AST.name lblExit))
  !!ir (AST.lmark lblLoop)
  let cond = (AST.xtlo 1<rt> (src >> i)) == AST.b1
  !!ir (count := AST.ite cond (count .+ AST.num1 oprSize) count)
  !!ir (i := i .+ AST.num1 oprSize)
  !!ir (AST.jmp (AST.name lblLoopCond))
  !!ir (AST.lmark lblExit)
  !!ir (dstAssign oprSize dst count)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !!ir (!.ctxt R.ZF := src == AST.num0 oprSize)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.CF := AST.b0)
  !!ir (!.ctxt R.PF := AST.b0)
  !>ir insLen

let popf ins insLen ctxt =
  let ir = IRBuilder (16)
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  !<ir insLen
  !?ir (auxPop oprSize ctxt t)
  !!ir (!.ctxt R.OF := AST.extract t 1<rt> 11)
  !!ir (!.ctxt R.DF := AST.extract t 1<rt> 10)
  !!ir (!.ctxt R.IF := AST.extract t 1<rt> 9)
  !!ir (!.ctxt R.TF := AST.extract t 1<rt> 8)
  !!ir (!.ctxt R.SF := AST.extract t 1<rt> 7)
  !!ir (!.ctxt R.ZF := AST.extract t 1<rt> 6)
  !!ir (!.ctxt R.AF := AST.extract t 1<rt> 4)
  !!ir (!.ctxt R.PF := AST.extract t 1<rt> 2)
  !!ir (!.ctxt R.CF := AST.xtlo 1<rt> t)
  !>ir insLen

let inline private padPushExpr oprSize opr =
  match opr.E with
  | Var (_, s, _, _) ->
    if isSegReg <| Register.ofRegID s then AST.zext oprSize opr else opr
  | Num (_) -> AST.sext oprSize opr
  | _ -> opr

let push ins insLen ctxt =
  let src = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (8)
  !<ir insLen
  !?ir (auxPush oprSize ctxt (padPushExpr oprSize src))
  !>ir insLen

let pusha ins insLen ctxt oprSize =
  let ir = IRBuilder (16)
  let t = !*ir oprSize
  let sp = if oprSize = 32<rt> then R.ESP else R.SP
  let ax = if oprSize = 32<rt> then R.EAX else R.AX
  let cx = if oprSize = 32<rt> then R.ECX else R.CX
  let dx = if oprSize = 32<rt> then R.EDX else R.DX
  let bx = if oprSize = 32<rt> then R.EBX else R.BX
  let bp = if oprSize = 32<rt> then R.EBP else R.BP
  let si = if oprSize = 32<rt> then R.ESI else R.SI
  let di = if oprSize = 32<rt> then R.EDI else R.DI
  !<ir insLen
  !!ir (dstAssign oprSize t (!.ctxt sp))
  !?ir (auxPush oprSize ctxt (!.ctxt ax))
  !?ir (auxPush oprSize ctxt (!.ctxt cx))
  !?ir (auxPush oprSize ctxt (!.ctxt dx))
  !?ir (auxPush oprSize ctxt (!.ctxt bx))
  !?ir (auxPush oprSize ctxt t)
  !?ir (auxPush oprSize ctxt (!.ctxt bp))
  !?ir (auxPush oprSize ctxt (!.ctxt si))
  !?ir (auxPush oprSize ctxt (!.ctxt di))
  !>ir insLen

let pushf ins insLen ctxt =
  let oprSize = getOperationSize ins
  let e = AST.zext oprSize <| !.ctxt R.CF
  (* We only consider 9 flags (we ignore system flags). *)
  let e = e .| ((AST.zext oprSize (!.ctxt R.PF)) << numI32 2 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.AF)) << numI32 4 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.ZF)) << numI32 6 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.SF)) << numI32 7 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.TF)) << numI32 8 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.IF)) << numI32 9 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.DF)) << numI32 10 oprSize)
  let e = e .| ((AST.zext oprSize (!.ctxt R.OF)) << numI32 11 oprSize)
  let e = match oprSize with
          | 16<rt> -> e
          | 32<rt> -> e .& (numI32 0xfcffff 32<rt>)
          | 64<rt> -> e .& (numI32 0xfcffff 64<rt>)
          | _ -> raise InvalidOperandSizeException
  let ir = IRBuilder (8)
  !<ir insLen
  !?ir (auxPush oprSize ctxt e)
  !>ir insLen

let rcl ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, count) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cF = !.ctxt R.CF
  let oF = !.ctxt R.OF
  let tmpCount = !*ir oprSize
  let size = numI32 (RegType.toBitWidth oprSize) oprSize
  let count = AST.zext oprSize count
  let cnt =
    match oprSize with
    | 8<rt> -> (count .& numI32 0x1f oprSize) .% numI32 9 oprSize
    | 16<rt> -> (count .& numI32 0x1f oprSize) .% numI32 17 oprSize
    | 32<rt> -> count .& numI32 0x1f oprSize
    | 64<rt> -> count .& numI32 0x3f oprSize
    | _ -> raise InvalidOperandSizeException
  let cond = count == AST.num1 oprSize
  !<ir insLen
  !!ir (tmpCount := cnt)
  !!ir (dst := (dst << tmpCount) .| (dst >> (size .- tmpCount)))
  !!ir (cF := AST.xthi 1<rt> dst)
#if !EMULATION
  !!ir (oF := AST.ite cond (AST.xthi 1<rt> dst <+> cF) undefOF)
#else
  !!ir (oF := AST.ite cond (AST.xthi 1<rt> dst <+> cF) oF)
#endif
  !>ir insLen

let rcr ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, count) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cF = !.ctxt R.CF
  let oF = !.ctxt R.OF
  let tmpCount = !*ir oprSize
  let size = numI32 (RegType.toBitWidth oprSize) oprSize
  let count = AST.zext oprSize count
  let cnt =
    match oprSize with
    | 8<rt> -> (count .& numI32 0x1f oprSize) .% numI32 9 oprSize
    | 16<rt> -> (count .& numI32 0x1f oprSize) .% numI32 17 oprSize
    | 32<rt> -> count .& numI32 0x1f oprSize
    | 64<rt> -> count .& numI32 0x3f oprSize
    | _ -> raise InvalidOperandSizeException
  let cond = count == AST.num1 oprSize
  !<ir insLen
  !!ir (tmpCount := cnt)
#if !EMULATION
  !!ir (oF := AST.ite cond (AST.xthi 1<rt> dst <+> cF) undefOF)
#else
  !!ir (oF := AST.ite cond (AST.xthi 1<rt> dst <+> cF) oF)
#endif
  !!ir (dst := (dst >> tmpCount) .| (dst << (size .- tmpCount)))
  !!ir (cF := AST.xthi 1<rt> dst)
  !>ir insLen

let rdpkru ins insLen ctxt =
  let ir = IRBuilder (8)
  let lblSucc = ir.NewSymbol "Succ"
  let lblErr = ir.NewSymbol "Err"
  let oprSize = getOperationSize ins
  let ecx = !.ctxt R.ECX
  let eax = getRegOfSize ctxt ctxt.WordBitSize grpEAX
  let edx = getRegOfSize ctxt ctxt.WordBitSize grpEDX
  !<ir insLen
  !!ir (AST.cjmp (ecx == AST.num0 oprSize) (AST.name lblSucc) (AST.name lblErr))
  !!ir (AST.lmark lblErr)
  !!ir (AST.sideEffect (Exception "GP"))
  !!ir (AST.lmark lblSucc)
  !!ir (eax := AST.zext ctxt.WordBitSize (!.ctxt R.PKRU))
  !!ir (edx := AST.num0 ctxt.WordBitSize)
  !>ir insLen

let retWithImm ins insLen ctxt =
  let ir = IRBuilder (8)
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  let sp = getStackPtr ctxt
  let src = transOneOpr ins insLen ctxt
  !<ir insLen
  !?ir (auxPop oprSize ctxt t)
  !!ir (sp := sp .+ (AST.zext oprSize src))
  !!ir (AST.interjmp t InterJmpKind.IsRet)
  !>ir insLen

let ret ins insLen ctxt =
  let ir = IRBuilder (6)
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  !<ir insLen
  !?ir (auxPop oprSize ctxt t)
  !!ir (AST.interjmp t InterJmpKind.IsRet)
  !>ir insLen

let rotate ins insLen ctxt lfn hfn cfFn ofFn =
  let ir = IRBuilder (8)
  let struct (dst, count) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cF = !.ctxt R.CF
  let oF = !.ctxt R.OF
  let countMask = if is64REXW ctxt ins then numU32 0x3Fu oprSize
                  else numU32 0x1Fu oprSize
  let size = numI32 (RegType.toBitWidth oprSize) oprSize
  let orgCount = !*ir oprSize
  let cond1 = orgCount == AST.num0 oprSize
  let cond2 = orgCount == AST.num1 oprSize
  !<ir insLen
  !!ir (orgCount := (AST.zext oprSize count .& countMask))
  !!ir (dst := (lfn dst orgCount) .| (hfn dst (size .- orgCount)))
  !!ir (cF := AST.ite cond1 cF (cfFn 1<rt> dst))
#if !EMULATION
  !!ir (oF := AST.ite cond2 (ofFn dst cF) undefOF)
#else
  !!ir (oF := AST.ite cond2 (ofFn dst cF) oF)
#endif
  !>ir insLen

let rol ins insLen ctxt =
  let ofFn dst cF = cF <+> AST.xthi 1<rt> dst
  rotate ins insLen ctxt (<<) (>>) AST.xtlo ofFn

let ror ins insLen ctxt =
  let ofFn dst _cF =
    AST.xthi 1<rt> dst <+> AST.extract dst 1<rt> 1
  rotate ins insLen ctxt (>>) (<<) AST.xthi ofFn

let rorx ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = transThreeOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let y = !*ir oprSize
  if oprSize = 32<rt> then
    !!ir (y := imm .& (numI32 0x1F oprSize))
    !!ir (dst := (src >> y) .| (src << (numI32 32 oprSize .- y)))
  else (* OperandSize = 64 *)
    !!ir (y := imm .& (numI32 0x3F oprSize))
    !!ir (dst := (src >> y) .| (src << (numI32 64 oprSize .- y)))
  !>ir insLen

let sahf ins insLen ctxt =
  let ir = IRBuilder (8)
  let ah = !.ctxt R.AH
  !<ir insLen
  !!ir (!.ctxt R.CF := AST.xtlo 1<rt> ah)
  !!ir (!.ctxt R.PF := AST.extract ah 1<rt> 2)
  !!ir (!.ctxt R.AF := AST.extract ah 1<rt> 4)
  !!ir (!.ctxt R.ZF := AST.extract ah 1<rt> 6)
  !!ir (!.ctxt R.SF := AST.extract ah 1<rt> 7)
  !>ir insLen

let shift ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let n0 = AST.num0 oprSize
  let n1 = AST.num1 oprSize
  let countMask = if is64REXW ctxt ins then numU32 0x3Fu oprSize
                  else numU32 0x1Fu oprSize
  let cnt = (AST.zext oprSize src) .& countMask
  let cond1 = cnt == n1
  let cond2 = cnt == n0
  let oF = !.ctxt R.OF
  let cF = !.ctxt R.CF
  let sF = !.ctxt R.SF
  let zF = !.ctxt R.ZF
  let aF = !.ctxt R.AF
  let tDst = !*ir oprSize
  let tCnt = !*ir oprSize
  !<ir insLen
  !!ir (tDst := dst)
  match ins.Opcode with
  | Opcode.SAR ->
    let prevLBit = AST.xtlo 1<rt> (tDst ?>> tCnt)
    !!ir (dst := dst ?>> cnt)
    !!ir (tCnt := cnt .- n1)
    !!ir (cF := AST.ite cond2 cF prevLBit)
#if !EMULATION
    !!ir (oF := AST.ite cond1 AST.b0 (AST.ite cond2 oF undefOF))
#else
    !!ir (oF := AST.ite cond1 AST.b0 oF)
#endif
  | Opcode.SHL ->
    let prevHBit = AST.xthi 1<rt> (tDst << tCnt)
    let of1 = AST.xthi 1<rt> dst <+> cF
    !!ir (dstAssign oprSize dst (dst << cnt))
    !!ir (tCnt := cnt .- n1)
    !!ir (cF := AST.ite cond2 cF prevHBit)
#if !EMULATION
    !!ir (oF := AST.ite cond1 of1 (AST.ite cond2 oF undefOF))
#else
    !!ir (oF := AST.ite cond1 of1 oF)
#endif
  | Opcode.SHR ->
    let prevLBit = AST.xtlo 1<rt> (tDst ?>> tCnt)
    !!ir (dstAssign oprSize dst (dst >> cnt))
    !!ir (tCnt := cnt .- n1)
    !!ir (cF := AST.ite cond2 cF prevLBit)
#if !EMULATION
    !!ir
      (oF := AST.ite cond1 (AST.xthi 1<rt> tDst) (AST.ite cond2 oF undefOF))
#else
    !!ir (oF := AST.ite cond1 (AST.xthi 1<rt> tDst) oF)
#endif
  | _ -> raise InvalidOpcodeException
  !!ir (sF := AST.ite cond2 sF (AST.xthi 1<rt> dst))
  !?ir (buildPF ctxt dst oprSize (Some cond2))
  !!ir (zF := AST.ite cond2 zF (dst == n0))
#if !EMULATION
  !!ir (aF := AST.ite cond2 aF undefAF)
#endif
  !>ir insLen

let sbb ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let struct (t1, t2, t3, t4) = tmpVars4 ir oprSize
  let cf = !.ctxt R.CF
  !<ir insLen
  !!ir (t1 := dst)
  !!ir (t2 := AST.sext oprSize src)
  !!ir (t3 := t2 .+ AST.zext oprSize cf)
  !!ir (t4 := t1 .- t3)
  !!ir (dstAssign oprSize dst t4)
  !!ir (cf := (AST.lt t1 t3) .| (AST.lt t3 t2))
  !!ir (!.ctxt R.OF := ofOnSub t1 t2 t4)
  !?ir (enumASZPFlags ctxt t1 t2 t4 oprSize)
  !>ir insLen

let private scasBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  let df = !.ctxt R.DF
  let x = getRegOfSize ctxt oprSize grpEAX
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let tSrc = !*ir oprSize
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (tSrc := AST.loadLE oprSize di)
  !!ir (t := x .- tSrc)
  !?ir (enumEFLAGS ctxt x tSrc t oprSize (cfOnSub x tSrc) (ofOnSub x tSrc t))
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))

let scas (ins: InsInfo) insLen ctxt =
  let pref = ins.Prefixes
  let zfCond n = Some (!.ctxt R.ZF == n)
  let ir = IRBuilder (32)
  !<ir insLen
  if hasREPZ pref then
    strRepeat ins insLen ctxt scasBody (zfCond AST.b0) ir
  elif hasREPNZ pref then
    strRepeat ins insLen ctxt scasBody (zfCond AST.b1) ir
  else scasBody ins ctxt ir
  !>ir insLen

let private getCondOfSet (ins: IntelInternalInstruction) ctxt =
  match ins.Opcode with
  | Opcode.SETO   -> !.ctxt R.OF
  | Opcode.SETNO  -> !.ctxt R.OF == AST.b0
  | Opcode.SETB   -> !.ctxt R.CF
  | Opcode.SETNB  -> !.ctxt R.CF == AST.b0
  | Opcode.SETZ   -> !.ctxt R.ZF
  | Opcode.SETNZ  -> !.ctxt R.ZF == AST.b0
  | Opcode.SETBE  -> (!.ctxt R.CF) .| (!.ctxt R.ZF)
  | Opcode.SETA   -> ((!.ctxt R.CF) .| (!.ctxt R.ZF)) == AST.b0
  | Opcode.SETS   -> !.ctxt R.SF
  | Opcode.SETNS  -> !.ctxt R.SF == AST.b0
  | Opcode.SETP   -> !.ctxt R.PF
  | Opcode.SETNP  -> !.ctxt R.PF == AST.b0
  | Opcode.SETL   -> !.ctxt R.SF != !.ctxt R.OF
  | Opcode.SETNL  -> !.ctxt R.SF == !.ctxt R.OF
  | Opcode.SETLE  -> !.ctxt R.ZF .|
                     (!.ctxt R.SF != !.ctxt R.OF)
  | Opcode.SETG   -> (!.ctxt R.ZF == AST.b0) .&
                     (!.ctxt R.SF == !.ctxt R.OF)
  | _ -> raise InvalidOpcodeException

let setcc ins insLen ctxt =
  let ir = IRBuilder (4)
  let dst = transOneOpr ins insLen ctxt
  let oprSize = getOperationSize ins
  let cond = getCondOfSet ins ctxt |> AST.zext oprSize
  !<ir insLen
  !!ir (dstAssign oprSize dst cond)
  !>ir insLen

let inline shiftDblPrec ins insLen ctxt fnDst fnSrc isShl =
  let ir = IRBuilder (16)
  let struct (dst, src, cnt) = transThreeOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let orig = !*ir oprSize
  let c = !*ir oprSize
  let cond1 = c == AST.num0 oprSize
  let cond2 = c == AST.num1 oprSize
  let cF = !.ctxt R.CF
  let oF = !.ctxt R.OF
  let aF = !.ctxt R.AF
  let maxSz = numI32 (if is64REXW ctxt ins then 64 else 32) oprSize
  let final = AST.ite cond1 orig ((fnDst orig c) .| (fnSrc src (maxSz .- c)))
  !<ir insLen
  !!ir (orig := dst)
  !!ir (c := (AST.zext oprSize cnt) .% maxSz)
  !!ir (dstAssign oprSize dst final)
  !!ir (
    if isShl then
      cF := AST.ite cond1 cF (AST.xtlo 1<rt> (orig >> (maxSz .- c)))
    else
      cF := AST.ite cond1 cF (AST.xtlo 1<rt> (orig >> (c .- AST.num1 oprSize)))
  )
#if !EMULATION
  !!ir (oF := AST.ite cond1 oF
               (AST.ite cond2 (AST.xthi 1<rt> (orig <+> dst)) undefOF))
  !!ir (aF := AST.ite cond1 aF undefAF)
#else
  !!ir (oF := AST.ite cond1 oF
               (AST.ite cond2 (AST.xthi 1<rt> (orig <+> dst)) oF))
#endif
  !?ir (enumSZPFlags ctxt dst oprSize)
  !>ir insLen

let shld ins insLen ctxt =
  shiftDblPrec ins insLen ctxt (<<) (>>) true

let shrd ins insLen ctxt =
  shiftDblPrec ins insLen ctxt (>>) (<<) false

let shlx ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src1, src2) = transThreeOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let temp = !*ir oprSize
  let countMask = if is64REXW ctxt ins then 0x3F else 0x1F // FIXME: CS.L = 1
  let count = src2 .& (numI32 countMask oprSize)
  !<ir insLen
  !!ir (temp := src1)
  !!ir (AST.xthi 1<rt> dst := AST.xthi 1<rt> temp)
  !!ir (dst := dst << count)
  !>ir insLen

let setFlag insLen ctxt flag =
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (!.ctxt flag := AST.b1)
  !>ir insLen

let stc insLen ctxt = setFlag insLen ctxt R.CF

let std insLen ctxt = setFlag insLen ctxt R.DF

let sti insLen ctxt = setFlag insLen ctxt R.IF

let private stosBody ins ctxt ir =
  let oprSize = getOperationSize ins
  let df = !.ctxt R.DF
  let di = !.ctxt (if is64bit ctxt then R.RDI else R.EDI)
  let src = getRegOfSize ctxt oprSize grpEAX
  let amount = numI32 (RegType.toByteWidth oprSize) ctxt.WordBitSize
  !!ir (AST.loadLE oprSize di := src)
  !!ir (di := AST.ite df (di .- amount) (di .+ amount))

let stos (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  if hasREPZ ins.Prefixes then
    strRepeat ins insLen ctxt stosBody None ir
  elif hasREPNZ ins.Prefixes then Utils.impossible ()
  else stosBody ins ctxt ir
  !>ir insLen

let sub ins insLen ctxt =
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let ir = IRBuilder (16)
  let struct (t1, t2, t3) = tmpVars3 ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t1 := dst)
  !!ir (t2 := src)
  !!ir (t3 := t1 .- t2)
  !!ir (dstAssign oprSize dst t3)
  !?ir (enumEFLAGS ctxt t1 t2 t3 oprSize (cfOnSub t1 t2) (ofOnSub t1 t2 t3))
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let test ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (src1, src2) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  !<ir insLen
  !!ir (t := src1 .& src2)
  !!ir (!.ctxt R.SF := AST.xthi 1<rt> t)
  !!ir (!.ctxt R.ZF := t == (AST.num0 oprSize))
  !?ir (buildPF ctxt t oprSize None)
  !!ir (!.ctxt R.CF := AST.b0)
  !!ir (!.ctxt R.OF := AST.b0)
#if !EMULATION
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !>ir insLen

let tzcnt ins insLen ctxt =
  let ir = IRBuilder (16)
  let lblLoop = ir.NewSymbol "Loop"
  let lblExit = ir.NewSymbol "Exit"
  let lblLoopCond = ir.NewSymbol "LoopCond"
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let max = numI32 (RegType.toBitWidth oprSize) oprSize
  !<ir insLen
  let t1 = !*ir oprSize
  !!ir (t1 := AST.num0 oprSize)
  !!ir (AST.lmark lblLoopCond)
  let cond = (AST.lt t1 max) .& (AST.xtlo 1<rt> (src >> t1) == AST.b0)
  !!ir (AST.cjmp cond (AST.name lblLoop) (AST.name lblExit))
  !!ir (AST.lmark lblLoop)
  !!ir (t1 := t1 .+ AST.num1 oprSize)
  !!ir (AST.jmp (AST.name lblLoopCond))
  !!ir (AST.lmark lblExit)
  !!ir (dstAssign oprSize dst t1)
  !!ir (!.ctxt R.CF := dst == max)
  !!ir (!.ctxt R.ZF := dst == AST.num0 oprSize)
#if !EMULATION
  !!ir (!.ctxt R.OF := undefOF)
  !!ir (!.ctxt R.SF := undefSF)
  !!ir (!.ctxt R.PF := undefPF)
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !>ir insLen

let wrfsbase ins insLen ctxt =
  let ir = IRBuilder (4)
  let src = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (!.ctxt R.FSBase := AST.zext ctxt.WordBitSize src)
  !>ir insLen

let wrgsbase ins insLen ctxt =
  let ir = IRBuilder (4)
  let src = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (!.ctxt R.GSBase := AST.zext ctxt.WordBitSize src)
  !>ir insLen

let wrpkru ins insLen ctxt =
  let ir = IRBuilder (8)
  let lblSucc = ir.NewSymbol "Succ"
  let lblErr = ir.NewSymbol "Err"
  let oprSize = getOperationSize ins
  let ecxIsZero = !.ctxt R.ECX == AST.num0 oprSize
  let edxIsZero = !.ctxt R.EDX == AST.num0 oprSize
  let cond = ecxIsZero .& edxIsZero
  !<ir insLen
  !!ir (AST.cjmp cond (AST.name lblSucc) (AST.name lblErr))
  !!ir (AST.lmark lblErr)
  !!ir (AST.sideEffect (Exception "GP"))
  !!ir (AST.lmark lblSucc)
  !!ir (!.ctxt R.PKRU := !.ctxt R.EAX)
  !>ir insLen

let xadd ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (d, s) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let t = !*ir oprSize
  !<ir insLen
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Lock) else ()
  !!ir (t := s .+ d)
  !!ir (dstAssign oprSize s d)
  !!ir (dstAssign oprSize d t)
  !?ir (enumEFLAGS ctxt d s t oprSize (cfOnSub d s) (ofOnAdd d s t))
  if hasLock ins.Prefixes then !!ir (AST.sideEffect Unlock) else ()
  !>ir insLen

let xchg ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  !<ir insLen
  if dst <> src then
    let oprSize = getOperationSize ins
    let t = !*ir oprSize
    !!ir (t := dst)
    !!ir (dstAssign oprSize dst src)
    !!ir (dstAssign oprSize src t)
  !>ir insLen

let xlatb ins insLen ctxt =
  let ir = IRBuilder (4)
  let addressSize = getEffAddrSz ins
  let al = AST.zext addressSize (!.ctxt R.AL)
  let bx = getRegOfSize ctxt addressSize grpEBX
  !<ir insLen
  !!ir (!.ctxt R.AL := AST.loadLE 8<rt> (al .+ bx))
  !>ir insLen

let xor ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = transTwoOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let r = !*ir oprSize
  !<ir insLen
  !!ir (r := dst <+> AST.sext oprSize src)
  !!ir (dstAssign oprSize dst r)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.CF := AST.b0)
  !!ir (!.ctxt R.SF := AST.xthi 1<rt> r)
  !!ir (!.ctxt R.ZF := r == (AST.num0 oprSize))
  !?ir (buildPF ctxt r oprSize None)
#if !EMULATION
  !!ir (!.ctxt R.AF := undefAF)
#endif
  !>ir insLen

IntelHelper.fs
//这段代码定义了Intel体系结构的操作码大小计算逻辑。
//主要功能点如下:
//1. 定义操作码大小计算器InsSizeComputer及其各个派生类,对应不同操作码大小规则。
//2. 定义ReadHelper类,用于读取和解析机器码字节流。
//3. 提供获取各种寄存器值的方法。
//4. 定义操作码大小常量,如通用操作数大小SzDef等。 
//5. 各个InsSizeComputer实现具体的大小计算逻辑。
//6. 考虑不同字长和扩展指令前缀对大小的影响。
//运算过程:
//1. 根据机器码特征获取ReadHelper对象。
//2. 选择对应的InsSizeComputer。
//3. InsSizeComputer计算各个寄存器(内存/寄存器)大小。
//4. 赋值给ReadHelper对象,下游使用。
//5. 不同操作码类别使用不同InsSizeComputer实现大小逻辑。
//所以此模块定义完整的Intel体系结构操作码大小计算逻辑流程,是机器码分析重要组成部分。

module internal B2R2.FrontEnd.BinLifter.Intel.Helper

open System
open B2R2
open B2R2.FrontEnd.BinLifter
open System.Runtime.CompilerServices
open LanguagePrimitives

[<assembly: InternalsVisibleTo("B2R2.Peripheral.Assembly.Intel")>]
do ()

type [<AbstractClass>] OperandParser () =
  abstract member Render: ByteSpan * ReadHelper -> Operands

and [<AbstractClass>] InsSizeComputer () =
  abstract Render: ReadHelper -> SzCond -> unit

and ReadHelper (addr, cpos, pref, rex, vex, wordSz, ops, szs) =
  let reader = BinReader.binReaderLE
  let mutable addr: Addr = addr
  let mutable cpos: int = cpos (* current position *)
  let mutable pref: Prefix = pref
  let mutable rex: REXPrefix = rex
  let mutable vex: VEXInfo option = vex
  let mutable wordSize: WordSize = wordSz
  let mutable memOprSz = 0<rt>
  let mutable memAddrSz = 0<rt>
  let mutable memRegSz = 0<rt>
  let mutable regSz = 0<rt>
  let mutable operationSz = 0<rt>
  new (wordSz, oparsers, szcomputers) =
    ReadHelper (0UL, 0, Prefix.PrxNone, REXPrefix.NOREX, None,
                wordSz, oparsers, szcomputers)
  member __.InsAddr with get(): Addr = addr and set(a) = addr <- a
  member __.CurrPos with get() = cpos and set(p) = cpos <- p
  member __.IncPos () = cpos <- cpos + 1
  member __.Prefixes with get() = pref and set(p) = pref <- p
  member __.REXPrefix with get(): REXPrefix = rex and set(r) = rex <- r
  member __.VEXInfo with get(): VEXInfo option = vex and set(v) = vex <- v
  member __.WordSize with get(): WordSize = wordSize and set(w) = wordSize <- w
  member __.OprParsers with get(): OperandParser [] = ops
  member __.SzComputers with get(): InsSizeComputer [] = szs
  member __.MemEffOprSize with get() = memOprSz and set(s) = memOprSz <- s
  member __.MemEffAddrSize with get() = memAddrSz and set(s) = memAddrSz <- s
  member __.MemEffRegSize with get() = memRegSz and set(s) = memRegSz <- s
  member __.RegSize with get() = regSz and set(s) = regSz <- s
  member __.OperationSize with get() = operationSz and set(s) = operationSz <- s

  member inline private __.ModCPos i = cpos <- cpos + i

  member inline __.PeekByte (span: ByteSpan) = span[cpos]

  member inline __.ReadByte (span: ByteSpan) =
    let v = span[cpos]
    __.ModCPos 1
    v

  member inline __.ReadInt8 (span: ByteSpan) =
    let v = reader.ReadInt8 (span, cpos)
    __.ModCPos 1
    v

  member inline __.ReadInt16 (span: ByteSpan) =
    let v = reader.ReadInt16 (span, cpos)
    __.ModCPos 2
    v

  member inline __.ReadInt32 (span: ByteSpan) =
    let v = reader.ReadInt32 (span, cpos)
    __.ModCPos 4
    v

  member inline __.ReadInt64 (span: ByteSpan) =
    let v = reader.ReadInt64 (span, cpos)
    __.ModCPos 8
    v

  member inline __.ReadUInt8 (span: ByteSpan) =
    let v = reader.ReadUInt8 (span, cpos)
    __.ModCPos 1
    v

  member inline __.ReadUInt16 (span: ByteSpan) =
    let v = reader.ReadUInt16 (span, cpos)
    __.ModCPos 2
    v

  member inline __.ReadUInt32 (span: ByteSpan) =
    let v = reader.ReadUInt32 (span, cpos)
    __.ModCPos 4
    v

  member inline __.ReadUInt64 (span: ByteSpan) =
    let v = reader.ReadUInt64 (span, cpos)
    __.ModCPos 8
    v

  member inline __.ParsedLen () = cpos

  member inline __.GetInsID (span: ByteSpan) =
    let len = cpos
    let bs = reader.ReadBytes (span, 0, len)
    let chars: char [] = Array.zeroCreate (len * sizeof<char>)
    Buffer.BlockCopy (bs, 0, chars, 0, bs.Length)
    String chars

let inline hasREXW rexPref = rexPref &&& REXPrefix.REXW = REXPrefix.REXW

let inline hasREXR rexPref = rexPref &&& REXPrefix.REXR = REXPrefix.REXR

let inline hasAddrSz p = p &&& Prefix.PrxADDRSIZE = Prefix.PrxADDRSIZE

let inline hasOprSz p = p &&& Prefix.PrxOPSIZE = Prefix.PrxOPSIZE

let inline hasREPZ p = p &&& Prefix.PrxREPZ = Prefix.PrxREPZ

let inline hasREPNZ p = p &&& Prefix.PrxREPNZ = Prefix.PrxREPNZ

let inline hasLock p = p &&& Prefix.PrxLOCK = Prefix.PrxLOCK

let inline is64bit (rhlp: ReadHelper) = rhlp.WordSize = WordSize.Bit64

let inline hasNoPref (rhlp: ReadHelper) = (int rhlp.Prefixes) = 0

let inline hasNoREX (rhlp: ReadHelper) = rhlp.REXPrefix = REXPrefix.NOREX

let inline getMod (byte: byte) = (int byte >>> 6) &&& 0b11

let inline getReg (byte: byte) = (int byte >>> 3) &&& 0b111

let inline getRM (byte: byte) = (int byte) &&& 0b111

let inline getSTReg n = Register.streg n |> OprReg

let inline modIsMemory b = (getMod b) <> 0b11

let inline modIsReg b = (getMod b) = 0b11

let inline isReg001 span (rhlp: ReadHelper) = getReg (rhlp.PeekByte span) = 1

let inline isReg010 span (rhlp: ReadHelper) = getReg (rhlp.PeekByte span) = 2

let inline isReg101 span (rhlp: ReadHelper) = getReg (rhlp.PeekByte span) = 5

let inline isReg110 span (rhlp: ReadHelper) = getReg (rhlp.PeekByte span) = 6

/// Filter out segment-related prefixes.
let [<Literal>] ClearSegMask: Prefix = EnumOfValue 0xFC0F

/// Filter out PrxREPNZ(0x2), PrxREPZ(0x8), and PrxOPSIZE(0x400).
let [<Literal>] ClearVEXPrefMask: Prefix = EnumOfValue 0xFBF5

/// Filter out group 1 prefixes.
let [<Literal>] ClearGrp1PrefMask: Prefix = EnumOfValue 0xFFF0

let getSegment pref =
  if (pref &&& Prefix.PrxCS) <> Prefix.PrxNone then Some R.CS
  elif (pref &&& Prefix.PrxDS) <> Prefix.PrxNone then Some R.DS
  elif (pref &&& Prefix.PrxES) <> Prefix.PrxNone then Some R.ES
  elif (pref &&& Prefix.PrxFS) <> Prefix.PrxNone then Some R.FS
  elif (pref &&& Prefix.PrxGS) <> Prefix.PrxNone then Some R.GS
  elif (pref &&& Prefix.PrxSS) <> Prefix.PrxNone then Some R.SS
  else None

let isBranch = function
  | Opcode.CALLFar | Opcode.CALLNear
  | Opcode.JMPFar | Opcode.JMPNear
  | Opcode.RETFar | Opcode.RETFarImm | Opcode.RETNear | Opcode.RETNearImm
  | Opcode.JA | Opcode.JB | Opcode.JBE | Opcode.JCXZ | Opcode.JECXZ
  | Opcode.JG | Opcode.JL | Opcode.JLE | Opcode.JNB | Opcode.JNL | Opcode.JNO
  | Opcode.JNP | Opcode.JNS | Opcode.JNZ | Opcode.JO | Opcode.JP
  | Opcode.JRCXZ | Opcode.JS | Opcode.JZ | Opcode.LOOP | Opcode.LOOPE
  | Opcode.LOOPNE -> true
  | _ -> false

let isCETInstr = function
  | Opcode.INCSSPD | Opcode.INCSSPQ | Opcode.RDSSPD | Opcode.RDSSPQ
  | Opcode.SAVEPREVSSP | Opcode.RSTORSSP | Opcode.WRSSD | Opcode.WRSSQ
  | Opcode.WRUSSD | Opcode.WRUSSQ | Opcode.SETSSBSY | Opcode.CLRSSBSY -> true
  | _ -> false

///////////////////////////////
let getOprSize size sizeCond =
  if sizeCond = SzCond.F64 ||
    (size = 32<rt> && sizeCond = SzCond.D64) then 64<rt>
  else size

let inline getEffOprSize32 prefs =
  if hasOprSz prefs then 16<rt> else 32<rt>

let inline getEffAddrSize32 prefs =
  if hasAddrSz prefs then 16<rt> else 32<rt>

let inline getEffOprSize64 prefs rexPref sizeCond =
  if hasREXW rexPref then 64<rt>
  else
    if hasOprSz prefs then getOprSize 16<rt> sizeCond
    else getOprSize 32<rt> sizeCond

let inline getEffAddrSize64 prefs =
  if hasAddrSz prefs then 32<rt> else 64<rt>

let getEffAddrSize (rhlp: ReadHelper) =
  if rhlp.WordSize = WordSize.Bit32 then getEffAddrSize32 rhlp.Prefixes
  else getEffAddrSize64 rhlp.Prefixes

let getEffOprSize (rhlp: ReadHelper) sizeCond =
  if rhlp.WordSize = WordSize.Bit32 then getEffOprSize32 rhlp.Prefixes
  else getEffOprSize64 rhlp.Prefixes rhlp.REXPrefix sizeCond

/// AHR12LIb ALIb ALOb ALR8LIb BHR15LIb BLR11LIb CHR13LIb CLR9LIb DHR14LIb
/// DLR10LIb Eb Eb1 EbCL EbGb EbIb GbEb IbAL Jb ObAL XbYb
type SzByte () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 8<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 8<rt>
    rhlp.RegSize <- 8<rt>
    rhlp.OperationSize <- 8<rt>

/// GwMw EvSw EwGw MwGw SwEw
type SzWord () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 16<rt>
    rhlp.RegSize <- 16<rt>
    rhlp.OperationSize <- 16<rt>

/// ALDX DXAL DXEAX EAX EAXDX EAXIb EBP EBX ECX EDI EDX ESI ESP Ev Ev1 EvCL EvGv
/// EvGvCL EvGvIb EvIb EvSIb EvSIz EyGy GvEv GvEvSIb GvEvSIz GvEy GvMa GvMv
/// GyByEy GyEy GyEyBy GyEyIb GyMy Ib IbEAX Iw IwIb Mv MyGy Mz OvRAX RAXIv RAXOv
/// RAXrAX RAXrBP RAXrBX RAXrCX RAXrDI RAXrDX RAXrSI RAXrSP RAXSIz RAXz RBPIv
/// RBPz RBXIv RBXz RCXIv RCXz RDIIv RDIz RDXIv RDXz RSIIv RSIz RSPIv RSPz Rv Ry
/// SIb SIz
type SzDef () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// HxUxIb MpdVpd MpsVps MxVx MZxzVZxz VpdHpdWpd VpdHpdWpdIb VpdWpd VpsHpsWps
/// VpsHpsWpsIb VpsWps VsdHsdWsdIb VssHssWssIb VxHxWsd VxHxWss VxHxWx VxHxWxIb
/// VxMx VxWx VxWxIb VZxzWZxz WpdVpd WpsVps WsdHxVsd WssHxVss WxVx WZxzVZxz
type SzVecDef () =
  inherit InsSizeComputer ()
  override __.Render (rhlp: ReadHelper) _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- vLen
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- vLen
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// GvEd Md
type SzDV () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// Md
type SzD () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- 32<rt>

/// Ew Mw
type SzMemW () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 16<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- 16<rt>

/// CS ES DS FS GS SS
type SzRegW () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 16<rt>
    rhlp.OperationSize <- 16<rt>

/// GvEw
type SzWV () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 16<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// RAX RCX RDX RBX RSP RBP RSI RDI Jz
type SzD64 () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// GzMp
type SzPZ () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    let oprSize =
      if rhlp.Prefixes &&& Prefix.PrxOPSIZE = Prefix.PrxOPSIZE then 32<rt>
      else 48<rt>
    rhlp.MemEffOprSize <- oprSize
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// EdVdqIb
type SzDDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 32<rt>

/// MdqVdq VdqHdqUdq VdqHdqWdqIb VdqMdq VdqUdq VdqWdq VdqWdqIb WdqVdq
type SzDqDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// VdqWdqd VdqMd VdqHdqWdqd VdqWdqdIb MdVdq VdqHdqUdqdIb
type SzDqdDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// WdqdVdq MdVdq
type SzDqdDqMR () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 32<rt>

/// VdqWdqq VdqMq VdqHdqMq VdqHdqWdqq VdqWdqqIb WdqqVdq MqVdq
type SzDqqDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// WdqqVdq MqVdq
type SzDqqDqMR () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 64<rt>

/// VxWxq
type SzXqX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (64<rt>, effAddrSz, 128<rt>)
      | 256<rt> -> struct (vLen, effAddrSz, vLen)
      | _ -> Utils.futureFeature () (* EVEX *)
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// BNBNdqq BNdqqBN
type SzDqqDqWS () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    let struct (mopr, maddr, mreg) =
      match rhlp.WordSize with
      | WordSize.Bit32 -> struct (64<rt>, effAddrSz, 128<rt>)
      | WordSize.Bit64 -> struct (128<rt>, effAddrSz, 128<rt>)
      | _ -> raise ParsingFailureException
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- effOprSz

/// BNEv BNMv BNMib VdqEy VssHssEy VsdHsdEy
type SzVyDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// EyVdq MibBN
type SzVyDqMR () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- effOprSz

/// RyCd RyDd CdRy DdRy
type SzDY () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    let effRegSz = WordSize.toRegType rhlp.WordSize
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effRegSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// VdqQpi VdqNq
type SzQDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// PpiWdqq
type SzDqqQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// PpiWdq PqUdq
type SzDqQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// GyWdqd
type SzDqdY () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// GyWdqq
type SzDqqY () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// GyUdq
type SzDqY () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// UdqIb Mdq
type SzDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// PqQd
type SzDQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// PqQq PqQqIb QqPq MqPq
type SzQQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// EyPq
type SzYQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- effOprSz

/// PqEy
type SzYQRM () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// PqEdwIb
type SzDwQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// VdqEdwIb VdqHdqEdwIb
type SzDwDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- effOprSz

/// EdwVdqIb
type SzDwDqMR () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 16<rt>

/// GdNqIb GdNq
type SzQD () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- 32<rt>
    rhlp.OperationSize <- 32<rt>

/// GdUdqIb GdUdq
type SzDqd () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 32<rt>
    rhlp.OperationSize <- 32<rt>

/// VxHxWdq
type SzXDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VdqWx
type SzDqX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- vLen
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- vLen
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- vLen

/// GdUx
type SzXD () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- vLen
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- vLen
    rhlp.RegSize <- 32<rt>
    rhlp.OperationSize <- 32<rt>

/// VxWdqqdq
type SzDqqdqX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (64<rt>, effAddrSz, 128<rt>)
      | 256<rt> -> struct (128<rt>, effAddrSz, 128<rt>)
      | _ -> Utils.futureFeature () (* EVEX *)
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VxWdqdq
type SzDqddqX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (32<rt>, effAddrSz, 128<rt>)
      | 256<rt> -> struct (64<rt>, effAddrSz, 128<rt>)
      | _ -> Utils.futureFeature () (* EVEX *)
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VdqWdqw
type SzDqwDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// VxWdqw
type SzDqwX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 16<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VqqMdq VqqHqqWdqIb
type SzDqQqq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 256<rt>
    rhlp.OperationSize <- 256<rt>

/// VxWdqb
type SzDqbX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 8<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VdqEdbIb VdqHdqEdbIb
type SzDbDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 8<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// GvEb Mb
type SzBV () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 8<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 8<rt>
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// NqIb Mq
type SzQ () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- 64<rt>
    rhlp.OperationSize <- 64<rt>

/// Ms
type SzS () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effOprSz = if rhlp.WordSize = WordSize.Bit32 then 48<rt> else 80<rt>
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// VxMd
type SzDX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VZxzWdqd VxHxWdqd
type SzDqdXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VxHxWdqq
type SzDqqX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// Ap Ep Mp
type SzP () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    let struct (regSz, oprSz) =
      if effOprSz = 16<rt> then struct (16<rt>, 32<rt>)
      elif effOprSz = 32<rt> then struct (32<rt>, 48<rt>)
      else struct (64<rt>, 80<rt>)
    rhlp.MemEffOprSize <- oprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- regSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- oprSz

/// GvMp
type SzPRM () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    let struct (regSz, oprSz) =
      if effOprSz = 16<rt> then struct (16<rt>, 32<rt>)
      elif effOprSz = 32<rt> then struct (32<rt>, 48<rt>)
      else struct (64<rt>, 80<rt>)
    rhlp.MemEffOprSize <- oprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- regSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

/// VZxzWxq
type SzXqXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (64<rt>, effAddrSz, 128<rt>)
      | 256<rt> -> struct (128<rt>, effAddrSz, 128<rt>)
      | 512<rt> -> struct (256<rt>, effAddrSz, 256<rt>)
      | _ -> raise ParsingFailureException
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VZxzWx
type SzXXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (vLen, effAddrSz, vLen)
      | 256<rt> -> struct (128<rt>, effAddrSz, 128<rt>)
      | 512<rt> -> struct (256<rt>, effAddrSz, 256<rt>)
      | _ -> raise ParsingFailureException
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VxWZxz
type SzXzX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let regSize =
      match vLen with
      | 128<rt> -> vLen
      | 256<rt> -> 128<rt>
      | 512<rt> -> 256<rt>
      | _ -> raise ParsingFailureException
    rhlp.MemEffOprSize <- vLen
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- vLen
    rhlp.RegSize <- regSize
    rhlp.OperationSize <- regSize

/// VZxzHxWZxz VZxzHxWZxzIb
type SzXzXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- vLen
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- vLen
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VqqWdqq
type SzDqqQq () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 256<rt>
    rhlp.OperationSize <- 256<rt>

/// VZxzWdqq
type SzDqqXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// WqqVZxz WZqqVZxzIb WqqVZxzIb VqqHqqWqq
type SzQqXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 256<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 256<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- 256<rt>

/// VZxzHxWqqIb
type SzQqXzRM () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 256<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 256<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VxWdqd
type SzDqdX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VZxzRd
type SzDXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 32<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 32<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// VZxzRq
type SzQXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 64<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 64<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// WdqVqqIb
type SzDqQq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- 256<rt>
    rhlp.OperationSize <- 128<rt>

/// WdqVZxzIb
type SzDqXz () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    rhlp.MemEffOprSize <- 128<rt>
    rhlp.MemEffAddrSize <- getEffAddrSize rhlp
    rhlp.MemEffRegSize <- 128<rt>
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- 128<rt>

/// VdqHdqEyIb
type SzYDq () =
  inherit InsSizeComputer ()
  override __.Render rhlp szCond =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = getEffOprSize rhlp szCond
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- 128<rt>
    rhlp.OperationSize <- 128<rt>

/// VdqHdqEyIb
type SzQq () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    rhlp.MemEffOprSize <- 256<rt>
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- 256<rt>
    rhlp.RegSize <- 256<rt>
    rhlp.OperationSize <- 256<rt>

/// VxWdqwd
type SzDqwdX () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let vLen = (Option.get rhlp.VEXInfo).VectorLength
    let struct (mopr, maddr, mreg) =
      match vLen with
      | 128<rt> -> struct (16<rt>, effAddrSz, 128<rt>)
      | 256<rt> -> struct (32<rt>, effAddrSz, 128<rt>)
      | _ -> Utils.futureFeature () (* EVEX *)
    rhlp.MemEffOprSize <- mopr
    rhlp.MemEffAddrSize <- maddr
    rhlp.MemEffRegSize <- mreg
    rhlp.RegSize <- vLen
    rhlp.OperationSize <- vLen

/// EyGy - WordSize
type SzY () =
  inherit InsSizeComputer ()
  override __.Render rhlp _ =
    let effAddrSz = getEffAddrSize rhlp
    let effOprSz = if rhlp.WordSize = WordSize.Bit64 then 64<rt> else 32<rt>
    rhlp.MemEffOprSize <- effOprSz
    rhlp.MemEffAddrSize <- effAddrSz
    rhlp.MemEffRegSize <- effOprSz
    rhlp.RegSize <- effOprSz
    rhlp.OperationSize <- effOprSz

type SizeKind =
  | Byte = 0
  | Word = 1
  | Def = 2
  | VecDef = 3
  | DV = 4
  | D = 5
  | MemW = 6
  | RegW = 7
  | WV = 8
  | D64 = 9
  | PZ = 10
  | DDq = 11
  | DqDq = 12
  | DqdDq = 13
  | DqdDqMR = 14
  | DqqDq = 15
  | DqqDqMR = 16
  | XqX = 17
  | DqqDqWS = 18
  | VyDq = 19
  | VyDqMR = 20
  | DY = 21
  | QDq = 22
  | DqqQ = 23
  | DqQ = 24
  | DqdY = 25
  | DqqY = 26
  | DqY = 27
  | Dq = 28
  | DQ = 29
  | QQ = 30
  | YQ = 31
  | YQRM = 32
  | DwQ = 33
  | DwDq = 34
  | DwDqMR = 35
  | QD = 36
  | Dqd = 37
  | XDq = 38
  | DqX = 39
  | XD = 40
  | DqqdqX = 41
  | DqddqX = 42
  | DqwDq = 43
  | DqwX = 44
  | DqQqq = 45
  | DqbX = 46
  | DbDq = 47
  | BV = 48
  | Q = 49
  | S = 50
  | DX = 51
  | DqdXz = 52
  | DqqX = 53
  | P = 54
  | PRM = 55
  | XqXz = 56
  | XXz = 57
  | XzX = 58
  | XzXz = 59
  | DqqQq = 60
  | DqqXz = 61
  | QqXz = 62
  | QqXzRM = 63
  | DqdX = 64
  | DXz = 65
  | QXz = 66
  | DqQq = 67
  | DqXz = 68
  | YDq = 69
  | Qq = 70
  | DqwdX = 71
  | Y = 72

// vim: set tw=80 sts=2 sw=2:

IntelInstruction.fs
//这个模块定义了x86/x64体系结构指令的内部表示格式IntelInternalInstruction,以及它的各种接口方法。
//主要功能点:
//1. 定义IntelInternalInstruction类型,保存指令基本信息。
//2. 实现ILiftable指令接口,提供翻译、反汇编等操作。 
//3. 判断指令类型,如是否是分支、直接跳转指令等。
//4. 提供即时值、目标地址、中断号等访问方法。
//5. 实现ICacheable指令接口,对指令产生中间代码列表缓存。
//6. 定义虚方法Translate实现具体翻译逻辑。
//7. 定义虚方法Disasm实现反汇编字符串生成。
//8. 作为输入,给上层指令模块提供统一的调用接口。
//所以它定义了x86指令的公共抽象,给上层提供类型安全的调用接口。
//与具体指令模块配合,实现从机器码到中间语言的连续翻译。
//是Intel体系结构前端关键模块之一。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.FrontEnd.BinLifter

module private Dummy =
  let helper = DisasmHelper ()

/// The internal representation for an Intel instruction used by our
/// disassembler and lifter.
type IntelInstruction
  (addr, len, wordSz, pref, rex, vex, opcode, oprs, opsz, psz) =
  inherit IntelInternalInstruction
    (addr, len, wordSz, pref, rex, vex, opcode, oprs, opsz, psz)

  override __.IsBranch () =
    Helper.isBranch opcode

  override __.IsModeChanging () = false

  member __.HasConcJmpTarget () =
    match oprs with
    | OneOperand (OprDirAddr _) -> true
    | _ -> false

  override __.IsDirectBranch () =
    __.IsBranch () && __.HasConcJmpTarget ()

  override __.IsIndirectBranch () =
    __.IsBranch () && (not <| __.HasConcJmpTarget ())

  override __.IsCondBranch () =
    match opcode with
    | Opcode.JA | Opcode.JB | Opcode.JBE | Opcode.JCXZ | Opcode.JECXZ
    | Opcode.JG | Opcode.JL | Opcode.JLE | Opcode.JNB | Opcode.JNL | Opcode.JNO
    | Opcode.JNP | Opcode.JNS | Opcode.JNZ | Opcode.JO | Opcode.JP
    | Opcode.JRCXZ | Opcode.JS | Opcode.JZ | Opcode.LOOP | Opcode.LOOPE
    | Opcode.LOOPNE -> true
    | _ -> false

  override __.IsCJmpOnTrue () =
    __.IsCondBranch ()
    && match opcode with
       | Opcode.JA | Opcode.JB | Opcode.JBE | Opcode.JCXZ | Opcode.JECXZ
       | Opcode.JG | Opcode.JL | Opcode.JLE | Opcode.JO | Opcode.JP
       | Opcode.JRCXZ | Opcode.JS | Opcode.JZ | Opcode.LOOP | Opcode.LOOPE ->
         true
       | _ -> false

  override __.IsCall () =
    match opcode with
    | Opcode.CALLFar | Opcode.CALLNear -> true
    | _ -> false

  override __.IsRET () =
    match opcode with
    | Opcode.RETFar | Opcode.RETFarImm | Opcode.RETNear | Opcode.RETNearImm ->
      true
    | _ -> false

  override __.IsInterrupt () =
    match opcode with
    | Opcode.INT | Opcode.INT3 | Opcode.INTO | Opcode.SYSCALL | Opcode.SYSENTER
      -> true
    | _ -> false

  override __.IsExit () =
    match opcode with
    (* In kernel code, HLT is often preceded by CLI to shut down the machine.
       In user code, compilers insert HLT to raise a fault and exit. *)
    | Opcode.HLT
    | Opcode.UD2
    | Opcode.SYSEXIT | Opcode.SYSRET
    | Opcode.IRET | Opcode.IRETW | Opcode.IRETD | Opcode.IRETQ -> true
    | _ -> false

  override __.IsBBLEnd () =
       __.IsBranch ()
    || __.IsInterrupt ()
    || __.IsExit ()

  override __.DirectBranchTarget (addr: byref<Addr>) =
    if __.IsBranch () then
      match oprs with
      | OneOperand (OprDirAddr (Absolute (_))) -> Utils.futureFeature ()
      | OneOperand (OprDirAddr (Relative offset)) ->
        addr <- (int64 __.Address + offset) |> uint64
        true
      | _ -> false
    else false

  override __.IndirectTrampolineAddr (addr: byref<Addr>) =
    if __.IsIndirectBranch () then
      match oprs with
      | OneOperand (OprMem (None, None, Some disp, _)) ->
        addr <- uint64 disp; true
      | OneOperand (OprMem (Some Register.RIP, None, Some disp, _)) ->
        addr <- __.Address + uint64 __.Length + uint64 disp
        true
      | _ -> false
    else false

  override __.Immediate (v: byref<int64>) =
    match oprs with
    | OneOperand (OprImm (c, _))
    | TwoOperands (OprImm (c, _), _)
    | TwoOperands (_, OprImm (c, _))
    | ThreeOperands (OprImm (c, _), _, _)
    | ThreeOperands (_, OprImm (c, _), _)
    | ThreeOperands (_, _, OprImm (c, _))
    | FourOperands (OprImm (c, _), _, _, _)
    | FourOperands (_, OprImm (c, _), _, _)
    | FourOperands (_, _, OprImm (c, _), _)
    | FourOperands (_, _, _, OprImm (c, _)) -> v <- c; true
    | _ -> false

  member private __.AddBranchTargetIfExist addrs =
    match __.DirectBranchTarget () |> Utils.tupleToOpt with
    | None -> addrs
    | Some target ->
      Seq.singleton (target, ArchOperationMode.NoMode) |> Seq.append addrs

  override __.GetNextInstrAddrs () =
    let acc =
      Seq.singleton (__.Address + uint64 __.Length, ArchOperationMode.NoMode)
    if __.IsCall () then acc |> __.AddBranchTargetIfExist
    elif __.IsDirectBranch () || __.IsIndirectBranch () then
      if __.IsCondBranch () then acc |> __.AddBranchTargetIfExist
      else __.AddBranchTargetIfExist Seq.empty
    elif opcode = Opcode.HLT then Seq.empty
    elif opcode = Opcode.UD2 then Seq.empty
    else acc

  override __.InterruptNum (num: byref<int64>) =
    if opcode = Opcode.INT then
      match oprs with
      | OneOperand (OprImm (n, _)) ->
        num <- n
        true
      | _ -> false
    else false

  override __.IsNop () =
    opcode = Opcode.NOP

  override __.Translate ctxt =
    (Lifter.translate __ len ctxt).ToStmts ()

  override __.TranslateToList ctxt =
    Lifter.translate __ len ctxt

  override __.Disasm (showAddr, resolveSymb, disasmHelper) =
    let builder = DisasmStringBuilder (showAddr, resolveSymb, wordSz, addr, len)
    Disasm.disasm disasmHelper __ builder
    builder.Finalize ()

  override __.Disasm () =
    let builder = DisasmStringBuilder (false, false, wordSz, addr, len)
    Disasm.disasm Dummy.helper __ builder
    builder.Finalize ()

  override __.Decompose (showAddr) =
    let builder = DisasmWordBuilder (showAddr, false, wordSz, addr, len, 8)
    Disasm.disasm Dummy.helper __ builder
    builder.Finalize ()

  override __.IsInlinedAssembly () = false

  interface ICacheableOperation<TranslationContext, BinIR.LowUIR.Stmt []> with
    member __.Perform ctxt = (Lifter.translate __ len ctxt).ToStmts ()

// vim: set tw=80 sts=2 sw=2:

IntelLifter.fs
//这个模块实现了x86/x64通用指令集和MMX/SSE/AVX精细集指令的翻译入口。
//主要功能:
//1. 定义Opcode枚举类型。
//2. 根据Opcode选择对应的指令翻译函数。
//3. 调用具体翻译函数将指令翻译成IR。
//4.不支持的指令直接填充为不可达代码。
//翻译流程:
//1. 通过Opcode匹配到具体指令。
//2. 调用匹配指令翻译函数。 
//3. 指令函数进一步分发指令细节翻译。
//4. 返回翻译后的中间代码。
//它提供了从机器码Opcode到翻译函数的映射入口。
//通过Opcode路由到不同模块的具体指令实现。
//与各个指令模块配合,完成整个x86指令集翻译。
//形成了自上向下的翻译框架,实现指令翻译统一接口。
//是Intel体系结构翻译的重要 coordinator 模块。

module internal B2R2.FrontEnd.BinLifter.Intel.Lifter

open B2R2
open B2R2.BinIR

type OP = Opcode (* Just to make it concise. *)

/// Translate IR.
let translate (ins: IntelInternalInstruction) insLen ctxt =
  match ins.Opcode with
  | OP.AAA -> GeneralLifter.aaa insLen ctxt
  | OP.AAD -> GeneralLifter.aad ins insLen ctxt
  | OP.AAM -> GeneralLifter.aam ins insLen ctxt
  | OP.AAS -> GeneralLifter.aas insLen ctxt
  | OP.ADC -> GeneralLifter.adc ins insLen ctxt
  | OP.ADD -> GeneralLifter.add ins insLen ctxt
  | OP.AND -> GeneralLifter.``and`` ins insLen ctxt
  | OP.ANDN -> GeneralLifter.andn ins insLen ctxt
  | OP.ARPL -> GeneralLifter.arpl ins insLen ctxt
  | OP.BNDMOV -> GeneralLifter.bndmov ins insLen ctxt
  | OP.BOUND -> GeneralLifter.nop insLen
  | OP.BSF -> GeneralLifter.bsf ins insLen ctxt
  | OP.BSR -> GeneralLifter.bsr ins insLen ctxt
  | OP.BSWAP -> GeneralLifter.bswap ins insLen ctxt
  | OP.BT -> GeneralLifter.bt ins insLen ctxt
  | OP.BTC -> GeneralLifter.btc ins insLen ctxt
  | OP.BTR -> GeneralLifter.btr ins insLen ctxt
  | OP.BTS -> GeneralLifter.bts ins insLen ctxt
  | OP.CALLNear -> GeneralLifter.call ins insLen ctxt
  | OP.CALLFar -> LiftingUtils.sideEffects insLen UnsupportedFAR
  | OP.CBW | OP.CWDE | OP.CDQE ->
    GeneralLifter.convBWQ ins insLen ctxt
  | OP.CLC -> GeneralLifter.clearFlag insLen ctxt R.CF
  | OP.CLD -> GeneralLifter.clearFlag insLen ctxt R.DF
  | OP.CLI -> GeneralLifter.clearFlag insLen ctxt R.IF
  | OP.CLRSSBSY -> GeneralLifter.nop insLen
  | OP.CLTS -> LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.CMC -> GeneralLifter.cmc ins insLen ctxt
  | OP.CMOVO | OP.CMOVNO | OP.CMOVB | OP.CMOVAE
  | OP.CMOVZ | OP.CMOVNZ | OP.CMOVBE | OP.CMOVA
  | OP.CMOVS  | OP.CMOVNS | OP.CMOVP | OP.CMOVNP
  | OP.CMOVL | OP.CMOVGE | OP.CMOVLE | OP.CMOVG ->
    GeneralLifter.cmovcc ins insLen ctxt
  | OP.CMP -> GeneralLifter.cmp ins insLen ctxt
  | OP.CMPSB | OP.CMPSW | OP.CMPSQ ->
    GeneralLifter.cmps ins insLen ctxt
  | OP.CMPXCHG -> GeneralLifter.cmpxchg ins insLen ctxt
  | OP.CMPXCHG8B | OP.CMPXCHG16B ->
    GeneralLifter.compareExchangeBytes ins insLen ctxt
  | OP.CPUID -> LiftingUtils.sideEffects insLen ProcessorID
  | OP.CRC32 -> GeneralLifter.nop insLen
  | OP.CWD | OP.CDQ | OP.CQO ->
    GeneralLifter.convWDQ ins insLen ctxt
  | OP.DAA -> GeneralLifter.daa insLen ctxt
  | OP.DAS -> GeneralLifter.das insLen ctxt
  | OP.DEC -> GeneralLifter.dec ins insLen ctxt
  | OP.DIV | OP.IDIV -> GeneralLifter.div ins insLen ctxt
  | OP.ENDBR32 | OP.ENDBR64 -> GeneralLifter.nop insLen
  | OP.ENTER -> GeneralLifter.enter ins insLen ctxt
  | OP.HLT -> LiftingUtils.sideEffects insLen Delay
  | OP.IMUL -> GeneralLifter.imul ins insLen ctxt
  | OP.INC -> GeneralLifter.inc ins insLen ctxt
  | OP.INCSSPD | OP.INCSSPQ -> GeneralLifter.nop insLen
  | OP.INSB | OP.INSW | OP.INSD ->
    GeneralLifter.insinstr ins insLen ctxt
  | OP.INT | OP.INTO -> GeneralLifter.interrupt ins insLen ctxt
  | OP.INT3 -> LiftingUtils.sideEffects insLen Breakpoint
  | OP.JMPFar | OP.JMPNear -> GeneralLifter.jmp ins insLen ctxt
  | OP.JO | OP.JNO | OP.JB | OP.JNB
  | OP.JZ | OP.JNZ | OP.JBE | OP.JA
  | OP.JS | OP.JNS | OP.JP | OP.JNP
  | OP.JL | OP.JNL | OP.JLE | OP.JG
  | OP.JECXZ | OP.JRCXZ -> GeneralLifter.jcc ins insLen ctxt
  | OP.LAHF -> LiftingUtils.sideEffects insLen ProcessorID
  | OP.LEA -> GeneralLifter.lea ins insLen ctxt
  | OP.LEAVE -> GeneralLifter.leave ins insLen ctxt
  | OP.LODSB | OP.LODSW | OP.LODSD | OP.LODSQ ->
    GeneralLifter.lods ins insLen ctxt
  | OP.LOOP | OP.LOOPE | OP.LOOPNE ->
    GeneralLifter.loop ins insLen ctxt
  | OP.LZCNT -> GeneralLifter.lzcnt ins insLen ctxt
  | OP.LDS | OP.LES | OP.LFS | OP.LGS | OP.LSS ->
    LiftingUtils.sideEffects insLen UnsupportedFAR
  | OP.MOV -> GeneralLifter.mov ins insLen ctxt
  | OP.MOVBE -> GeneralLifter.movbe ins insLen ctxt
  | OP.MOVSB | OP.MOVSW | OP.MOVSQ ->
    GeneralLifter.movs ins insLen ctxt
  | OP.MOVSX | OP.MOVSXD -> GeneralLifter.movsx ins insLen ctxt
  | OP.MOVZX -> GeneralLifter.movzx ins insLen ctxt
  | OP.MUL -> GeneralLifter.mul ins insLen ctxt
  | OP.NEG -> GeneralLifter.neg ins insLen ctxt
  | OP.NOP -> GeneralLifter.nop insLen
  | OP.NOT -> GeneralLifter.not ins insLen ctxt
  | OP.OR -> GeneralLifter.logOr ins insLen ctxt
  | OP.OUTSB | OP.OUTSW | OP.OUTSD ->
    GeneralLifter.outs ins insLen ctxt
  | OP.POP -> GeneralLifter.pop ins insLen ctxt
  | OP.POPA -> GeneralLifter.popa insLen ctxt 16<rt>
  | OP.POPAD -> GeneralLifter.popa insLen ctxt 32<rt>
  | OP.POPCNT -> GeneralLifter.popcnt ins insLen ctxt
  | OP.POPF | OP.POPFD | OP.POPFQ ->
    GeneralLifter.popf ins insLen ctxt
  | OP.PUSH -> GeneralLifter.push ins insLen ctxt
  | OP.PUSHA -> GeneralLifter.pusha ins insLen ctxt 16<rt>
  | OP.PUSHAD -> GeneralLifter.pusha ins insLen ctxt 32<rt>
  | OP.PUSHF | OP.PUSHFD | OP.PUSHFQ ->
    GeneralLifter.pushf ins insLen ctxt
  | OP.RCL -> GeneralLifter.rcl ins insLen ctxt
  | OP.RCR -> GeneralLifter.rcr ins insLen ctxt
  | OP.RDMSR | OP.RSM ->
    LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.RDPKRU -> GeneralLifter.rdpkru ins insLen ctxt
  | OP.RDPMC -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.RDRAND -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.RDSSPD | OP.RDSSPQ -> GeneralLifter.nop insLen
  | OP.RDTSC -> LiftingUtils.sideEffects insLen ClockCounter
  | OP.RDTSCP -> LiftingUtils.sideEffects insLen ClockCounter
  | OP.RETNear -> GeneralLifter.ret ins insLen ctxt
  | OP.RETNearImm -> GeneralLifter.retWithImm ins insLen ctxt
  | OP.RETFar -> LiftingUtils.sideEffects insLen UnsupportedFAR
  | OP.RETFarImm -> LiftingUtils.sideEffects insLen UnsupportedFAR
  | OP.ROL -> GeneralLifter.rol ins insLen ctxt
  | OP.ROR -> GeneralLifter.ror ins insLen ctxt
  | OP.RORX -> GeneralLifter.rorx ins insLen ctxt
  | OP.RSTORSSP -> GeneralLifter.nop insLen
  | OP.SAHF -> GeneralLifter.sahf ins insLen ctxt
  | OP.SAR | OP.SHR | OP.SHL ->
    GeneralLifter.shift ins insLen ctxt
  | OP.SAVEPREVSSP -> GeneralLifter.nop insLen
  | OP.SBB -> GeneralLifter.sbb ins insLen ctxt
  | OP.SCASB | OP.SCASW | OP.SCASD | OP.SCASQ ->
    GeneralLifter.scas ins insLen ctxt
  | OP.SETO | OP.SETNO | OP.SETB | OP.SETNB
  | OP.SETZ | OP.SETNZ | OP.SETBE | OP.SETA
  | OP.SETS | OP.SETNS | OP.SETP | OP.SETNP
  | OP.SETL | OP.SETNL | OP.SETLE | OP.SETG ->
    GeneralLifter.setcc ins insLen ctxt
  | OP.SETSSBSY -> GeneralLifter.nop insLen
  | OP.SHLD -> GeneralLifter.shld ins insLen ctxt
  | OP.SHLX -> GeneralLifter.shlx ins insLen ctxt
  | OP.SHRD -> GeneralLifter.shrd ins insLen ctxt
  | OP.STC -> GeneralLifter.stc insLen ctxt
  | OP.STD -> GeneralLifter.std insLen ctxt
  | OP.STI -> GeneralLifter.sti insLen ctxt
  | OP.STOSB | OP.STOSW | OP.STOSD | OP.STOSQ ->
    GeneralLifter.stos ins insLen ctxt
  | OP.SUB -> GeneralLifter.sub ins insLen ctxt
  | OP.SYSCALL | OP.SYSENTER -> LiftingUtils.sideEffects insLen SysCall
  | OP.SYSEXIT | OP.SYSRET ->
    LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.TEST -> GeneralLifter.test ins insLen ctxt
  | OP.TZCNT -> GeneralLifter.tzcnt ins insLen ctxt
  | OP.UD2 -> LiftingUtils.sideEffects insLen UndefinedInstr
  | OP.WBINVD -> LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.WRFSBASE -> GeneralLifter.wrfsbase ins insLen ctxt
  | OP.WRGSBASE -> GeneralLifter.wrgsbase ins insLen ctxt
  | OP.WRPKRU -> GeneralLifter.wrpkru ins insLen ctxt
  | OP.WRMSR -> LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.WRSSD | OP.WRSSQ -> GeneralLifter.nop insLen
  | OP.WRUSSD | OP.WRUSSQ -> GeneralLifter.nop insLen
  | OP.XABORT -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.XADD -> GeneralLifter.xadd ins insLen ctxt
  | OP.XBEGIN -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.XCHG -> GeneralLifter.xchg ins insLen ctxt
  | OP.XEND -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.XGETBV -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.XLATB -> GeneralLifter.xlatb ins insLen ctxt
  | OP.XOR -> GeneralLifter.xor ins insLen ctxt
  | OP.XRSTOR | OP.XRSTORS | OP.XSAVE | OP.XSAVEC
  | OP.XSAVEC64 | OP.XSAVEOPT | OP.XSAVES | OP.XSAVES64 ->
    LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.XTEST -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.IN | OP.INVD | OP.INVLPG | OP.IRET | OP.IRETQ | OP.IRETW | OP.IRETD
  | OP.LAR | OP.LGDT | OP.LIDT | OP.LLDT
  | OP.LMSW | OP.LSL | OP.LTR | OP.OUT | OP.SGDT
  | OP.SIDT | OP.SLDT | OP.SMSW | OP.STR | OP.VERR ->
    LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.MOVD -> MMXLifter.movd ins insLen ctxt
  | OP.MOVQ -> MMXLifter.movq ins insLen ctxt
  | OP.PACKSSDW -> MMXLifter.packssdw ins insLen ctxt
  | OP.PACKSSWB -> MMXLifter.packsswb ins insLen ctxt
  | OP.PACKUSWB -> MMXLifter.packuswb ins insLen ctxt
  | OP.PUNPCKHBW -> MMXLifter.punpckhbw ins insLen ctxt
  | OP.PUNPCKHWD -> MMXLifter.punpckhwd ins insLen ctxt
  | OP.PUNPCKHDQ -> MMXLifter.punpckhdq ins insLen ctxt
  | OP.PUNPCKLBW -> MMXLifter.punpcklbw ins insLen ctxt
  | OP.PUNPCKLWD -> MMXLifter.punpcklwd ins insLen ctxt
  | OP.PUNPCKLDQ -> MMXLifter.punpckldq ins insLen ctxt
  | OP.PADDB -> MMXLifter.paddb ins insLen ctxt
  | OP.PADDW -> MMXLifter.paddw ins insLen ctxt
  | OP.PADDD -> MMXLifter.paddd ins insLen ctxt
  | OP.PADDSB -> MMXLifter.paddsb ins insLen ctxt
  | OP.PADDSW -> MMXLifter.paddsw ins insLen ctxt
  | OP.PADDUSB -> MMXLifter.paddusb ins insLen ctxt
  | OP.PADDUSW -> MMXLifter.paddusw ins insLen ctxt
  | OP.PSUBB -> MMXLifter.psubb ins insLen ctxt
  | OP.PSUBW -> MMXLifter.psubw ins insLen ctxt
  | OP.PSUBD -> MMXLifter.psubd ins insLen ctxt
  | OP.PSUBSB -> MMXLifter.psubsb ins insLen ctxt
  | OP.PSUBSW -> MMXLifter.psubsw ins insLen ctxt
  | OP.PSUBUSB -> MMXLifter.psubusb ins insLen ctxt
  | OP.PSUBUSW -> MMXLifter.psubusw ins insLen ctxt
  | OP.PMULHW -> MMXLifter.pmulhw ins insLen ctxt
  | OP.PMULLW -> MMXLifter.pmullw ins insLen ctxt
  | OP.PMADDWD -> MMXLifter.pmaddwd ins insLen ctxt
  | OP.PCMPEQB -> MMXLifter.pcmpeqb ins insLen ctxt
  | OP.PCMPEQW -> MMXLifter.pcmpeqw ins insLen ctxt
  | OP.PCMPEQD -> MMXLifter.pcmpeqd ins insLen ctxt
  | OP.PCMPGTB -> MMXLifter.pcmpgtb ins insLen ctxt
  | OP.PCMPGTW -> MMXLifter.pcmpgtw ins insLen ctxt
  | OP.PCMPGTD -> MMXLifter.pcmpgtd ins insLen ctxt
  | OP.PAND -> MMXLifter.pand ins insLen ctxt
  | OP.PANDN -> MMXLifter.pandn ins insLen ctxt
  | OP.POR -> MMXLifter.por ins insLen ctxt
  | OP.PXOR -> MMXLifter.pxor ins insLen ctxt
  | OP.PSLLW -> MMXLifter.psllw ins insLen ctxt
  | OP.PSLLD -> MMXLifter.pslld ins insLen ctxt
  | OP.PSLLQ -> MMXLifter.psllq ins insLen ctxt
  | OP.PSRLW -> MMXLifter.psrlw ins insLen ctxt
  | OP.PSRLD -> MMXLifter.psrld ins insLen ctxt
  | OP.PSRLQ -> MMXLifter.psrlq ins insLen ctxt
  | OP.PSRAW -> MMXLifter.psraw ins insLen ctxt
  | OP.PSRAD -> MMXLifter.psrad ins insLen ctxt
  | OP.EMMS -> MMXLifter.emms ins insLen ctxt
  | OP.MOVAPS -> SSELifter.movaps ins insLen ctxt
  | OP.MOVAPD -> SSELifter.movapd ins insLen ctxt (* SSE2 *)
  | OP.MOVUPS -> SSELifter.movups ins insLen ctxt
  | OP.MOVUPD -> SSELifter.movupd ins insLen ctxt (* SSE2 *)
  | OP.MOVHPS -> SSELifter.movhps ins insLen ctxt
  | OP.MOVHPD -> SSELifter.movhpd ins insLen ctxt (* SSE2 *)
  | OP.MOVHLPS -> SSELifter.movhlps ins insLen ctxt
  | OP.MOVLPS -> SSELifter.movlps ins insLen ctxt
  | OP.MOVLPD -> SSELifter.movlpd ins insLen ctxt (* SSE2 *)
  | OP.MOVLHPS -> SSELifter.movlhps ins insLen ctxt
  | OP.MOVMSKPS -> SSELifter.movmskps ins insLen ctxt
  | OP.MOVMSKPD -> SSELifter.movmskpd ins insLen ctxt (* SSE2 *)
  | OP.MOVSS -> SSELifter.movss ins insLen ctxt
  | OP.MOVSD -> SSELifter.movsd ins insLen ctxt (* SSE2 *)
  | OP.ADDPS -> SSELifter.addps ins insLen ctxt
  | OP.ADDPD -> SSELifter.addpd ins insLen ctxt (* SSE2 *)
  | OP.ADDSS -> SSELifter.addss ins insLen ctxt
  | OP.ADDSD -> SSELifter.addsd ins insLen ctxt (* SSE2 *)
  | OP.SUBPS -> SSELifter.subps ins insLen ctxt
  | OP.SUBPD -> SSELifter.subpd ins insLen ctxt (* SSE2 *)
  | OP.SUBSS -> SSELifter.subss ins insLen ctxt
  | OP.SUBSD -> SSELifter.subsd ins insLen ctxt (* SSE2 *)
  | OP.MULPS -> SSELifter.mulps ins insLen ctxt
  | OP.MULPD -> SSELifter.mulpd ins insLen ctxt (* SSE2 *)
  | OP.MULSS -> SSELifter.mulss ins insLen ctxt
  | OP.MULSD -> SSELifter.mulsd ins insLen ctxt (* SSE2 *)
  | OP.DIVPS -> SSELifter.divps ins insLen ctxt
  | OP.DIVPD -> SSELifter.divpd ins insLen ctxt (* SSE2 *)
  | OP.DIVSS -> SSELifter.divss ins insLen ctxt
  | OP.DIVSD -> SSELifter.divsd ins insLen ctxt (* SSE2 *)
  | OP.RCPPS -> SSELifter.rcpps ins insLen ctxt
  | OP.RCPSS -> SSELifter.rcpss ins insLen ctxt
  | OP.SQRTPS -> SSELifter.sqrtps ins insLen ctxt
  | OP.SQRTPD -> SSELifter.sqrtpd ins insLen ctxt (* SSE2 *)
  | OP.SQRTSS -> SSELifter.sqrtss ins insLen ctxt
  | OP.SQRTSD -> SSELifter.sqrtsd ins insLen ctxt (* SSE2 *)
  | OP.RSQRTPS -> SSELifter.rsqrtps ins insLen ctxt
  | OP.RSQRTSS -> SSELifter.rsqrtss ins insLen ctxt
  | OP.MAXPS -> SSELifter.maxps ins insLen ctxt
  | OP.MAXPD -> SSELifter.maxpd ins insLen ctxt (* SSE2 *)
  | OP.MAXSS -> SSELifter.maxss ins insLen ctxt
  | OP.MAXSD -> SSELifter.maxsd ins insLen ctxt (* SSE2 *)
  | OP.MINPS -> SSELifter.minps ins insLen ctxt
  | OP.MINPD -> SSELifter.minpd ins insLen ctxt (* SSE2 *)
  | OP.MINSS -> SSELifter.minss ins insLen ctxt
  | OP.MINSD -> SSELifter.minsd ins insLen ctxt (* SSE2 *)
  | OP.CMPPS -> SSELifter.cmpps ins insLen ctxt
  | OP.CMPPD -> SSELifter.cmppd ins insLen ctxt (* SSE2 *)
  | OP.CMPSS -> SSELifter.cmpss ins insLen ctxt
  | OP.CMPSD -> SSELifter.cmpsd ins insLen ctxt (* SSE2 *)
  | OP.COMISS | OP.VCOMISS ->
    SSELifter.comiss ins insLen ctxt
  | OP.COMISD | OP.VCOMISD -> (* SSE2 *)
    SSELifter.comisd ins insLen ctxt
  | OP.UCOMISS | OP.VUCOMISS ->
    SSELifter.ucomiss ins insLen ctxt
  | OP.UCOMISD | OP.VUCOMISD -> (* SSE2 *)
    SSELifter.ucomisd ins insLen ctxt
  | OP.ANDPS -> SSELifter.andps ins insLen ctxt
  | OP.ANDPD -> SSELifter.andpd ins insLen ctxt (* SSE2 *)
  | OP.ANDNPS -> SSELifter.andnps ins insLen ctxt
  | OP.ANDNPD -> SSELifter.andnpd ins insLen ctxt (* SSE2 *)
  | OP.ORPS -> SSELifter.orps ins insLen ctxt
  | OP.ORPD -> SSELifter.orpd ins insLen ctxt (* SSE2 *)
  | OP.XORPS -> SSELifter.xorps ins insLen ctxt
  | OP.XORPD -> SSELifter.xorpd ins insLen ctxt (* SSE2 *)
  | OP.XSETBV -> LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.SHUFPS -> SSELifter.shufps ins insLen ctxt
  | OP.SHUFPD -> SSELifter.shufpd ins insLen ctxt (* SSE2 *)
  | OP.UNPCKHPS -> SSELifter.unpckhps ins insLen ctxt
  | OP.UNPCKHPD -> SSELifter.unpckhpd ins insLen ctxt (* SSE2 *)
  | OP.UNPCKLPS -> SSELifter.unpcklps ins insLen ctxt
  | OP.UNPCKLPD -> SSELifter.unpcklpd ins insLen ctxt (* SSE2 *)
  | OP.CVTPI2PS -> SSELifter.cvtpi2ps ins insLen ctxt
  | OP.CVTPI2PD -> SSELifter.cvtpi2pd ins insLen ctxt (* SSE2 *)
  | OP.CVTSI2SS -> SSELifter.cvtsi2ss ins insLen ctxt
  | OP.CVTSI2SD -> SSELifter.cvtsi2sd ins insLen ctxt (* SSE2 *)
  | OP.CVTPS2PI -> SSELifter.cvtps2pi ins insLen ctxt true
  | OP.CVTPS2PD -> SSELifter.cvtps2pd ins insLen ctxt (* SSE2 *)
  | OP.CVTPD2PS -> SSELifter.cvtpd2ps ins insLen ctxt (* SSE2 *)
  | OP.CVTPD2PI -> SSELifter.cvtpd2pi ins insLen ctxt true (* SSE2 *)
  | OP.CVTPD2DQ -> SSELifter.cvtpd2dq ins insLen ctxt true (* SSE2 *)
  | OP.CVTTPD2DQ -> SSELifter.cvtpd2dq ins insLen ctxt false (* SSE2 *)
  | OP.CVTDQ2PS -> SSELifter.cvtdq2ps ins insLen ctxt (* SSE2 *)
  | OP.CVTDQ2PD -> SSELifter.cvtdq2pd ins insLen ctxt (* SSE2 *)
  | OP.CVTPS2DQ -> SSELifter.cvtps2dq ins insLen ctxt true (* SSE2 *)
  | OP.CVTTPS2DQ -> SSELifter.cvtps2dq ins insLen ctxt false (* SSE2 *)
  | OP.CVTTPS2PI -> SSELifter.cvtps2pi ins insLen ctxt false
  | OP.CVTTPD2PI -> SSELifter.cvtpd2pi ins insLen ctxt false (* SSE2 *)
  | OP.CVTSS2SI | OP.VCVTSS2SI ->
    SSELifter.cvtss2si ins insLen ctxt true
  | OP.CVTSS2SD -> SSELifter.cvtss2sd ins insLen ctxt (* SSE2 *)
  | OP.CVTSD2SS -> SSELifter.cvtsd2ss ins insLen ctxt (* SSE2 *)
  | OP.CVTSD2SI | OP.VCVTSD2SI -> (* SSE2 *)
    SSELifter.cvtsd2si ins insLen ctxt true
  | OP.CVTTSS2SI | OP.VCVTTSS2SI ->
    SSELifter.cvtss2si ins insLen ctxt false
  | OP.CVTTSD2SI | OP.VCVTTSD2SI -> (* SSE2 *)
    SSELifter.cvtsd2si ins insLen ctxt false
  | OP.LDMXCSR -> SSELifter.ldmxcsr ins insLen ctxt
  | OP.STMXCSR -> SSELifter.stmxcsr ins insLen ctxt
  | OP.PAVGB -> SSELifter.pavgb ins insLen ctxt
  | OP.PAVGW -> SSELifter.pavgw ins insLen ctxt
  | OP.PEXTRW -> SSELifter.pextrw ins insLen ctxt
  | OP.PINSRW -> SSELifter.pinsrw ins insLen ctxt
  | OP.PMAXUB -> SSELifter.pmaxub ins insLen ctxt
  | OP.PMAXSW -> SSELifter.pmaxsw ins insLen ctxt
  | OP.PMAXSB -> SSELifter.pmaxsb ins insLen ctxt (* SSE4 *)
  | OP.PMINUB -> SSELifter.pminub ins insLen ctxt
  | OP.PMINSW -> SSELifter.pminsw ins insLen ctxt
  | OP.PMINUD -> SSELifter.pminud ins insLen ctxt (* SSE4 *)
  | OP.PMINSB -> SSELifter.pminsb ins insLen ctxt (* SSE4 *)
  | OP.PMOVMSKB -> SSELifter.pmovmskb ins insLen ctxt
  | OP.PMULHUW -> SSELifter.pmulhuw ins insLen ctxt
  | OP.PSADBW -> SSELifter.psadbw ins insLen ctxt
  | OP.PSHUFW -> SSELifter.pshufw ins insLen ctxt
  | OP.PSHUFD -> SSELifter.pshufd ins insLen ctxt (* SSE2 *)
  | OP.PSHUFLW -> SSELifter.pshuflw ins insLen ctxt (* SSE2 *)
  | OP.PSHUFHW -> SSELifter.pshufhw ins insLen ctxt (* SSE2 *)
  | OP.PSHUFB -> SSELifter.pshufb ins insLen ctxt (* SSE3 *)
  | OP.MOVDQA -> SSELifter.movdqa ins insLen ctxt (* SSE2 *)
  | OP.MOVDQU -> SSELifter.movdqu ins insLen ctxt (* SSE2 *)
  | OP.MOVQ2DQ -> SSELifter.movq2dq ins insLen ctxt (* SSE2 *)
  | OP.MOVDQ2Q -> SSELifter.movdq2q ins insLen ctxt (* SSE2 *)
  | OP.PMULUDQ -> SSELifter.pmuludq ins insLen ctxt (* SSE2 *)
  | OP.PADDQ -> SSELifter.paddq ins insLen ctxt (* SSE2 *)
  | OP.PSUBQ -> SSELifter.psubq ins insLen ctxt (* SSE2 *)
  | OP.PSLLDQ -> SSELifter.pslldq ins insLen ctxt (* SSE2 *)
  | OP.PSRLDQ -> SSELifter.psrldq ins insLen ctxt (* SSE2 *)
  | OP.PUNPCKHQDQ -> SSELifter.punpckhqdq ins insLen ctxt (* SSE2 *)
  | OP.PUNPCKLQDQ -> SSELifter.punpcklqdq ins insLen ctxt (* SSE2 *)
  | OP.MOVNTQ -> SSELifter.movntq ins insLen ctxt
  | OP.MOVNTPS -> SSELifter.movntps ins insLen ctxt
  | OP.PREFETCHNTA
  | OP.PREFETCHT0 | OP.PREFETCHT1
  | OP.PREFETCHW | OP.PREFETCHT2 -> GeneralLifter.nop insLen
  | OP.SFENCE -> LiftingUtils.sideEffects insLen Fence
  | OP.CLFLUSH -> GeneralLifter.nop insLen (* SSE2 *)
  | OP.LFENCE -> LiftingUtils.sideEffects insLen Fence (* SSE2 *)
  | OP.MFENCE -> LiftingUtils.sideEffects insLen Fence (* SSE2 *)
  | OP.PAUSE -> LiftingUtils.sideEffects insLen Delay (* SSE2 *)
  | OP.MOVNTPD -> SSELifter.movntpd ins insLen ctxt (* SSE2 *)
  | OP.MOVNTDQ -> SSELifter.movntdq ins insLen ctxt (* SSE2 *)
  | OP.MOVNTI -> SSELifter.movnti ins insLen ctxt (* SSE2 *)
  | OP.LDDQU -> SSELifter.lddqu ins insLen ctxt (* SSE3 *)
  | OP.MOVSHDUP -> SSELifter.movshdup ins insLen ctxt (* SSE3 *)
  | OP.MOVSLDUP -> SSELifter.movsldup ins insLen ctxt (* SSE3 *)
  | OP.MOVDDUP -> SSELifter.movddup ins insLen ctxt (* SSE3 *)
  | OP.PALIGNR -> SSELifter.palignr ins insLen ctxt (* SSE3 *)
  | OP.ROUNDSD -> SSELifter.roundsd ins insLen ctxt (* SSE4 *)
  | OP.PINSRB -> SSELifter.pinsrb ins insLen ctxt (* SSE4 *)
  | OP.PTEST -> SSELifter.ptest ins insLen ctxt (* SSE4 *)
  | OP.PCMPEQQ -> SSELifter.pcmpeqq ins insLen ctxt (* SSE4 *)
  | OP.PCMPESTRI | OP.PCMPESTRM | OP.PCMPISTRI | OP.PCMPISTRM ->
    SSELifter.pcmpstr ins insLen ctxt (* SSE4 *)
  | OP.VSQRTPS -> AVXLifter.vsqrtps ins insLen ctxt
  | OP.VSQRTPD -> AVXLifter.vsqrtpd ins insLen ctxt
  | OP.VSQRTSS -> AVXLifter.vsqrtss ins insLen ctxt
  | OP.VSQRTSD -> AVXLifter.vsqrtsd ins insLen ctxt
  | OP.VADDPS -> AVXLifter.vaddps ins insLen ctxt
  | OP.VADDPD -> AVXLifter.vaddpd ins insLen ctxt
  | OP.VADDSS -> AVXLifter.vaddss ins insLen ctxt
  | OP.VADDSD -> AVXLifter.vaddsd ins insLen ctxt
  | OP.VSUBPS -> AVXLifter.vsubps ins insLen ctxt
  | OP.VSUBPD -> AVXLifter.vsubpd ins insLen ctxt
  | OP.VSUBSS -> AVXLifter.vsubss ins insLen ctxt
  | OP.VSUBSD -> AVXLifter.vsubsd ins insLen ctxt
  | OP.VMULPS -> AVXLifter.vmulps ins insLen ctxt
  | OP.VMULPD -> AVXLifter.vmulpd ins insLen ctxt
  | OP.VMULSS -> AVXLifter.vmulss ins insLen ctxt
  | OP.VMULSD -> AVXLifter.vmulsd ins insLen ctxt
  | OP.VDIVPS -> AVXLifter.vdivps ins insLen ctxt
  | OP.VDIVPD -> AVXLifter.vdivpd ins insLen ctxt
  | OP.VDIVSS -> AVXLifter.vdivss ins insLen ctxt
  | OP.VDIVSD -> AVXLifter.vdivsd ins insLen ctxt
  | OP.VCVTSI2SS -> AVXLifter.vcvtsi2ss ins insLen ctxt
  | OP.VCVTSI2SD -> AVXLifter.vcvtsi2sd ins insLen ctxt
  | OP.VCVTSD2SS -> AVXLifter.vcvtsd2ss ins insLen ctxt
  | OP.VCVTSS2SD -> AVXLifter.vcvtss2sd ins insLen ctxt
  | OP.VMOVD -> AVXLifter.vmovd ins insLen ctxt
  | OP.VMOVQ -> AVXLifter.vmovq ins insLen ctxt
  | OP.VMOVAPS -> AVXLifter.vmovdqu ins insLen ctxt
  | OP.VMOVAPD -> AVXLifter.vmovdqu ins insLen ctxt
  | OP.VMOVDQU -> AVXLifter.vmovdqu ins insLen ctxt
  | OP.VMOVDQU16 -> AVXLifter.vmovdqu16 ins insLen ctxt
  | OP.VMOVDQU64 -> AVXLifter.vmovdqu64 ins insLen ctxt
  | OP.VMOVDQA -> AVXLifter.vmovdqa ins insLen ctxt
  | OP.VMOVDQA64 -> AVXLifter.vmovdqa64 ins insLen ctxt
  | OP.VMOVNTDQ -> AVXLifter.vmovntdq ins insLen ctxt
  | OP.VMOVUPS -> AVXLifter.vmovups ins insLen ctxt
  | OP.VMOVUPD -> AVXLifter.vmovupd ins insLen ctxt
  | OP.VMOVDDUP -> AVXLifter.vmovddup ins insLen ctxt
  | OP.VMOVNTPS -> AVXLifter.vmovntps ins insLen ctxt
  | OP.VMOVNTPD -> AVXLifter.vmovntpd ins insLen ctxt
  | OP.VMOVHLPS -> AVXLifter.vmovhlps ins insLen ctxt
  | OP.VMOVHPD | OP.VMOVHPS -> AVXLifter.vmovhpd ins insLen ctxt
  | OP.VMOVLHPS -> AVXLifter.vmovlhps ins insLen ctxt
  | OP.VMOVLPD | OP.VMOVLPS -> AVXLifter.vmovlpd ins insLen ctxt
  | OP.VMOVMSKPD -> AVXLifter.vmovmskpd ins insLen ctxt
  | OP.VMOVMSKPS -> AVXLifter.vmovmskps ins insLen ctxt
  | OP.VMOVSD -> AVXLifter.vmovsd ins insLen ctxt
  | OP.VMOVSHDUP -> AVXLifter.vmovshdup ins insLen ctxt
  | OP.VMOVSLDUP -> AVXLifter.vmovsldup ins insLen ctxt
  | OP.VMOVSS -> AVXLifter.vmovss ins insLen ctxt
  | OP.VANDPS -> AVXLifter.vandps ins insLen ctxt
  | OP.VANDPD -> AVXLifter.vandpd ins insLen ctxt
  | OP.VANDNPS -> AVXLifter.vandnps ins insLen ctxt
  | OP.VANDNPD -> AVXLifter.vandnpd ins insLen ctxt
  | OP.VORPS -> AVXLifter.vorps ins insLen ctxt
  | OP.VORPD -> AVXLifter.vorpd ins insLen ctxt
  | OP.VSHUFI32X4 -> AVXLifter.vshufi32x4 ins insLen ctxt
  | OP.VSHUFPS -> AVXLifter.vshufps ins insLen ctxt
  | OP.VSHUFPD -> AVXLifter.vshufpd ins insLen ctxt
  | OP.VUNPCKHPS -> AVXLifter.vunpckhps ins insLen ctxt
  | OP.VUNPCKHPD -> AVXLifter.vunpckhpd ins insLen ctxt
  | OP.VUNPCKLPS -> AVXLifter.vunpcklps ins insLen ctxt
  | OP.VUNPCKLPD -> AVXLifter.vunpcklpd ins insLen ctxt
  | OP.VXORPS -> AVXLifter.vxorps ins insLen ctxt
  | OP.VXORPD -> AVXLifter.vxorpd ins insLen ctxt
  | OP.VBROADCASTI128 -> AVXLifter.vbroadcasti128 ins insLen ctxt
  | OP.VBROADCASTSS -> AVXLifter.vbroadcastss ins insLen ctxt
  | OP.VEXTRACTF32X8 -> AVXLifter.vextracti32x8 ins insLen ctxt
  | OP.VEXTRACTI64X4 -> AVXLifter.vextracti64x4 ins insLen ctxt
  | OP.VINSERTI128 -> AVXLifter.vinserti128 ins insLen ctxt
  | OP.VMPTRLD -> LiftingUtils.sideEffects insLen UnsupportedExtension
  | OP.VPADDB -> AVXLifter.vpaddb ins insLen ctxt
  | OP.VPADDD -> AVXLifter.vpaddd ins insLen ctxt
  | OP.VPADDQ -> AVXLifter.vpaddq ins insLen ctxt
  | OP.VPALIGNR -> AVXLifter.vpalignr ins insLen ctxt
  | OP.VPAND -> AVXLifter.vpand ins insLen ctxt
  | OP.VPANDN -> AVXLifter.vpandn ins insLen ctxt
  | OP.VPBROADCASTB -> AVXLifter.vpbroadcastb ins insLen ctxt
  | OP.VPBROADCASTD -> AVXLifter.vpbroadcastd ins insLen ctxt
  | OP.VPCMPEQB -> AVXLifter.vpcmpeqb ins insLen ctxt
  | OP.VPCMPEQD -> AVXLifter.vpcmpeqd ins insLen ctxt
  | OP.VPCMPEQQ -> AVXLifter.vpcmpeqq ins insLen ctxt
  | OP.VPCMPESTRI | OP.VPCMPESTRM | OP.VPCMPISTRI
  | OP.VPCMPISTRM -> SSELifter.pcmpstr ins insLen ctxt
  | OP.VPCMPGTB -> AVXLifter.vpcmpgtb ins insLen ctxt
  | OP.VPINSRD -> AVXLifter.vpinsrd ins insLen ctxt
  | OP.VPMINUB -> AVXLifter.vpminub ins insLen ctxt
  | OP.VPMINUD -> AVXLifter.vpminud ins insLen ctxt
  | OP.VPMOVMSKB -> SSELifter.pmovmskb ins insLen ctxt
  | OP.VPMULUDQ -> AVXLifter.vpmuludq ins insLen ctxt
  | OP.VPOR -> AVXLifter.vpor ins insLen ctxt
  | OP.VPSHUFB -> AVXLifter.vpshufb ins insLen ctxt
  | OP.VPSHUFD -> AVXLifter.vpshufd ins insLen ctxt
  | OP.VPSLLD -> AVXLifter.vpslld ins insLen ctxt
  | OP.VPSLLDQ -> AVXLifter.vpslldq ins insLen ctxt
  | OP.VPSLLQ -> AVXLifter.vpsllq ins insLen ctxt
  | OP.VPSRLD -> AVXLifter.vpsrld ins insLen ctxt
  | OP.VPSRLDQ -> AVXLifter.vpsrldq ins insLen ctxt
  | OP.VPSRLQ -> AVXLifter.vpsrlq ins insLen ctxt
  | OP.VPSUBB -> AVXLifter.vpsubb ins insLen ctxt
  | OP.VPTEST -> AVXLifter.vptest ins insLen ctxt
  | OP.VPUNPCKHDQ -> AVXLifter.vpunpckhdq ins insLen ctxt
  | OP.VPUNPCKHQDQ -> AVXLifter.vpunpckhqdq ins insLen ctxt
  | OP.VPUNPCKLDQ -> AVXLifter.vpunpckldq ins insLen ctxt
  | OP.VPUNPCKLQDQ -> AVXLifter.vpunpcklqdq ins insLen ctxt
  | OP.VPXOR -> AVXLifter.vpxor ins insLen ctxt
  | OP.VPXORD -> AVXLifter.vpxord ins insLen ctxt
  | OP.VZEROUPPER -> AVXLifter.vzeroupper ins insLen ctxt
  | OP.VEXTRACTI32X8 -> AVXLifter.vextracti32x8 ins insLen ctxt
  | OP.VERW -> LiftingUtils.sideEffects insLen UnsupportedPrivInstr
  | OP.VFMADD132SD -> AVXLifter.vfmadd132sd ins insLen ctxt
  | OP.VFMADD213SD -> AVXLifter.vfmadd213sd ins insLen ctxt
  | OP.VFMADD231SD -> AVXLifter.vfmadd231sd ins insLen ctxt
  | OP.FLD -> X87Lifter.fld ins insLen ctxt
  | OP.FST -> X87Lifter.ffst ins insLen ctxt false
  | OP.FSTP -> X87Lifter.ffst ins insLen ctxt true
  | OP.FILD -> X87Lifter.fild ins insLen ctxt
  | OP.FIST -> X87Lifter.fist ins insLen ctxt false
  | OP.FISTP -> X87Lifter.fist ins insLen ctxt true
  | OP.FISTTP -> X87Lifter.fisttp ins insLen ctxt (* SSE3 *)
  | OP.FBLD -> X87Lifter.fbld ins insLen ctxt
  | OP.FBSTP -> X87Lifter.fbstp ins insLen ctxt
  | OP.FXCH -> X87Lifter.fxch ins insLen ctxt
  | OP.FCMOVE -> X87Lifter.fcmove ins insLen ctxt
  | OP.FCMOVNE -> X87Lifter.fcmovne ins insLen ctxt
  | OP.FCMOVB -> X87Lifter.fcmovb ins insLen ctxt
  | OP.FCMOVBE -> X87Lifter.fcmovbe ins insLen ctxt
  | OP.FCMOVNB -> X87Lifter.fcmovnb ins insLen ctxt
  | OP.FCMOVNBE -> X87Lifter.fcmovnbe ins insLen ctxt
  | OP.FCMOVU -> X87Lifter.fcmovu ins insLen ctxt
  | OP.FCMOVNU -> X87Lifter.fcmovnu ins insLen ctxt
  | OP.FADD -> X87Lifter.fpuadd ins insLen ctxt false
  | OP.FADDP -> X87Lifter.fpuadd ins insLen ctxt true
  | OP.FIADD -> X87Lifter.fiadd ins insLen ctxt
  | OP.FSUB -> X87Lifter.fpusub ins insLen ctxt false
  | OP.FSUBP -> X87Lifter.fpusub ins insLen ctxt true
  | OP.FISUB -> X87Lifter.fisub ins insLen ctxt
  | OP.FSUBR -> X87Lifter.fsubr ins insLen ctxt false
  | OP.FSUBRP -> X87Lifter.fsubr ins insLen ctxt true
  | OP.FISUBR  -> X87Lifter.fisubr ins insLen ctxt
  | OP.FMUL -> X87Lifter.fpumul ins insLen ctxt false
  | OP.FMULP -> X87Lifter.fpumul ins insLen ctxt true
  | OP.FIMUL -> X87Lifter.fimul ins insLen ctxt
  | OP.FDIV -> X87Lifter.fpudiv ins insLen ctxt false
  | OP.FDIVP -> X87Lifter.fpudiv ins insLen ctxt true
  | OP.FIDIV -> X87Lifter.fidiv ins insLen ctxt
  | OP.FDIVR -> X87Lifter.fdivr ins insLen ctxt false
  | OP.FDIVRP -> X87Lifter.fdivr  ins insLen ctxt true
  | OP.FIDIVR -> X87Lifter.fidivr ins insLen ctxt
  | OP.FPREM -> X87Lifter.fprem ins insLen ctxt false
  | OP.FPREM1 -> X87Lifter.fprem ins insLen ctxt true
  | OP.FABS -> X87Lifter.fabs ins insLen ctxt
  | OP.FCHS -> X87Lifter.fchs ins insLen ctxt
  | OP.FRNDINT -> X87Lifter.frndint ins insLen ctxt
  | OP.FSCALE -> X87Lifter.fscale ins insLen ctxt
  | OP.FSQRT -> X87Lifter.fsqrt ins insLen ctxt
  | OP.FXTRACT -> X87Lifter.fxtract ins insLen ctxt
  | OP.FCOM -> X87Lifter.fcom ins insLen ctxt 0 false
  | OP.FCOMP -> X87Lifter.fcom ins insLen ctxt 1 false
  | OP.FCOMPP -> X87Lifter.fcom ins insLen ctxt 2 false
  | OP.FUCOM -> X87Lifter.fcom ins insLen ctxt 0 true
  | OP.FUCOMP -> X87Lifter.fcom ins insLen ctxt 1 true
  | OP.FUCOMPP -> X87Lifter.fcom ins insLen ctxt 2 true
  | OP.FICOM -> X87Lifter.ficom ins insLen ctxt false
  | OP.FICOMP -> X87Lifter.ficom ins insLen ctxt true
  | OP.FCOMI -> X87Lifter.fcomi ins insLen ctxt false
  | OP.FUCOMI -> X87Lifter.fcomi ins insLen ctxt false
  | OP.FCOMIP -> X87Lifter.fcomi ins insLen ctxt true
  | OP.FUCOMIP -> X87Lifter.fcomi ins insLen ctxt true
  | OP.FTST -> X87Lifter.ftst ins insLen ctxt
  | OP.FXAM -> X87Lifter.fxam ins insLen ctxt
  | OP.FSIN -> X87Lifter.fsin ins insLen ctxt
  | OP.FCOS -> X87Lifter.fcos ins insLen ctxt
  | OP.FSINCOS -> X87Lifter.fsincos ins insLen ctxt
  | OP.FPTAN -> X87Lifter.fptan ins insLen ctxt
  | OP.FPATAN -> X87Lifter.fpatan ins insLen ctxt
  | OP.F2XM1 -> X87Lifter.f2xm1 ins insLen ctxt
  | OP.FYL2X -> X87Lifter.fyl2x ins insLen ctxt
  | OP.FYL2XP1 -> X87Lifter.fyl2xp1 ins insLen ctxt
  | OP.FLD1 -> X87Lifter.fld1 ins insLen ctxt
  | OP.FLDZ -> X87Lifter.fldz ins insLen ctxt
  | OP.FLDPI -> X87Lifter.fldpi ins insLen ctxt
  | OP.FLDL2E -> X87Lifter.fldl2e ins insLen ctxt
  | OP.FLDLN2 -> X87Lifter.fldln2 ins insLen ctxt
  | OP.FLDL2T -> X87Lifter.fldl2t ins insLen ctxt
  | OP.FLDLG2 -> X87Lifter.fldlg2 ins insLen ctxt
  | OP.FINCSTP -> X87Lifter.fincstp ins insLen ctxt
  | OP.FDECSTP -> X87Lifter.fdecstp ins insLen ctxt
  | OP.FFREE -> X87Lifter.ffree ins insLen ctxt
  | OP.FINIT -> X87Lifter.finit ins insLen ctxt
  | OP.FNINIT -> X87Lifter.fninit ins insLen ctxt
  | OP.FCLEX -> X87Lifter.fclex ins insLen ctxt
  | OP.FSTCW -> X87Lifter.fstcw ins insLen ctxt
  | OP.FNSTCW -> X87Lifter.fnstcw ins insLen ctxt
  | OP.FLDCW -> X87Lifter.fldcw ins insLen ctxt
  | OP.FNSTENV -> X87Lifter.fnstenv ins insLen ctxt
  | OP.FLDENV -> X87Lifter.fldenv ins insLen ctxt
  | OP.FNSAVE -> X87Lifter.fnsave ins insLen ctxt
  | OP.FRSTOR -> X87Lifter.frstor ins insLen ctxt
  | OP.FNSTSW -> X87Lifter.fnstsw ins insLen ctxt
  | OP.WAIT -> X87Lifter.wait ins insLen ctxt
  | OP.FNOP -> X87Lifter.fnop ins insLen ctxt
  | OP.FXSAVE | OP.FXSAVE64 -> X87Lifter.fxsave ins insLen ctxt
  | OP.FXRSTOR | OP.FXRSTOR64 -> X87Lifter.fxrstor ins insLen ctxt
  | o ->
#if DEBUG
         eprintfn "%A" o
         eprintfn "%A" ins
#endif
         LiftingUtils.sideEffects insLen UnsupportedExtension
         // raise <| NotImplementedIRException (Disasm.opCodeToString o)

// vim: set tw=80 sts=2 sw=2:

IntelLiftingUtils.fs
//这个模块定义了一些x86/x64体系结构指令翻译过程中的辅助函数。
//主要功能包括:
//1. 通过TranslationContext获取寄存器/伪寄存器表达AST节点。
//2. 根据操作数类型翻译为AST节点。 
//3. 一元/二元/多元操作数翻译封装。
//4. 特殊处理x87 FPU寄存器和标签。
//5. 定义宽度转换、符号扩展等操作的AST实现。
//6. 处理Intel专有的目标操作数赋值逻辑。
//7. 定义读写机器码位置标记边效用的IRBuilder实现。
//通过这些函数,提供了从机器码操作数到中间代码表达的通用接口,给上层指令翻译模块使用。
//它将二进制机器码细节封装,提供类型安全和一致的调用接口,实现从机器码到中间代码的翻译。
//与前端模块配合,完整 bridged 机器码与中间语言之间的差异,实现自下而上的抽象转换。 是Intel体系结构翻译关键模块之一。

module internal B2R2.FrontEnd.BinLifter.Intel.LiftingUtils

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel.Helper

open type BinOpType

let inline ( !. ) (ctxt: TranslationContext) name =
  Register.toRegID name |> ctxt.GetRegVar

let inline getPseudoRegVar (ctxt: TranslationContext) name pos =
  ctxt.GetPseudoRegVar (Register.toRegID name) pos

let numInsLen insLen (ctxt: TranslationContext) = numU32 insLen ctxt.WordBitSize

let numOprSize = function
  | 8<rt> | 16<rt> | 32<rt> | 64<rt> | 128<rt> | 256<rt> | 512<rt> as rt ->
    numI32 (int rt) rt
  | _ -> raise InvalidOperandSizeException

let inline is64bit (ctxt: TranslationContext) = ctxt.WordBitSize = 64<rt>

let is64REXW ctxt (ins: InsInfo) =
  is64bit ctxt && hasREXW ins.REXPrefix

#if DEBUG
let assert32 ctxt =
  if is64bit ctxt then raise InvalidISAException else ()
#endif

let inline getOperationSize (i: InsInfo) = i.MainOperationSize

let inline getEffAddrSz (i: InsInfo) = i.PointerSize

let inline getImmValue imm =
  match imm with
  | OprImm (imm, _) -> imm
  | _ -> raise InvalidOperandException

let private getMemExpr128 expr =
  match expr.E with
  | Load (e, 128<rt>, expr, _) ->
    AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> expr
  | _ -> raise InvalidOperandException

let private getMemExpr256 expr =
  match expr.E with
  | Load (e, 256<rt>, expr, _) ->
    AST.load e 64<rt> (expr .+ numI32 24 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 16 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> expr
  | _ -> raise InvalidOperandException

let private getMemExpr512 expr =
  match expr.E with
  | Load (e, 512<rt>, expr, _) ->
    AST.load e 64<rt> (expr .+ numI32 56 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 48 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 40 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 32 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 24 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 16 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr)),
    AST.load e 64<rt> expr
  | _ -> raise InvalidOperandException

let private getMemExprs expr =
  match expr.E with
  | Load (e, 128<rt>, expr, _) ->
    [ AST.load e 64<rt> expr
      AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr)) ]
  | Load (e, 256<rt>, expr, _) ->
    [ AST.load e 64<rt> expr
      AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 16 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 24 (TypeCheck.typeOf expr)) ]
  | Load (e, 512<rt>, expr, _) ->
    [ AST.load e 64<rt> expr
      AST.load e 64<rt> (expr .+ numI32 8 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 16 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 24 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 32 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 40 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 48 (TypeCheck.typeOf expr))
      AST.load e 64<rt> (expr .+ numI32 56 (TypeCheck.typeOf expr)) ]
  | _ -> raise InvalidOperandException

let getPseudoRegVar128 ctxt r =
  getPseudoRegVar ctxt r 2, getPseudoRegVar ctxt r 1

let getPseudoRegVar256 ctxt r =
  getPseudoRegVar ctxt r 4, getPseudoRegVar ctxt r 3,
  getPseudoRegVar ctxt r 2, getPseudoRegVar ctxt r 1

let getPseudoRegVar512 ctxt r =
  getPseudoRegVar ctxt r 8, getPseudoRegVar ctxt r 7,
  getPseudoRegVar ctxt r 6, getPseudoRegVar ctxt r 5,
  getPseudoRegVar ctxt r 4, getPseudoRegVar ctxt r 3,
  getPseudoRegVar ctxt r 2, getPseudoRegVar ctxt r 1

let private getPseudoRegVars ctxt r =
  match Register.getKind r with
  | Register.Kind.XMM -> [ getPseudoRegVar ctxt r 1; getPseudoRegVar ctxt r 2 ]
  | Register.Kind.YMM -> [ getPseudoRegVar ctxt r 1; getPseudoRegVar ctxt r 2
                           getPseudoRegVar ctxt r 3; getPseudoRegVar ctxt r 4 ]
  | Register.Kind.ZMM -> [ getPseudoRegVar ctxt r 1; getPseudoRegVar ctxt r 2
                           getPseudoRegVar ctxt r 3; getPseudoRegVar ctxt r 4
                           getPseudoRegVar ctxt r 5; getPseudoRegVar ctxt r 6
                           getPseudoRegVar ctxt r 7; getPseudoRegVar ctxt r 8 ]
  | _ -> raise InvalidOperandException

let isSegReg = function
  | Register.CS
  | Register.DS
  | Register.SS
  | Register.ES
  | Register.FS
  | Register.GS -> true
  | _ -> false

let private segRegToBase = function
  | R.CS -> R.CSBase
  | R.DS -> R.DSBase
  | R.ES -> R.ESBase
  | R.FS -> R.FSBase
  | R.GS -> R.GSBase
  | R.SS -> R.SSBase
  | _ -> Utils.impossible ()

let private ldMem (ins: InsInfo) ctxt oprSize e =
  match getSegment ins.Prefixes with
  | Some s -> !.ctxt (segRegToBase s) .+ e
  | None -> e
  |> AST.loadLE oprSize

let private numOfAddrSz (ins: InsInfo) (ctxt: TranslationContext) n =
  let pref = ins.Prefixes
  let sz =
    if ctxt.WordBitSize = 32<rt> then if hasAddrSz pref then 16<rt> else 32<rt>
    else if hasAddrSz pref then 32<rt> else 64<rt>
  numI64 n sz

let inline private sIdx ins ctxt (r, s: Scale) =
  (!.ctxt r) .* (numOfAddrSz ins ctxt (int64 s))

let private transMem ins insLen ctxt b index disp oprSize =
  match b, index, (disp: Disp option) with
  | None, None, Some d ->
    numOfAddrSz ins ctxt d
    |> ldMem ins ctxt oprSize
  | None, Some i, Some d ->
    (sIdx ins ctxt i) .+ (numOfAddrSz ins ctxt d)
    |> ldMem ins ctxt oprSize
  | Some b, None, None ->
    !.ctxt b
    |> ldMem ins ctxt oprSize
  | Some R.RIP, None, Some d -> (* RIP-relative addressing *)
    !.ctxt R.RIP .+ numOfAddrSz ins ctxt (d + int64 (insLen: uint32))
    |> ldMem ins ctxt oprSize
  | Some b, None, Some d ->
    !.ctxt b .+ (numOfAddrSz ins ctxt d)
    |> ldMem ins ctxt oprSize
  | Some b, Some i, None ->
    !.ctxt b .+ (sIdx ins ctxt i)
    |> ldMem ins ctxt oprSize
  | Some b, Some i, Some d ->
    !.ctxt b .+ (sIdx ins ctxt i) .+ (numOfAddrSz ins ctxt d)
    |> ldMem ins ctxt oprSize
  | _, _, _ -> raise InvalidOperandException

let transOprToExpr ins insLen ctxt = function
  | OprReg reg -> !.ctxt reg
  | OprMem (b, index, disp, oprSize) ->
    transMem ins insLen ctxt b index disp oprSize
  | OprImm (imm, _) -> numI64 imm (getOperationSize ins)
  | OprDirAddr (Relative offset) -> numI64 offset ctxt.WordBitSize
  | OprDirAddr (Absolute (_, addr, _)) -> numU64 addr ctxt.WordBitSize
  | _ -> Utils.impossible ()

let transOprToExprVec ins insLen ctxt opr =
  match opr with
  | OprReg r -> getPseudoRegVars ctxt r
  | OprMem (b, index, disp, oprSize) ->
    transMem ins insLen ctxt b index disp oprSize |> getMemExprs
  | OprImm (imm, _) -> [ numI64 imm (getOperationSize ins) ]
  | _ -> raise InvalidOperandException

let transOprToExpr32 ins insLen ctxt opr =
  match opr with
  | OprReg r when Register.toRegType r > 64<rt> ->
    getPseudoRegVar ctxt r 1 |> AST.xtlo 32<rt>
  | OprReg r -> !.ctxt r
  | OprMem (b, index, disp, 32<rt>) ->
    transMem ins insLen ctxt b index disp 32<rt>
  | _ -> raise InvalidOperandException

let transOprToExpr64 ins insLen ctxt opr =
  match opr with
  | OprReg r when Register.toRegType r > 64<rt> -> getPseudoRegVar ctxt r 1
  | OprReg r -> !.ctxt r
  | OprMem (b, index, disp, 64<rt>) ->
    transMem ins insLen ctxt b index disp 64<rt>
  | _ -> raise InvalidOperandException

let transOprToExpr128 ins insLen ctxt opr =
  match opr with
  | OprReg r -> getPseudoRegVar128 ctxt r
  | OprMem (b, index, disp, oprSize) ->
    transMem ins insLen ctxt b index disp oprSize |> getMemExpr128
  | _ -> raise InvalidOperandException

let transOprToExpr256 ins insLen ctxt opr =
  match opr with
  | OprReg r -> getPseudoRegVar256 ctxt r
  | OprMem (b, index, disp, oprSize) ->
    transMem ins insLen ctxt b index disp oprSize |> getMemExpr256
  | _ -> raise InvalidOperandException

let transOprToExpr512 ins insLen ctxt opr =
  match opr with
  | OprReg r -> getPseudoRegVar512 ctxt r
  | OprMem (b, index, disp, oprSize) ->
    transMem ins insLen ctxt b index disp oprSize |> getMemExpr512
  | _ -> raise InvalidOperandException

let transOprToFloat80 ins insLen ctxt opr =
  match opr with
  | OprReg r when Register.toRegType r = 80<rt> -> !.ctxt r
  | OprReg r ->
    !.ctxt r |> AST.cast CastKind.FloatCast 80<rt>
  | OprMem (b, index, disp, 80<rt>) ->
    transMem ins insLen ctxt b index disp 80<rt>
  | OprMem (b, index, disp, len) ->
    transMem ins insLen ctxt b index disp len
    |> AST.cast CastKind.FloatCast 80<rt>
  | _ -> raise InvalidOperandException

/// Return a tuple (jump target expr, is pc-relative?)
let transJumpTargetOpr (ins: InsInfo) pc insLen (ctxt: TranslationContext) =
  match ins.Operands with
  | OneOperand (OprDirAddr (Absolute (_, addr, _))) ->
    struct (numU64 addr ctxt.WordBitSize, false)
  | OneOperand (OprDirAddr (Relative offset)) ->
    let wordSize = ctxt.WordBitSize
    let offset = numI64 offset wordSize |> AST.sext wordSize
    struct (pc .+ offset, true)
  | OneOperand (OprReg reg) -> struct (!.ctxt reg, false)
  | OneOperand (OprMem (b, index, disp, oprSize)) ->
    struct (transMem ins insLen ctxt b index disp oprSize, false)
  | _ -> raise InvalidOperandException

let getTwoOprs (ins: InsInfo) =
  match ins.Operands with
  | TwoOperands (o1, o2) -> struct (o1, o2)
  | _ -> raise InvalidOperandException

let getThreeOprs (ins: InsInfo) =
  match ins.Operands with
  | ThreeOperands (o1, o2, o3) -> struct (o1, o2, o3)
  | _ -> raise InvalidOperandException

let getFourOprs (ins: InsInfo) =
  match ins.Operands with
  | FourOperands (o1, o2, o3, o4) -> struct (o1, o2, o3, o4)
  | _ -> raise InvalidOperandException

let transOneOpr (ins: InsInfo) insLen ctxt =
  match ins.Operands with
  | OneOperand opr -> transOprToExpr ins insLen ctxt opr
  | _ -> raise InvalidOperandException

let transTwoOprs (ins: InsInfo) insLen ctxt =
  match ins.Operands with
  | TwoOperands (o1, o2) ->
    struct (transOprToExpr ins insLen ctxt o1,
            transOprToExpr ins insLen ctxt o2)
  | _ -> raise InvalidOperandException

let transThreeOprs (ins: InsInfo) insLen ctxt =
  match ins.Operands with
  | ThreeOperands (o1, o2, o3) ->
    struct (transOprToExpr ins insLen ctxt o1,
            transOprToExpr ins insLen ctxt o2,
            transOprToExpr ins insLen ctxt o3)
  | _ -> raise InvalidOperandException

/// This is an Intel-specific assignment to a destination operand.
/// Unlike typical assignments, this function performs zero-padding when
/// necessary (See Intel Manual 3.4.1.1).
/// In 64-bit mode, operand size determines the number of valid bits.
/// 64-bit operands generate a 64-bit result in the destination general-purpose
/// register. 32-bit operands generate a 32-bit result, zero-extended to a
/// 64-bit result in the destination general-purpose register. 8-bit and 16-bit
/// operands generate 8-bit or 16-bit result. The upper 56 or 48 bits
/// (respectively) of the destination general-purpose register are not modified.
let dstAssign oprSize dst src =
  match oprSize with
  | 8<rt> | 16<rt> -> dst := src (* No extension for 8- and 16-bit operands *)
  | _ -> let dst = AST.unwrap dst
         let dstOrigSz = dst |> TypeCheck.typeOf
         let oprBitSize = RegType.toBitWidth oprSize
         let dstBitSize = RegType.toBitWidth dstOrigSz
         if dstBitSize > oprBitSize then dst := AST.zext dstOrigSz src
         elif dstBitSize = oprBitSize then dst := src
         else raise InvalidOperandSizeException

/// For x87 FPU Top register or x87 FPU Tag word sections.
let extractDstAssign e1 e2 =
  match e1.E with
  | Extract ({ E = BinOp (BinOpType.SHR, 16<rt>,
    { E = BinOp (BinOpType.AND, 16<rt>,
      ({ E = Var (16<rt>, rId, _, _) } as e1), mask, _) }, amt, _) }, 8<rt>,
        0, _) when int rId = 0x4F (* FSW *) || int rId = 0x50 (* FTW *) ->
    e1 := (e1 .& (AST.not mask)) .| (((AST.zext 16<rt> e2) << amt) .& mask)
  | e -> printfn "%A" e; raise InvalidAssignmentException

let maxNum rt =
  match rt with
  | 8<rt> -> BitVector.maxUInt8
  | 16<rt> -> BitVector.maxUInt16
  | 32<rt> -> BitVector.maxUInt32
  | 64<rt> -> BitVector.maxUInt64
  | _ -> raise InvalidOperandSizeException
  |> AST.num

let castNum newType e =
  match e.E with
  | Num n -> BitVector.cast n newType |> AST.num
  | _ -> raise InvalidOperandException

let getMask oprSize =
  match oprSize with
  | 8<rt> -> numI64 0xffL oprSize
  | 16<rt> -> numI64 0xffffL oprSize
  | 32<rt> -> numI64 0xffffffffL oprSize
  | 64<rt> -> numI64 0xffffffffffffffffL oprSize
  | _ -> raise InvalidOperandSizeException

let sideEffects insLen name =
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (AST.sideEffect name)
  !>ir insLen

IntelMMXLifter.fs
//这个模块实现了MMX/SSE/AVX指令集相关的多媒体指令的翻译逻辑。
//主要功能点:
//1. 定义MMX/SSE/AVX多媒体寄存器和操作的翻译函数。
//2. 实现SIMD操作数多元组的打包/解包函数。
//3. 指令操作数翻译函数,处理向量/标量操作数。
//4. 定义SIMD指令翻译公共函数。
//5. 各个MMX/SSE/AVX多媒体指令的具体实现函数。
//翻译过程:
//1. 解析/翻译操作数获取中间表达式。
//2. 调用具体实现函数,实现SIMD指令语义。
//3. 处理多元组的打包/解包。
//4. 返回翻译后的IRBuilder。
//它给高层提供了MMX/SSE/AVX指令集的统一翻译接口。
//与通用指令集模块结合,完成整体x86指令翻译流程。
//是MMX/SSE/AVX体系结构翻译过程中的重要组成部分。

module internal B2R2.FrontEnd.BinLifter.Intel.MMXLifter

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.LiftingUtils

let private movdRegToReg ctxt r1 r2 ir =
  let tmp = !*ir 32<rt>
  match Register.getKind r1, Register.getKind r2 with
  | Register.Kind.XMM, _ ->
    !!ir (getPseudoRegVar ctxt r1 1 := AST.zext 64<rt> (!.ctxt r2))
    !!ir (getPseudoRegVar ctxt r1 2 := AST.num0 64<rt>)
  | _, Register.Kind.XMM ->
    !!ir (tmp := AST.xtlo 32<rt> (getPseudoRegVar ctxt r2 1))
    !!ir (dstAssign 32<rt> (!.ctxt r1) tmp)
  | Register.Kind.MMX, _ ->
    !!ir (!.ctxt r1 := AST.zext 64<rt> (!.ctxt r2))
  | _, Register.Kind.MMX ->
    !!ir (tmp := AST.xtlo 32<rt> (!.ctxt r2))
    !!ir (dstAssign 32<rt> (!.ctxt r1) tmp)
  | _, _ -> Utils.impossible ()

let private movdRegToMem ctxt dst r ir =
  match Register.getKind r with
  | Register.Kind.XMM ->
    !!ir (dst := AST.xtlo 32<rt> (getPseudoRegVar ctxt r 1))
  | Register.Kind.MMX -> !!ir (dst := AST.xtlo 32<rt> (!.ctxt r))
  | _ -> Utils.impossible ()

let private movdMemToReg ctxt src r ir =
  match Register.getKind r with
  | Register.Kind.XMM ->
    !!ir (getPseudoRegVar ctxt r 1 := AST.zext 64<rt> src)
    !!ir (getPseudoRegVar ctxt r 2 := AST.num0 64<rt>)
  | Register.Kind.MMX -> !!ir (!.ctxt r := AST.zext 64<rt> src)
  | _ -> Utils.impossible ()

let movd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src  with
  | OprReg r1, OprReg r2 -> movdRegToReg ctxt r1 r2 ir
  | OprMem _, OprReg r -> let dst = transOprToExpr ins insLen ctxt dst
                          movdRegToMem ctxt dst r ir
  | OprReg r, OprMem _ -> let src = transOprToExpr ins insLen ctxt src
                          movdMemToReg ctxt src r ir
  | _, _ -> raise InvalidOperandException
  !>ir insLen

let private movqRegToReg ctxt r1 r2 ir =
  match Register.getKind r1, Register.getKind r2 with
  | Register.Kind.XMM, Register.Kind.XMM ->
    !!ir (getPseudoRegVar ctxt r1 1 := getPseudoRegVar ctxt r2 1 )
    !!ir (getPseudoRegVar ctxt r1 2 := AST.num0 64<rt>)
  | Register.Kind.XMM, _ ->
    !!ir (getPseudoRegVar ctxt r1 1 := !.ctxt r2)
    !!ir (getPseudoRegVar ctxt r1 2 := AST.num0 64<rt>)
  | Register.Kind.GP, Register.Kind.XMM ->
    !!ir (!.ctxt r1 := getPseudoRegVar ctxt r2 1)
  | Register.Kind.MMX, Register.Kind.MMX
  | Register.Kind.MMX, Register.Kind.GP
  | Register.Kind.GP, Register.Kind.MMX ->
    !!ir (!.ctxt r1 := !.ctxt r2)
  | _, _ -> Utils.impossible ()

let private movqRegToMem ctxt dst r ir =
  match Register.getKind r with
  | Register.Kind.XMM -> !!ir (dst := getPseudoRegVar ctxt r 1)
  | Register.Kind.MMX -> !!ir (dst := !.ctxt r)
  | _ -> Utils.impossible ()

let private movqMemToReg ctxt src r ir =
  match Register.getKind r with
  | Register.Kind.XMM ->
    !!ir (getPseudoRegVar ctxt r 1 := src)
    !!ir (getPseudoRegVar ctxt r 2 := AST.num0 64<rt>)
  | Register.Kind.MMX -> !!ir (!.ctxt r := src)
  | _ -> Utils.impossible ()

let movq ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src with
  | OprReg r1, OprReg r2 -> movqRegToReg ctxt r1 r2 ir
  | OprMem _, OprReg r -> let dst = transOprToExpr ins insLen ctxt dst
                          movqRegToMem ctxt dst r ir
  | OprReg r, OprMem _ -> let src = transOprToExpr ins insLen ctxt src
                          movqMemToReg ctxt src r ir
  | _, _ -> raise InvalidOperandException
  !>ir insLen

let private saturateSignedDwordToSignedWord expr =
  let checkMin = AST.slt expr (numI32 -32768 32<rt>)
  let checkMax = AST.sgt expr (numI32 32767 32<rt>)
  let minNum = numI32 -32768 16<rt>
  let maxNum = numI32 32767 16<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum (AST.xtlo 16<rt> expr))

let private saturateSignedWordToSignedByte expr =
  let checkMin = AST.slt expr (numI32 -128 16<rt>)
  let checkMax = AST.sgt expr (numI32 127 16<rt>)
  let minNum = numI32 -128 8<rt>
  let maxNum = numI32 127 8<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum (AST.xtlo 8<rt> expr))

let private saturateSignedWordToUnsignedByte expr =
  let checkMin = AST.slt expr (numI32 0 16<rt>)
  let checkMax = AST.sgt expr (numI32 255 16<rt>)
  let minNum = numU32 0u 8<rt>
  let maxNum = numU32 0xffu 8<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum (AST.xtlo 8<rt> expr))

let private saturateToSignedByte expr =
  let checkMin = AST.slt expr (numI32 -128 8<rt>)
  let checkMax = AST.sgt expr (numI32 127 8<rt>)
  let minNum = numI32 -128 8<rt>
  let maxNum = numI32 127 8<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum expr)

let private saturateToSignedWord expr =
  let checkMin = AST.slt expr (numI32 -32768 16<rt>)
  let checkMax = AST.sgt expr (numI32 32767 16<rt>)
  let minNum = numI32 -32768 16<rt>
  let maxNum = numI32 32767 16<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum expr)

let private saturateToUnsignedByte expr =
  let checkMin = AST.lt expr (numU32 0u 8<rt>)
  let checkMax = AST.gt expr (numU32 0xffu 8<rt>)
  let minNum = numU32 0u 8<rt>
  let maxNum = numU32 0xffu 8<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum expr)

let private saturateToUnsignedWord expr =
  let checkMin = AST.lt expr (numU32 0u 16<rt>)
  let checkMax = AST.gt expr (numU32 0xffffu 16<rt>)
  let minNum = numU32 0u 16<rt>
  let maxNum = numU32 0xffu 16<rt>
  AST.ite checkMin minNum (AST.ite checkMax maxNum expr)

let private makeSrc ir packSize packNum src =
  let tSrc = Array.init packNum (fun _ -> !*ir packSize)
  for i in 0 .. packNum - 1 do
    !!ir (tSrc[i] := AST.extract src packSize (i * (int packSize)))
  tSrc

let private buildPackedTwoOprs ins insLen ctxt packSz opFn bufSz dst src =
  let ir = IRBuilder (bufSz)
  let oprSize = getOperationSize ins
  let packNum = oprSize / packSz
  let makeSrc = makeSrc ir packSz
  !<ir insLen
  match oprSize with
  | 64<rt> ->
    let dst = transOprToExpr ins insLen ctxt dst
    let src = transOprToExpr ins insLen ctxt src
    let src1 = makeSrc packNum dst
    let src2 = match src.E with
               | Load (_, rt, _, _) -> makeSrc (rt / packSz) src
               | _ -> makeSrc packNum src
    !!ir (dst := opFn oprSize src1 src2 |> AST.concatArr)
  | 128<rt> ->
    let packNum = packNum / (oprSize / 64<rt>)
    let srcAppend src =
      let src = transOprToExprVec ins insLen ctxt src
      List.map (makeSrc packNum) src |> List.fold Array.append [||]
    let tSrc = opFn oprSize (srcAppend dst) (srcAppend src)
    let dst = transOprToExprVec ins insLen ctxt dst
    let packNum = Array.length tSrc / List.length dst
    let assign idx dst =
      !!ir (dst := Array.sub tSrc (packNum * idx) packNum |> AST.concatArr)
    List.iteri assign dst
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private buildPackedThreeOprs ins iLen ctxt packSz opFn bufSz dst s1 s2 =
  let ir = IRBuilder (bufSz)
  let oprSize = getOperationSize ins
  let packNum = oprSize / packSz
  let makeSrc = makeSrc ir packSz
  !<ir iLen
  match oprSize with
  | 64<rt> ->
    let dst = transOprToExpr ins iLen ctxt dst
    let src1 = transOprToExpr ins iLen ctxt s1
    let src2 = transOprToExpr ins iLen ctxt s2
    let src1 = makeSrc packNum src1
    let src2 = makeSrc packNum src2
    !!ir (dst := opFn oprSize src1 src2 |> AST.concatArr)
  | 128<rt> | 256<rt> ->
    let packNum = packNum / (oprSize / 64<rt>)
    let dst = transOprToExprVec ins iLen ctxt dst
    let srcAppend src =
      let src = transOprToExprVec ins iLen ctxt src
      List.map (makeSrc packNum) src |> List.fold Array.append [||]
    let tSrc = opFn oprSize (srcAppend s1) (srcAppend s2)
    let assign idx dst =
      !!ir (dst := Array.sub tSrc (packNum * idx) packNum |> AST.concatArr)
    List.iteri assign dst
  | _ -> raise InvalidOperandSizeException
  !>ir iLen

let buildPackedInstr (ins: InsInfo) insLen ctxt packSz opFn bufSz =
  match ins.Operands with
  | TwoOperands (o1, o2) ->
    buildPackedTwoOprs ins insLen ctxt packSz opFn bufSz o1 o2
  | ThreeOperands (o1, o2, o3) ->
    buildPackedThreeOprs ins insLen ctxt packSz opFn bufSz o1 o2 o3
  | _ -> raise InvalidOperandException

let private opPackssdw _ src1 src2 =
  Array.append src1 src2 |> Array.map saturateSignedDwordToSignedWord

let packssdw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPackssdw 16

let private opPacksswb _ src1 src2 =
  Array.append src1 src2 |> Array.map saturateSignedWordToSignedByte

let packsswb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPacksswb 16

let private opPackuswb _ src1 src2 =
  Array.append src1 src2 |> Array.map saturateSignedWordToUnsignedByte

let packuswb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPackuswb 16

let private opPunpck oprSize src1 src2 isHigh =
  match oprSize with
  | 64<rt> | 128<rt> ->
    let half = Array.length src1 / 2
    let sPos = if isHigh then half else 0
    let src1 = Array.sub src1 sPos half
    let src2 = Array.sub src2 sPos half
    Array.fold2 (fun acc e1 e2 -> e2 :: e1 :: acc) [] src1 src2
    |> List.rev |> List.toArray
  | 256<rt> ->
    let half = Array.length src1 / 2
    let src1A = Array.sub src1 0 half
    let src1B = Array.sub src1 half half
    let src2A = Array.sub src2 0 half
    let src2B = Array.sub src2 half half
    let half = Array.length src1A / 2
    let sPos = if isHigh then half else 0
    let src1A = Array.sub src1A sPos half
    let src2A = Array.sub src2A sPos half
    let src1B = Array.sub src1B sPos half
    let src2B = Array.sub src2B sPos half
    List.append
      (Array.fold2 (fun acc e1 e2 -> e2 :: e1 :: acc) [] src1B src2B)
      (Array.fold2 (fun acc e1 e2 -> e2 :: e1 :: acc) [] src1A src2A)
    |> List.rev |> List.toArray
  | _ -> raise InvalidOperandSizeException

let opPunpckHigh oprSize src1 src2 = opPunpck oprSize src1 src2 true

let opPunpckLow oprSize src1 src2 = opPunpck oprSize src1 src2 false

let punpckhbw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPunpckHigh 64

let punpckhwd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPunpckHigh 32

let punpckhdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPunpckHigh 16

let punpcklbw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPunpckLow 64

let punpcklwd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPunpckLow 32

let punpckldq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPunpckLow 16

let opP op _ = Array.map2 (op)

let paddb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> (opP (.+)) 8

let paddw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> (opP (.+)) 8

let paddd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> (opP (.+)) 8

let private opPaddsb oprSize src1 src2 =
  (opP (.+)) oprSize src1 src2 |> Array.map saturateToSignedByte

let paddsb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPaddsb 16

let private opPaddsw oprSize src1 src2 =
  (opP (.+)) oprSize src1 src2 |> Array.map saturateToSignedWord

let paddsw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPaddsw 16

let private opPaddusb oprSize src1 src2 =
  (opP (.+)) oprSize src1 src2 |> Array.map saturateToUnsignedByte

let paddusb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPaddusb 16

let private opPaddusw oprSize src1 src2 =
  (opP (.+)) oprSize src1 src2 |> Array.map saturateToUnsignedWord

let paddusw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPaddusw 16

let opPsub _ = Array.map2 (.-)

let psubb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPsub 8

let psubw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsub 8

let psubd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPsub 8

let private opPsubsb oprSize src1 src2 =
  opPsub oprSize src1 src2 |> Array.map saturateToSignedByte

let psubsb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPsubsb 8

let private opPsubsw oprSize src1 src2 =
  opPsub oprSize src1 src2 |> Array.map saturateToSignedWord

let psubsw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsubsw 8

let private opPsubusb oprSize src1 src2 =
  opPsub oprSize src1 src2 |> Array.map saturateToUnsignedByte

let psubusb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPsubusb 8

let private opPsubusw oprSize src1 src2 =
  opPsub oprSize src1 src2 |> Array.map saturateToUnsignedWord

let psubusw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsubusw 8

let opPmul resType extr extSz packSz src1 src2 =
  Array.map2 (fun e1 e2 -> extr extSz e1 .* extr extSz e2) src1 src2
  |> Array.map (resType packSz)

let private opPmulhw _ = opPmul AST.xthi AST.sext 32<rt> 16<rt>

let pmulhw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPmulhw 32

let private opPmullw _ = opPmul AST.xtlo AST.sext 32<rt> 16<rt>

let pmullw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPmullw 32

let private opPmaddwd _ =
  let lowAndSExt expr = AST.xtlo 16<rt> expr |> AST.sext 32<rt>
  let highAndSExt expr = AST.xthi 16<rt> expr |> AST.sext 32<rt>
  let mulLow e1 e2 = lowAndSExt e1 .* lowAndSExt e2
  let mulHigh e1 e2 = highAndSExt e1 .* highAndSExt e2
  let packAdd e1 e2 = mulLow e1 e2 .+ mulHigh e1 e2
  Array.map2 packAdd

let pmaddwd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPmaddwd 16

let opPcmp packSz cmpOp =
  Array.map2 (fun e1 e2 ->
    AST.ite (cmpOp e1 e2) (getMask packSz) (AST.num0 packSz))

let opPcmpeqb _ = opPcmp 8<rt> (==)

let pcmpeqb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPcmpeqb 32

let private opPcmpeqw _ = opPcmp 16<rt> (==)

let pcmpeqw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPcmpeqw 32

let opPcmpeqd _ = opPcmp 32<rt> (==)

let pcmpeqd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPcmpeqd 16

let opPcmpgtb _ = opPcmp 8<rt> AST.sgt

let pcmpgtb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPcmpgtb 32

let private opPcmpgtw _ = opPcmp 16<rt> AST.sgt

let pcmpgtw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPcmpgtw 32

let private opPcmpgtd _ = opPcmp 32<rt> AST.sgt

let pcmpgtd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPcmpgtd 16

let opPand _ = Array.map2 (.&)

let pand ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPand 8

let opPandn _ = Array.map2 (fun e1 e2 -> (AST.not e1) .& e2)

let pandn ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPandn 8

let opPor _ = Array.map2 (.|)

let por ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPor 8

let pxor ins insLen ctxt =
  let ir = IRBuilder (4)
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize with
  | 64<rt> ->
    let struct (dst, src) = transTwoOprs ins insLen ctxt
    !!ir (dst := dst <+> src)
  | 128<rt> ->
    let struct (dst, src) = getTwoOprs ins
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    !!ir (dstA := dstA <+> srcA)
    !!ir (dstB := dstB <+> srcB)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private opShiftPackedDataLogical oprSize packSz shift src1 src2 =
  let count = AST.concatArr src2 |> AST.zext oprSize
  let cond = AST.gt count (numI32 ((int packSz) - 1) oprSize)
  let shifted expr = AST.extract (shift (AST.zext oprSize expr) count) packSz 0
  Array.map (fun e -> AST.ite cond (AST.num0 packSz) (shifted e)) src1

let private opPsllw oprSize = opShiftPackedDataLogical oprSize 16<rt> (<<)

let psllw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsllw 8

let private opPslld oprSize = opShiftPackedDataLogical oprSize 32<rt> (<<)

let pslld ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPslld 8

let private opPsllq oprSize = opShiftPackedDataLogical oprSize 64<rt> (<<)

let psllq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPsllq 8

let private opPsrlw oprSize = opShiftPackedDataLogical oprSize 16<rt> (>>)

let psrlw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsrlw 32

let private opPsrld oprSize = opShiftPackedDataLogical oprSize 32<rt> (>>)

let psrld ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPsrld 16

let private opPsrlq oprSize = opShiftPackedDataLogical oprSize 64<rt> (>>)

let psrlq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPsrlq 8

let private opShiftPackedDataRightArith oprSize packSz src1 src2 =
  let count = AST.concatArr src2 |> AST.zext oprSize
  let cond = AST.gt count (numI32 ((int packSz) - 1) oprSize)
  let count = AST.ite cond (numI32 (int packSz) oprSize) count
  let shifted expr = AST.extract ((AST.sext oprSize expr) ?>> count) packSz 0
  Array.map shifted src1

let private opPsraw oprSize = opShiftPackedDataRightArith oprSize 16<rt>

let psraw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPsraw 32

let private opPsrad oprSize = opShiftPackedDataRightArith oprSize 32<rt>

let psrad ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPsrad 16

let emms _ins insLen ctxt =
  let ir = IRBuilder (4)
  !<ir insLen
  !!ir (!.ctxt R.FTW := maxNum 16<rt>)
  !>ir insLen

IntelOpcodes.fs
//这段代码定义了x86体系结构的操作码(Opcode)类型。
//主要特征和功能如下:
//1. 使用类型别名Opcode来定义操作码。
//2. 枚举了所有常见的x86指令,包括一些扩展指令集如SSE/AVX等。
//3. 每个操作码以其名称来命名,方便阅读和识别。
//4. 目的在于为后续的x86指令解析与处理提供标准的操作码类型。
//5. 这个定义是根据官方文档生成的,保证完整性和一致性。
//6. 还定义了一个无效操作码InvalOP,用于处理未知指令。
//通过这个定义,后续在解码和解读x86二进制码时,就可以直接使用这个Opcode类型来标识各个指令,简化操作与管理。
//同时它也为后续对指令集的扩展奠定基础,只需增加新的枚举项即可支持新指令。
//总体来说,这是一个为x86指令定义标准类型的良好尝试,很好地统一和规范化了操作码,为二进制解析奠定基础。

namespace B2R2.FrontEnd.BinLifter.Intel

/// <summary>
/// Intel opcodes. This type should be generated using
/// <c>scripts/genOpcode.fsx</c> from the `IntelSupportedOpcodes.txt` file.
/// </summary>
type Opcode =
  /// ASCII Adjust After Addition.
  | AAA = 0
  /// ASCII Adjust AX Before Division.
  | AAD = 1
  /// ASCII Adjust AX After Multiply.
  | AAM = 2
  /// ASCII Adjust AL After Subtraction.
  | AAS = 3
  /// Add with Carry.
  | ADC = 4
  /// Unsigned integer add with carry.
  | ADCX = 5
  /// Add.
  | ADD = 6
  /// Add Packed Double-Precision Floating-Point Values.
  | ADDPD = 7
  /// Add Packed Single-Precision Floating-Point Values.
  | ADDPS = 8
  /// Add Scalar Double-Precision Floating-Point Values.
  | ADDSD = 9
  /// Add Scalar Single-Precision Floating-Point Values.
  | ADDSS = 10
  /// Packed Double-FP Add/Subtract.
  | ADDSUBPD = 11
  /// Packed Single-FP Add/Subtract.
  | ADDSUBPS = 12
  /// Unsigned integer add with overflow.
  | ADOX = 13
  /// Perform an AES decryption round using an 128-bit state and a round key.
  | AESDEC = 14
  /// Perform Last Round of an AES Decryption Flow.
  | AESDECLAST = 15
  /// Perform an AES encryption round using an 128-bit state and a round key.
  | AESENC = 16
  /// Perform Last Round of an AES Encryption Flow.
  | AESENCLAST = 17
  /// Perform an inverse mix column transformation primitive.
  | AESIMC = 18
  /// Assist the creation of round keys with a key expansion schedule.
  | AESKEYGENASSIST = 19
  /// Logical AND.
  | AND = 20
  /// Bitwise AND of first source with inverted 2nd source operands.
  | ANDN = 21
  /// Bitwise Logical AND of Packed Double-Precision Floating-Point Values.
  | ANDNPD = 22
  /// Bitwise Logical AND of Packed Single-Precision Floating-Point Values.
  | ANDNPS = 23
  /// Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values.
  | ANDPD = 24
  /// Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values.
  | ANDPS = 25
  /// Adjust RPL Field of Segment Selector.
  | ARPL = 26
  /// Contiguous bitwise extract.
  | BEXTR = 27
  /// Blend Packed Double Precision Floating-Point Values.
  | BLENDPD = 28
  /// Blend Packed Single Precision Floating-Point Values.
  | BLENDPS = 29
  /// Variable Blend Packed Double Precision Floating-Point Values.
  | BLENDVPD = 30
  /// Variable Blend Packed Single Precision Floating-Point Values.
  | BLENDVPS = 31
  /// Extract lowest set bit.
  | BLSI = 32
  /// Set all lower bits below first set bit to 1.
  | BLSMSK = 33
  /// Reset lowest set bit.
  | BLSR = 34
  /// Check the address of a memory reference against a LowerBound.
  | BNDCL = 35
  /// Check Upper Bound.
  | BNDCN = 36
  /// Check Upper Bound.
  | BNDCU = 37
  /// Load Extended Bounds Using Address Translation.
  | BNDLDX = 38
  /// Create a LowerBound and a UpperBound in a register.
  | BNDMK = 39
  /// Move Bounds.
  | BNDMOV = 40
  /// Store bounds using address translation.
  | BNDSTX = 41
  /// Check Array Index Against Bounds.
  | BOUND = 42
  /// Bit Scan Forward.
  | BSF = 43
  /// Bit Scan Reverse.
  | BSR = 44
  /// Byte Swap.
  | BSWAP = 45
  /// Bit Test.
  | BT = 46
  /// Bit Test and Complement.
  | BTC = 47
  /// Bit Test and Reset.
  | BTR = 48
  /// Bit Test and Set.
  | BTS = 49
  /// Zero high bits starting from specified bit position.
  | BZHI = 50
  /// Far call.
  | CALLFar = 51
  /// Near call.
  | CALLNear = 52
  /// Convert Byte to Word.
  | CBW = 53
  /// Convert Doubleword to Quadword.
  | CDQ = 54
  /// Convert Doubleword to Quadword.
  | CDQE = 55
  /// Clear AC Flag in EFLAGS Register.
  | CLAC = 56
  /// Clear Carry Flag.
  | CLC = 57
  /// Clear Direction Flag.
  | CLD = 58
  /// Flush Cache Line.
  | CLFLUSH = 59
  /// Flush Cache Line Optimized.
  | CLFLUSHOPT = 60
  /// Clear Interrupt Flag.
  | CLI = 61
  /// Clear busy bit in a supervisor shadow stack token.
  | CLRSSBSY = 62
  /// Clear Task-Switched Flag in CR0.
  | CLTS = 63
  /// Cache Line Write Back.
  | CLWB = 64
  /// Complement Carry Flag.
  | CMC = 65
  /// Conditional Move (Move if above (CF = 0 and ZF = 0)).
  | CMOVA = 66
  /// Conditional Move (Move if above or equal (CF = 0)).
  | CMOVAE = 67
  /// Conditional Move (Move if below (CF = 1)).
  | CMOVB = 68
  /// Conditional Move (Move if below or equal (CF = 1 or ZF = 1)).
  | CMOVBE = 69
  /// Conditional move if carry.
  | CMOVC = 70
  /// Conditional Move (Move if greater (ZF = 0 and SF = OF)).
  | CMOVG = 71
  /// Conditional Move (Move if greater or equal (SF = OF)).
  | CMOVGE = 72
  /// Conditional Move (Move if less (SF <> OF)).
  | CMOVL = 73
  /// Conditional Move (Move if less or equal (ZF = 1 or SF <> OF)).
  | CMOVLE = 74
  /// Conditional move if not carry.
  | CMOVNC = 75
  /// Conditional Move (Move if not overflow (OF = 0)).
  | CMOVNO = 76
  /// Conditional Move (Move if not parity (PF = 0)).
  | CMOVNP = 77
  /// Conditional Move (Move if not sign (SF = 0)).
  | CMOVNS = 78
  /// Conditional Move (Move if not zero (ZF = 0)).
  | CMOVNZ = 79
  /// Conditional Move (Move if overflow (OF = 1)).
  | CMOVO = 80
  /// Conditional Move (Move if parity (PF = 1)).
  | CMOVP = 81
  /// Conditional Move (Move if sign (SF = 1)).
  | CMOVS = 82
  /// Conditional Move (Move if zero (ZF = 1)).
  | CMOVZ = 83
  /// Compare Two Operands.
  | CMP = 84
  /// Compare packed double-precision floating-point values.
  | CMPPD = 85
  /// Compare packed single-precision floating-point values.
  | CMPPS = 86
  /// Compare String Operands (byte).
  | CMPSB = 87
  /// Compare String Operands (dword) or Compare scalar dbl-precision FP values.
  | CMPSD = 88
  /// Compare String Operands (quadword).
  | CMPSQ = 89
  /// Compare scalar single-precision floating-point values.
  | CMPSS = 90
  /// Compare String Operands (word).
  | CMPSW = 91
  /// Compare and Exchange.
  | CMPXCHG = 92
  /// Compare and Exchange Bytes.
  | CMPXCHG16B = 93
  /// Compare and Exchange Bytes.
  | CMPXCHG8B = 94
  /// Compare Scalar Ordered Double-Precision FP Values and Set EFLAGS.
  | COMISD = 95
  /// Compare Scalar Ordered Single-Precision FP Values and Set EFLAGS.
  | COMISS = 96
  /// CPU Identification.
  | CPUID = 97
  /// Convert Quadword to Octaword.
  | CQO = 98
  /// Accumulate CRC32 Value.
  | CRC32 = 99
  /// Convert Packed Dword Integers to Packed Double-Precision FP Values.
  | CVTDQ2PD = 100
  /// Convert Packed Dword Integers to Packed Single-Precision FP Values.
  | CVTDQ2PS = 101
  /// Convert Packed Double-Precision FP Values to Packed Dword Integers.
  | CVTPD2DQ = 102
  /// Convert Packed Double-Precision FP Values to Packed Dword Integers.
  | CVTPD2PI = 103
  /// Convert Packed Double-Precision FP Values to Packed Single-Precision FP.
  | CVTPD2PS = 104
  /// Convert Packed Dword Integers to Packed Double-Precision FP Values.
  | CVTPI2PD = 105
  /// Convert Packed Dword Integers to Packed Single-Precision FP Values.
  | CVTPI2PS = 106
  /// Convert Packed Single-Precision FP Values to Packed Dword Integers.
  | CVTPS2DQ = 107
  /// Convert Packed Single-Precision FP Values to Packed Double-Precision FP.
  | CVTPS2PD = 108
  /// Convert Packed Single-Precision FP Values to Packed Dword Integers.
  | CVTPS2PI = 109
  /// Convert Scalar Double-Precision FP Value to Integer.
  | CVTSD2SI = 110
  /// Convert Scalar Double-Precision FP Value to Scalar Single-Precision FP.
  | CVTSD2SS = 111
  /// Convert Dword Integer to Scalar Double-Precision FP Value.
  | CVTSI2SD = 112
  /// Convert Dword Integer to Scalar Single-Precision FP Value.
  | CVTSI2SS = 113
  /// Convert Scalar Single-Precision FP Value to Scalar Double-Precision FP.
  | CVTSS2SD = 114
  /// Convert Scalar Single-Precision FP Value to Dword Integer.
  | CVTSS2SI = 115
  /// Convert with Truncation Packed Double-Precision FP Values to Packed Dword.
  | CVTTPD2DQ = 116
  /// Convert with Truncation Packed Double-Precision FP Values to Packed Dword.
  | CVTTPD2PI = 117
  /// Convert with Truncation Packed Single-Precision FP Values to Packed Dword.
  | CVTTPS2DQ = 118
  /// Convert with Truncation Packed Single-Precision FP Values to Packed Dword.
  | CVTTPS2PI = 119
  /// Convert with Truncation Scalar Double-Precision FP Value to Signed.
  | CVTTSD2SI = 120
  /// Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.
  | CVTTSS2SI = 121
  /// Convert Word to Doubleword.
  | CWD = 122
  /// Convert Word to Doubleword.
  | CWDE = 123
  /// Decimal Adjust AL after Addition.
  | DAA = 124
  /// Decimal Adjust AL after Subtraction.
  | DAS = 125
  /// Decrement by 1.
  | DEC = 126
  /// Unsigned Divide.
  | DIV = 127
  /// Divide Packed Double-Precision Floating-Point Values.
  | DIVPD = 128
  /// Divide Packed Single-Precision Floating-Point Values.
  | DIVPS = 129
  /// Divide Scalar Double-Precision Floating-Point Values.
  | DIVSD = 130
  /// Divide Scalar Single-Precision Floating-Point Values.
  | DIVSS = 131
  /// Perform double-precision dot product for up to 2 elements and broadcast.
  | DPPD = 132
  /// Perform single-precision dot products for up to 4 elements and broadcast.
  | DPPS = 133
  /// Empty MMX Technology State.
  | EMMS = 134
  /// Execute an Enclave System Function of Specified Leaf Number.
  | ENCLS = 135
  /// Execute an Enclave User Function of Specified Leaf Number.
  | ENCLU = 136
  /// Terminate an Indirect Branch in 32-bit and Compatibility Mode.
  | ENDBR32 = 137
  /// Terminate an Indirect Branch in 64-bit Mode.
  | ENDBR64 = 138
  /// Make Stack Frame for Procedure Parameters.
  | ENTER = 139
  /// Extract Packed Floating-Point Values.
  | EXTRACTPS = 140
  /// Extract Field from Register.
  | EXTRQ = 141
  /// Compute 2x-1.
  | F2XM1 = 142
  /// Absolute Value.
  | FABS = 143
  /// Add.
  | FADD = 144
  /// Add and pop the register stack.
  | FADDP = 145
  /// Load Binary Coded Decimal.
  | FBLD = 146
  /// Store BCD Integer and Pop.
  | FBSTP = 147
  /// Change Sign.
  | FCHS = 148
  /// Clear Exceptions.
  | FCLEX = 149
  /// Floating-Point Conditional Move (if below (CF = 1)).
  | FCMOVB = 150
  /// Floating-Point Conditional Move (if below or equal (CF = 1 or ZF = 1)).
  | FCMOVBE = 151
  /// Floating-Point Conditional Move (if equal (ZF = 1)).
  | FCMOVE = 152
  /// Floating-Point Conditional Move (if not below (CF = 0)).
  | FCMOVNB = 153
  /// FP Conditional Move (if not below or equal (CF = 0 and ZF = 0)).
  | FCMOVNBE = 154
  /// Floating-Point Conditional Move (if not equal (ZF = 0)).
  | FCMOVNE = 155
  /// Floating-Point Conditional Move (if not unordered (PF = 0)).
  | FCMOVNU = 156
  /// Floating-Point Conditional Move (if unordered (PF = 1)).
  | FCMOVU = 157
  /// Compare Floating Point Values.
  | FCOM = 158
  /// Compare Floating Point Values and Set EFLAGS.
  | FCOMI = 159
  /// Compare Floating Point Values and Set EFLAGS.
  | FCOMIP = 160
  /// Compare Floating Point Values and pop register stack.
  | FCOMP = 161
  /// Compare Floating Point Values and pop register stack twice.
  | FCOMPP = 162
  /// Cosine.
  | FCOS = 163
  /// Decrement Stack-Top Pointer.
  | FDECSTP = 164
  /// Divide.
  | FDIV = 165
  /// Divide and pop the register stack.
  | FDIVP = 166
  /// Reverse Divide.
  | FDIVR = 167
  /// Reverse Divide and pop the register stack.
  | FDIVRP = 168
  /// Free Floating-Point Register.
  | FFREE = 169
  /// Performs FFREE ST(i) and pop stack.
  | FFREEP = 170
  /// Add.
  | FIADD = 171
  /// Compare Integer.
  | FICOM = 172
  /// Compare Integer and pop the register stack.
  | FICOMP = 173
  /// Divide.
  | FIDIV = 174
  /// Reverse Divide.
  | FIDIVR = 175
  /// Load Integer.
  | FILD = 176
  /// Multiply.
  | FIMUL = 177
  /// Increment Stack-Top Pointer.
  | FINCSTP = 178
  /// Initialize Floating-Point Unit.
  | FINIT = 179
  /// Store Integer.
  | FIST = 180
  /// Store Integer and pop the register stack.
  | FISTP = 181
  /// Store Integer with Truncation.
  | FISTTP = 182
  /// Subtract.
  | FISUB = 183
  /// Reverse Subtract.
  | FISUBR = 184
  /// Load Floating Point Value.
  | FLD = 185
  /// Load Constant (Push +1.0 onto the FPU register stack).
  | FLD1 = 186
  /// Load x87 FPU Control Word.
  | FLDCW = 187
  /// Load x87 FPU Environment.
  | FLDENV = 188
  /// Load Constant (Push log2e onto the FPU register stack).
  | FLDL2E = 189
  /// Load Constant (Push log210 onto the FPU register stack).
  | FLDL2T = 190
  /// Load Constant (Push log102 onto the FPU register stack).
  | FLDLG2 = 191
  /// Load Constant (Push loge2 onto the FPU register stack).
  | FLDLN2 = 192
  /// Load Constant (Push Pi onto the FPU register stack).
  | FLDPI = 193
  /// Load Constant (Push +0.0 onto the FPU register stack).
  | FLDZ = 194
  /// Multiply.
  | FMUL = 195
  /// Multiply and pop the register stack.
  | FMULP = 196
  /// Clear FP exception flags without checking for error conditions.
  | FNCLEX = 197
  /// Initialize FPU without checking error conditions.
  | FNINIT = 198
  /// No Operation.
  | FNOP = 199
  /// Save FPU state without checking error conditions.
  | FNSAVE = 200
  /// Store x87 FPU Control Word.
  | FNSTCW = 201
  /// Store FPU environment without checking error conditions.
  | FNSTENV = 202
  /// Store FPU status word without checking error conditions.
  | FNSTSW = 203
  /// Partial Arctangent.
  | FPATAN = 204
  /// Partial Remainder.
  | FPREM = 205
  /// Partial Remainder.
  | FPREM1 = 206
  /// Partial Tangent.
  | FPTAN = 207
  /// Round to Integer.
  | FRNDINT = 208
  /// Restore x87 FPU State.
  | FRSTOR = 209
  /// Store x87 FPU State.
  | FSAVE = 210
  /// Scale.
  | FSCALE = 211
  /// Sine.
  | FSIN = 212
  /// Sine and Cosine.
  | FSINCOS = 213
  /// Square Root.
  | FSQRT = 214
  /// Store Floating Point Value.
  | FST = 215
  /// Store FPU control word after checking error conditions.
  | FSTCW = 216
  /// Store x87 FPU Environment.
  | FSTENV = 217
  /// Store Floating Point Value.
  | FSTP = 218
  /// Store x87 FPU Status Word.
  | FSTSW = 219
  /// Subtract.
  | FSUB = 220
  /// Subtract and pop register stack.
  | FSUBP = 221
  /// Reverse Subtract.
  | FSUBR = 222
  /// Reverse Subtract and pop register stack.
  | FSUBRP = 223
  /// TEST.
  | FTST = 224
  /// Unordered Compare Floating Point Values.
  | FUCOM = 225
  /// Compare Floating Point Values and Set EFLAGS.
  | FUCOMI = 226
  /// Compare Floating Point Values and Set EFLAGS and pop register stack.
  | FUCOMIP = 227
  /// Unordered Compare Floating Point Values.
  | FUCOMP = 228
  /// Unordered Compare Floating Point Values.
  | FUCOMPP = 229
  /// Wait for FPU.
  | FWAIT = 230
  /// Examine ModR/M.
  | FXAM = 231
  /// Exchange Register Contents.
  | FXCH = 232
  /// Restore x87 FPU, MMX, XMM, and MXCSR State.
  | FXRSTOR = 233
  /// Restore x87 FPU, MMX, XMM, and MXCSR State.
  | FXRSTOR64 = 234
  /// Save x87 FPU, MMX Technology, and SSE State.
  | FXSAVE = 235
  /// Save x87 FPU, MMX Technology, and SSE State.
  | FXSAVE64 = 236
  /// Extract Exponent and Significand.
  | FXTRACT = 237
  /// compute y * log2x.
  | FYL2X = 238
  /// compute y * log2(x+1).
  | FYL2XP1 = 239
  /// GETSEC.
  | GETSEC = 240
  /// Galois Field Affine Transformation Inverse.
  | GF2P8AFFINEINVQB = 241
  /// Galois Field Affine Transformation.
  | GF2P8AFFINEQB = 242
  /// Galois Field Multiply Bytes.
  | GF2P8MULB = 243
  /// Packed Double-FP Horizontal Add.
  | HADDPD = 244
  /// Packed Single-FP Horizontal Add.
  | HADDPS = 245
  /// Halt.
  | HLT = 246
  /// Packed Double-FP Horizontal Subtract.
  | HSUBPD = 247
  /// Packed Single-FP Horizontal Subtract.
  | HSUBPS = 248
  /// Signed Divide.
  | IDIV = 249
  /// Signed Multiply.
  | IMUL = 250
  /// Input from Port.
  | IN = 251
  /// Increment by 1.
  | INC = 252
  /// Increment the shadow stack pointer (SSP).
  | INCSSPD = 253
  /// Increment the shadow stack pointer (SSP).
  | INCSSPQ = 254
  /// Input from Port to String.
  | INS = 255
  /// Input from Port to String (byte).
  | INSB = 256
  /// Input from Port to String (doubleword).
  | INSD = 257
  /// Insert Scalar Single-Precision Floating-Point Value.
  | INSERTPS = 258
  /// Inserts Field from a source Register to a destination Register.
  | INSERTQ = 259
  /// Input from Port to String (word).
  | INSW = 260
  /// Call to Interrupt (Interrupt vector specified by immediate byte).
  | INT = 261
  /// Call to Interrupt (Interrupt 3-trap to debugger).
  | INT3 = 262
  /// Call to Interrupt (InteInterrupt 4-if overflow flag is 1).
  | INTO = 263
  /// Invalidate Internal Caches.
  | INVD = 264
  /// Invalidate Translations Derived from EPT.
  | INVEPT = 265
  /// Invalidate TLB Entries.
  | INVLPG = 266
  /// Invalidate Process-Context Identifier.
  | INVPCID = 267
  /// Invalidate Translations Based on VPID.
  | INVVPID = 268
  /// Return from interrupt.
  | IRET = 269
  /// Interrupt return (32-bit operand size).
  | IRETD = 270
  /// Interrupt return (64-bit operand size).
  | IRETQ = 271
  /// Interrupt return (16-bit operand size).
  | IRETW = 272
  /// Jump if Condition Is Met (Jump near if not below, CF = 0).
  | JAE = 273
  | JNC = 273
  | JNB = 273
  /// Jump if Condition Is Met (Jump short if below, CF = 1).
  | JC = 274
  | JNAE = 274
  | JB = 274
  /// Jump if Condition Is Met (Jump short if CX register is 0).
  | JCXZ = 275
  /// Jump if Condition Is Met (Jump short if ECX register is 0).
  | JECXZ = 276
  /// Jump if Condition Is Met (Jump near if not less, SF = OF).
  | JGE = 277
  | JNL = 277
  /// Far jmp.
  | JMPFar = 278
  /// Near jmp.
  | JMPNear = 279
  /// Jump if Condition Is Met (Jump short if below or equal, CF = 1 or ZF).
  | JNA = 280
  | JBE = 280
  /// Jump if Condition Is Met (Jump short if above, CF = 0 and ZF = 0).
  | JNBE = 281
  | JA = 281
  /// Jump if Cond Is Met (Jump short if less or equal, ZF = 1 or SF <> OF).
  | JNG = 282
  | JLE = 282
  /// Jump if Condition Is Met (Jump short if less, SF <> OF).
  | JNGE = 283
  | JL = 283
  /// Jump if Condition Is Met (Jump short if greater, ZF = 0 and SF = OF).
  | JNLE = 284
  | JG = 284
  /// Jump if Condition Is Met (Jump near if not overflow, OF = 0).
  | JNO = 285
  /// Jump if Condition Is Met (Jump near if not sign, SF = 0).
  | JNS = 286
  /// Jump if Condition Is Met (Jump near if not zero, ZF = 0).
  | JNZ = 287
  | JNE = 287
  /// Jump if Condition Is Met (Jump near if overflow, OF = 1).
  | JO = 288
  /// Jump if Condition Is Met (Jump near if parity, PF = 1).
  | JP = 289
  | JPE = 289
  /// Jump if Condition Is Met (Jump near if not parity, PF = 0).
  | JPO = 290
  | JNP = 290
  /// Jump if Condition Is Met (Jump short if RCX register is 0).
  | JRCXZ = 291
  /// Jump if Condition Is Met (Jump short if sign, SF = 1).
  | JS = 292
  /// Jump if Condition Is Met (Jump short if zero, ZF = 1).
  | JZ = 293
  | JE = 293
  /// Add two 8-bit opmasks.
  | KADDB = 294
  /// Add two 32-bit opmasks.
  | KADDD = 295
  /// Add two 64-bit opmasks.
  | KADDQ = 296
  /// Add two 16-bit opmasks.
  | KADDW = 297
  /// Logical AND two 8-bit opmasks.
  | KANDB = 298
  /// Logical AND two 32-bit opmasks.
  | KANDD = 299
  /// Logical AND NOT two 8-bit opmasks.
  | KANDNB = 300
  /// Logical AND NOT two 32-bit opmasks.
  | KANDND = 301
  /// Logical AND NOT two 64-bit opmasks.
  | KANDNQ = 302
  /// Logical AND NOT two 16-bit opmasks.
  | KANDNW = 303
  /// Logical AND two 64-bit opmasks.
  | KANDQ = 304
  /// Logical AND two 16-bit opmasks.
  | KANDW = 305
  /// Move from or move to opmask register of 8-bit data.
  | KMOVB = 306
  /// Move from or move to opmask register of 32-bit data.
  | KMOVD = 307
  /// Move from or move to opmask register of 64-bit data.
  | KMOVQ = 308
  /// Move from or move to opmask register of 16-bit data.
  | KMOVW = 309
  /// Bitwise NOT of two 8-bit opmasks.
  | KNOTB = 310
  /// Bitwise NOT of two 32-bit opmasks.
  | KNOTD = 311
  /// Bitwise NOT of two 64-bit opmasks.
  | KNOTQ = 312
  /// Bitwise NOT of two 16-bit opmasks.
  | KNOTW = 313
  /// Logical OR two 8-bit opmasks.
  | KORB = 314
  /// Logical OR two 32-bit opmasks.
  | KORD = 315
  /// Logical OR two 64-bit opmasks.
  | KORQ = 316
  /// Update EFLAGS according to the result of bitwise OR of two 8-bit opmasks.
  | KORTESTB = 317
  /// Update EFLAGS according to the result of bitwise OR of two 32-bit opmasks.
  | KORTESTD = 318
  /// Update EFLAGS according to the result of bitwise OR of two 64-bit opmasks.
  | KORTESTQ = 319
  /// Update EFLAGS according to the result of bitwise OR of two 16-bit opmasks.
  | KORTESTW = 320
  /// Logical OR two 16-bit opmasks.
  | KORW = 321
  /// Shift left 8-bitopmask by specified count.
  | KSHIFTLB = 322
  /// Shift left 32-bitopmask by specified count.
  | KSHIFTLD = 323
  /// Shift left 64-bitopmask by specified count.
  | KSHIFTLQ = 324
  /// Shift left 16-bitopmask by specified count.
  | KSHIFTLW = 325
  /// Shift right 8-bit opmask by specified count.
  | KSHIFTRB = 326
  /// Shift right 32-bit opmask by specified count.
  | KSHIFTRD = 327
  /// Shift right 64-bit opmask by specified count.
  | KSHIFTRQ = 328
  /// Shift right 16-bit opmask by specified count.
  | KSHIFTRW = 329
  /// Update EFLAGS according to result of bitwise TEST of two 8-bit opmasks.
  | KTESTB = 330
  /// Update EFLAGS according to result of bitwise TEST of two 32-bit opmasks.
  | KTESTD = 331
  /// Update EFLAGS according to result of bitwise TEST of two 64-bit opmasks.
  | KTESTQ = 332
  /// Update EFLAGS according to result of bitwise TEST of two 16-bit opmasks.
  | KTESTW = 333
  /// Unpack and interleave two 8-bit opmasks into 16-bit mask.
  | KUNPCKBW = 334
  /// Unpack and interleave two 32-bit opmasks into 64-bit mask.
  | KUNPCKDQ = 335
  /// Unpack and interleave two 16-bit opmasks into 32-bit mask.
  | KUNPCKWD = 336
  /// Bitwise logical XNOR of two 8-bit opmasks.
  | KXNORB = 337
  /// Bitwise logical XNOR of two 32-bit opmasks.
  | KXNORD = 338
  /// Bitwise logical XNOR of two 64-bit opmasks.
  | KXNORQ = 339
  /// Bitwise logical XNOR of two 16-bit opmasks.
  | KXNORW = 340
  /// Logical XOR of two 8-bit opmasks.
  | KXORB = 341
  /// Logical XOR of two 32-bit opmasks.
  | KXORD = 342
  /// Logical XOR of two 64-bit opmasks.
  | KXORQ = 343
  /// Logical XOR of two 16-bit opmasks.
  | KXORW = 344
  /// Load Status Flags into AH Register.
  | LAHF = 345
  /// Load Access Rights Byte.
  | LAR = 346
  /// Load Unaligned Integer 128 Bits.
  | LDDQU = 347
  /// Load MXCSR Register.
  | LDMXCSR = 348
  /// Load Far Pointer (DS).
  | LDS = 349
  /// Load Effective Address.
  | LEA = 350
  /// High Level Procedure Exit.
  | LEAVE = 351
  /// Load Far Pointer (ES).
  | LES = 352
  /// Load Fence.
  | LFENCE = 353
  /// Load Far Pointer (FS).
  | LFS = 354
  /// Load GlobalDescriptor Table Register.
  | LGDT = 355
  /// Load Far Pointer (GS).
  | LGS = 356
  /// Load Interrupt Descriptor Table Register.
  | LIDT = 357
  /// Load Local Descriptor Table Register.
  | LLDT = 358
  /// Load Machine Status Word.
  | LMSW = 359
  /// Assert LOCK# Signal Prefix.
  | LOCK = 360
  /// Load String (byte).
  | LODSB = 361
  /// Load String (doubleword).
  | LODSD = 362
  /// Load String (quadword).
  | LODSQ = 363
  /// Load String (word).
  | LODSW = 364
  /// Loop According to ECX Counter (count <> 0).
  | LOOP = 365
  /// Loop According to ECX Counter (count <> 0 and ZF = 1).
  | LOOPE = 366
  /// Loop According to ECX Counter (count <> 0 and ZF = 0).
  | LOOPNE = 367
  /// Load Segment Limit.
  | LSL = 368
  /// Load Far Pointer (SS).
  | LSS = 369
  /// Load Task Register.
  | LTR = 370
  /// the Number of Leading Zero Bits.
  | LZCNT = 371
  /// Store Selected Bytes of Double Quadword.
  | MASKMOVDQU = 372
  /// Store Selected Bytes of Quadword.
  | MASKMOVQ = 373
  /// Return Maximum Packed Double-Precision Floating-Point Values.
  | MAXPD = 374
  /// Return Maximum Packed Single-Precision Floating-Point Values.
  | MAXPS = 375
  /// Return Maximum Scalar Double-Precision Floating-Point Values.
  | MAXSD = 376
  /// Return Maximum Scalar Single-Precision Floating-Point Values.
  | MAXSS = 377
  /// Memory Fence.
  | MFENCE = 378
  /// Return Minimum Packed Double-Precision Floating-Point Values.
  | MINPD = 379
  /// Return Minimum Packed Single-Precision Floating-Point Values.
  | MINPS = 380
  /// Return Minimum Scalar Double-Precision Floating-Point Values.
  | MINSD = 381
  /// Return Minimum Scalar Single-Precision Floating-Point Values.
  | MINSS = 382
  /// Set Up Monitor Address.
  | MONITOR = 383
  /// MOV.
  | MOV = 384
  /// Move Aligned Packed Double-Precision Floating-Point Values.
  | MOVAPD = 385
  /// Move Aligned Packed Single-Precision Floating-Point Values.
  | MOVAPS = 386
  /// Move Data After Swapping Bytes.
  | MOVBE = 387
  /// Move Doubleword.
  | MOVD = 388
  /// Move One Double-FP and Duplicate.
  | MOVDDUP = 389
  /// Move Quadword from XMM to MMX Technology Register.
  | MOVDQ2Q = 390
  /// Move Aligned Double Quadword.
  | MOVDQA = 391
  /// Move Unaligned Double Quadword.
  | MOVDQU = 392
  /// Move Packed Single-Precision Floating-Point Values High to Low.
  | MOVHLPS = 393
  /// Move High Packed Double-Precision Floating-Point Value.
  | MOVHPD = 394
  /// Move High Packed Single-Precision Floating-Point Values.
  | MOVHPS = 395
  /// Move Packed Single-Precision Floating-Point Values Low to High.
  | MOVLHPS = 396
  /// Move Low Packed Double-Precision Floating-Point Value.
  | MOVLPD = 397
  /// Move Low Packed Single-Precision Floating-Point Values.
  | MOVLPS = 398
  /// Extract Packed Double-Precision Floating-Point Sign Mask.
  | MOVMSKPD = 399
  /// Extract Packed Single-Precision Floating-Point Sign Mask.
  | MOVMSKPS = 400
  /// Load Double Quadword Non-Temporal Aligned Hint.
  | MOVNTDQ = 401
  /// Load Double Quadword Non-Temporal Aligned Hint.
  | MOVNTDQA = 402
  /// Store Doubleword Using Non-Temporal Hint.
  | MOVNTI = 403
  /// Store Packed Double-Precision FP Values Using Non-Temporal Hint.
  | MOVNTPD = 404
  /// Store Packed Single-Precision FP Values Using Non-Temporal Hint.
  | MOVNTPS = 405
  /// Store of Quadword Using Non-Temporal Hint.
  | MOVNTQ = 406
  /// Move Quadword.
  | MOVQ = 407
  /// Move Quadword from MMX Technology to XMM Register.
  | MOVQ2DQ = 408
  /// Move Data from String to String (byte).
  | MOVSB = 409
  /// Move Data from String to String (doubleword).
  | MOVSD = 410
  /// Move Packed Single-FP High and Duplicate.
  | MOVSHDUP = 411
  /// Move Packed Single-FP Low and Duplicate.
  | MOVSLDUP = 412
  /// Move Data from String to String (quadword).
  | MOVSQ = 413
  /// Move Scalar Single-Precision Floating-Point Values.
  | MOVSS = 414
  /// Move Data from String to String (word).
  | MOVSW = 415
  /// Move with Sign-Extension.
  | MOVSX = 416
  /// Move with Sign-Extension (doubleword to quadword).
  | MOVSXD = 417
  /// Move Unaligned Packed Double-Precision Floating-Point Values.
  | MOVUPD = 418
  /// Move Unaligned Packed Single-Precision Floating-Point Values.
  | MOVUPS = 419
  /// Move with Zero-Extend.
  | MOVZX = 420
  /// Compute Multiple Packed Sums of Absolute Difference.
  | MPSADBW = 421
  /// Unsigned Multiply.
  | MUL = 422
  /// Multiply Packed Double-Precision Floating-Point Values.
  | MULPD = 423
  /// Multiply Packed Single-Precision Floating-Point Values.
  | MULPS = 424
  /// Multiply Scalar Double-Precision Floating-Point Values.
  | MULSD = 425
  /// Multiply Scalar Single-Precision Floating-Point Values.
  | MULSS = 426
  /// Unsigned multiply without affecting arithmetic flags.
  | MULX = 427
  /// Monitor Wait.
  | MWAIT = 428
  /// Two's Complement Negation.
  | NEG = 429
  /// No Operation.
  | NOP = 430
  /// One's Complement Negation.
  | NOT = 431
  /// Logical Inclusive OR.
  | OR = 432
  /// Bitwise Logical OR of Double-Precision Floating-Point Values.
  | ORPD = 433
  /// Bitwise Logical OR of Single-Precision Floating-Point Values.
  | ORPS = 434
  /// Output to Port.
  | OUT = 435
  /// Output String to Port.
  | OUTS = 436
  /// Output String to Port (byte).
  | OUTSB = 437
  /// Output String to Port (doubleword).
  | OUTSD = 438
  /// Output String to Port (word).
  | OUTSW = 439
  /// Computes the absolute value of each signed byte data element.
  | PABSB = 440
  /// Computes the absolute value of each signed 32-bit data element.
  | PABSD = 441
  /// Computes the absolute value of each signed 16-bit data element.
  | PABSW = 442
  /// Pack with Signed Saturation.
  | PACKSSDW = 443
  /// Pack with Signed Saturation.
  | PACKSSWB = 444
  /// Pack with Unsigned Saturation.
  | PACKUSDW = 445
  /// Pack with Unsigned Saturation.
  | PACKUSWB = 446
  /// Add Packed byte Integers.
  | PADDB = 447
  /// Add Packed Doubleword Integers.
  | PADDD = 448
  /// Add Packed Quadword Integers.
  | PADDQ = 449
  /// Add Packed Signed Integers with Signed Saturation (byte).
  | PADDSB = 450
  /// Add Packed Signed Integers with Signed Saturation (word).
  | PADDSW = 451
  /// Add Packed Unsigned Integers with Unsigned Saturation (byte).
  | PADDUSB = 452
  /// Add Packed Unsigned Integers with Unsigned Saturation (word).
  | PADDUSW = 453
  /// Add Packed word Integers.
  | PADDW = 454
  /// Packed Align Right.
  | PALIGNR = 455
  /// Logical AND.
  | PAND = 456
  /// Logical AND NOT.
  | PANDN = 457
  /// Spin Loop Hint.
  | PAUSE = 458
  /// Average Packed Integers (byte).
  | PAVGB = 459
  /// Average Packed Integers (word).
  | PAVGW = 460
  /// Variable Blend Packed Bytes.
  | PBLENDVB = 461
  /// Blend Packed Words.
  | PBLENDW = 462
  /// Perform carryless multiplication of two 64-bit numbers.
  | PCLMULQDQ = 463
  /// Compare Packed Data for Equal (byte).
  | PCMPEQB = 464
  /// Compare Packed Data for Equal (doubleword).
  | PCMPEQD = 465
  /// Compare Packed Data for Equal (quadword).
  | PCMPEQQ = 466
  /// Compare packed words for equal.
  | PCMPEQW = 467
  /// Packed Compare Explicit Length Strings, Return Index.
  | PCMPESTRI = 468
  /// Packed Compare Explicit Length Strings, Return Mask.
  | PCMPESTRM = 469
  /// Compare Packed Signed Integers for Greater Than (byte).
  | PCMPGTB = 470
  /// Compare Packed Signed Integers for Greater Than (doubleword).
  | PCMPGTD = 471
  /// Performs logical compare of greater-than on packed integer quadwords.
  | PCMPGTQ = 472
  /// Compare Packed Signed Integers for Greater Than (word).
  | PCMPGTW = 473
  /// Packed Compare Implicit Length Strings, Return Index.
  | PCMPISTRI = 474
  /// Packed Compare Implicit Length Strings, Return Mask.
  | PCMPISTRM = 475
  /// Parallel deposit of bits using a mask.
  | PDEP = 476
  /// Parallel extraction of bits using a mask.
  | PEXT = 477
  /// Extract Byte.
  | PEXTRB = 478
  /// Extract Dword.
  | PEXTRD = 479
  /// Extract Qword.
  | PEXTRQ = 480
  /// Extract Word.
  | PEXTRW = 481
  /// Packed Horizontal Add.
  | PHADDD = 482
  /// Packed Horizontal Add and Saturate.
  | PHADDSW = 483
  /// Packed Horizontal Add.
  | PHADDW = 484
  /// Packed Horizontal Word Minimum.
  | PHMINPOSUW = 485
  /// Packed Horizontal Subtract.
  | PHSUBD = 486
  /// Packed Horizontal Subtract and Saturate.
  | PHSUBSW = 487
  /// Packed Horizontal Subtract.
  | PHSUBW = 488
  /// Insert Byte.
  | PINSRB = 489
  /// Insert a dword value from 32-bit register or memory into an XMM register.
  | PINSRD = 490
  /// Insert a qword value from 64-bit register or memory into an XMM register.
  | PINSRQ = 491
  /// Insert Word.
  | PINSRW = 492
  /// Multiply and Add Packed Signed and Unsigned Bytes.
  | PMADDUBSW = 493
  /// Multiply and Add Packed Integers.
  | PMADDWD = 494
  /// Compare packed signed byte integers.
  | PMAXSB = 495
  /// Compare packed signed dword integers.
  | PMAXSD = 496
  /// Maximum of Packed Signed Word Integers.
  | PMAXSW = 497
  /// Maximum of Packed Unsigned Byte Integers.
  | PMAXUB = 498
  /// Compare packed unsigned dword integers.
  | PMAXUD = 499
  /// Compare packed unsigned word integers.
  | PMAXUW = 500
  /// Minimum of Packed Signed Byte Integers.
  | PMINSB = 501
  /// Compare packed signed dword integers.
  | PMINSD = 502
  /// Minimum of Packed Signed Word Integers.
  | PMINSW = 503
  /// Minimum of Packed Unsigned Byte Integers.
  | PMINUB = 504
  /// Minimum of Packed Dword Integers.
  | PMINUD = 505
  /// Compare packed unsigned word integers.
  | PMINUW = 506
  /// Move Byte Mask.
  | PMOVMSKB = 507
  /// Packed Move with Sign Extend.
  | PMOVSXBD = 508
  /// Packed Move with Sign Extend.
  | PMOVSXBQ = 509
  /// Packed Move with Sign Extend.
  | PMOVSXBW = 510
  /// Packed Move with Sign Extend.
  | PMOVSXDQ = 511
  /// Packed Move with Sign Extend.
  | PMOVSXWD = 512
  /// Packed Move with Sign Extend.
  | PMOVSXWQ = 513
  /// Packed Move with Zero Extend.
  | PMOVZXBD = 514
  /// Packed Move with Zero Extend.
  | PMOVZXBQ = 515
  /// Packed Move with Zero Extend.
  | PMOVZXBW = 516
  /// Packed Move with Zero Extend.
  | PMOVZXDQ = 517
  /// Packed Move with Zero Extend.
  | PMOVZXWD = 518
  /// Packed Move with Zero Extend.
  | PMOVZXWQ = 519
  /// Multiply Packed Doubleword Integers.
  | PMULDQ = 520
  /// Packed Multiply High with Round and Scale.
  | PMULHRSW = 521
  /// Multiply Packed Unsigned Integers and Store High Result.
  | PMULHUW = 522
  /// Multiply Packed Signed Integers and Store High Result.
  | PMULHW = 523
  /// Multiply Packed Integers and Store Low Result.
  | PMULLD = 524
  /// Multiply Packed Signed Integers and Store Low Result.
  | PMULLW = 525
  /// Multiply Packed Unsigned Doubleword Integers.
  | PMULUDQ = 526
  /// Pop a Value from the Stack.
  | POP = 527
  /// Pop All General-Purpose Registers (word).
  | POPA = 528
  /// Pop All General-Purpose Registers (doubleword).
  | POPAD = 529
  /// Return the Count of Number of Bits Set to 1.
  | POPCNT = 530
  /// Pop Stack into EFLAGS Register (lower 16bits EFLAGS).
  | POPF = 531
  /// Pop Stack into EFLAGS Register (EFLAGS).
  | POPFD = 532
  /// Pop Stack into EFLAGS Register (RFLAGS).
  | POPFQ = 533
  /// Bitwise Logical OR.
  | POR = 534
  /// Prefetch Data Into Caches (using NTA hint).
  | PREFETCHNTA = 535
  /// Prefetch Data Into Caches (using T0 hint).
  | PREFETCHT0 = 536
  /// Prefetch Data Into Caches (using T1 hint).
  | PREFETCHT1 = 537
  /// Prefetch Data Into Caches (using T2 hint).
  | PREFETCHT2 = 538
  /// Prefetch Data into Caches in Anticipation of a Write.
  | PREFETCHW = 539
  /// Prefetch Vector Data Into Caches with Intent to Write and T1 Hint.
  | PREFETCHWT1 = 540
  /// Compute Sum of Absolute Differences.
  | PSADBW = 541
  /// Packed Shuffle Bytes.
  | PSHUFB = 542
  /// Shuffle Packed Doublewords.
  | PSHUFD = 543
  /// Shuffle Packed High Words.
  | PSHUFHW = 544
  /// Shuffle Packed Low Words.
  | PSHUFLW = 545
  /// Shuffle Packed Words.
  | PSHUFW = 546
  /// Packed Sign Byte.
  | PSIGNB = 547
  /// Packed Sign Doubleword.
  | PSIGND = 548
  /// Packed Sign Word.
  | PSIGNW = 549
  /// Shift Packed Data Left Logical (doubleword).
  | PSLLD = 550
  /// Shift Double Quadword Left Logical.
  | PSLLDQ = 551
  /// Shift Packed Data Left Logical (quadword).
  | PSLLQ = 552
  /// Shift Packed Data Left Logical (word).
  | PSLLW = 553
  /// Shift Packed Data Right Arithmetic (doubleword).
  | PSRAD = 554
  /// Shift Packed Data Right Arithmetic (word).
  | PSRAW = 555
  /// Shift Packed Data Right Logical (doubleword).
  | PSRLD = 556
  /// Shift Double Quadword Right Logical.
  | PSRLDQ = 557
  /// Shift Packed Data Right Logical (quadword).
  | PSRLQ = 558
  /// Shift Packed Data Right Logical (word).
  | PSRLW = 559
  /// Subtract Packed Integers (byte).
  | PSUBB = 560
  /// Subtract Packed Integers (doubleword).
  | PSUBD = 561
  /// Subtract Packed Integers (quadword).
  | PSUBQ = 562
  /// Subtract Packed Signed Integers with Signed Saturation (byte).
  | PSUBSB = 563
  /// Subtract Packed Signed Integers with Signed Saturation (word).
  | PSUBSW = 564
  /// Subtract Packed Unsigned Integers with Unsigned Saturation (byte).
  | PSUBUSB = 565
  /// Subtract Packed Unsigned Integers with Unsigned Saturation (word).
  | PSUBUSW = 566
  /// Subtract Packed Integers (word).
  | PSUBW = 567
  /// Logical Compare.
  | PTEST = 568
  /// Unpack High Data.
  | PUNPCKHBW = 569
  /// Unpack High Data.
  | PUNPCKHDQ = 570
  /// Unpack High Data.
  | PUNPCKHQDQ = 571
  /// Unpack High Data.
  | PUNPCKHWD = 572
  /// Unpack Low Data.
  | PUNPCKLBW = 573
  /// Unpack Low Data.
  | PUNPCKLDQ = 574
  /// Unpack Low Data.
  | PUNPCKLQDQ = 575
  /// Unpack Low Data.
  | PUNPCKLWD = 576
  /// Push Word, Doubleword or Quadword Onto the Stack.
  | PUSH = 577
  /// Push All General-Purpose Registers (word).
  | PUSHA = 578
  /// Push All General-Purpose Registers (doubleword).
  | PUSHAD = 579
  /// Push EFLAGS Register onto the Stack (16bits of EFLAGS).
  | PUSHF = 580
  /// Push EFLAGS Register onto the Stack (EFLAGS).
  | PUSHFD = 581
  /// Push EFLAGS Register onto the Stack (RFLAGS).
  | PUSHFQ = 582
  /// Logical Exclusive OR.
  | PXOR = 583
  /// Rotate x bits (CF, r/m(x)) left once.
  | RCL = 584
  /// Compute reciprocals of packed single-precision floating-point values.
  | RCPPS = 585
  /// Compute reciprocal of scalar single-precision floating-point values.
  | RCPSS = 586
  /// Rotate x bits (CF, r/m(x)) right once.
  | RCR = 587
  /// Read FS Segment Base.
  | RDFSBASE = 588
  /// Read GS Segment Base.
  | RDGSBASE = 589
  /// Read from Model Specific Register.
  | RDMSR = 590
  /// Read Protection Key Rights for User Pages.
  | RDPKRU = 591
  /// Read Performance-Monitoring Counters.
  | RDPMC = 592
  /// Read Random Number.
  | RDRAND = 593
  /// Read Random SEED.
  | RDSEED = 594
  /// Read shadow stack point (SSP).
  | RDSSPD = 595
  /// Read shadow stack point (SSP).
  | RDSSPQ = 596
  /// Read Time-Stamp Counter.
  | RDTSC = 597
  /// Read Time-Stamp Counter and Processor ID.
  | RDTSCP = 598
  /// Repeat while ECX not zero.
  | REP = 599
  /// Repeat while equal/Repeat while zero.
  | REPE = 600
  /// Repeat while not equal/Repeat while not zero.
  | REPNE = 601
  /// Repeat while not equal/Repeat while not zero.
  | REPNZ = 602
  /// Repeat while equal/Repeat while zero.
  | REPZ = 603
  /// Far return.
  | RETFar = 604
  /// Far return w/ immediate.
  | RETFarImm = 605
  /// Near return.
  | RETNear = 606
  /// Near return w/ immediate .
  | RETNearImm = 607
  /// Rotate x bits r/m(x) left once.
  | ROL = 608
  /// Rotate x bits r/m(x) right once.
  | ROR = 609
  /// Rotate right without affecting arithmetic flags.
  | RORX = 610
  /// Round Packed Double Precision Floating-Point Values.
  | ROUNDPD = 611
  /// Round Packed Single Precision Floating-Point Values.
  | ROUNDPS = 612
  /// Round Scalar Double Precision Floating-Point Values.
  | ROUNDSD = 613
  /// Round Scalar Single Precision Floating-Point Values.
  | ROUNDSS = 614
  /// Resume from System Management Mode.
  | RSM = 615
  /// Compute reciprocals of square roots of packed single-precision FP values.
  | RSQRTPS = 616
  /// Compute reciprocal of square root of scalar single-precision FP values.
  | RSQRTSS = 617
  /// Restore a shadow stack pointer (SSP).
  | RSTORSSP = 618
  /// Store AH into Flags.
  | SAHF = 619
  /// Shift.
  | SAR = 620
  /// Shift arithmetic right.
  | SARX = 621
  /// Save previous shadow stack pointer (SSP).
  | SAVEPREVSSP = 622
  /// Integer Subtraction with Borrow.
  | SBB = 623
  /// Scan String (byte).
  | SCASB = 624
  /// Scan String (doubleword).
  | SCASD = 625
  /// Scan String (quadword).
  | SCASQ = 626
  /// Scan String (word).
  | SCASW = 627
  /// Set byte if above (CF = 0 and ZF = 0).
  | SETA = 628
  /// Set byte if below (CF = 1).
  | SETB = 629
  /// Set byte if below or equal (CF = 1 or ZF = 1).
  | SETBE = 630
  /// Set byte if greater (ZF = 0 and SF = OF).
  | SETG = 631
  /// Set byte if less (SF <> OF).
  | SETL = 632
  /// Set byte if less or equal (ZF = 1 or SF <> OF).
  | SETLE = 633
  /// Set byte if not below (CF = 0).
  | SETNB = 634
  /// Set byte if not less (SF = OF).
  | SETNL = 635
  /// Set byte if not overflow (OF = 0).
  | SETNO = 636
  /// Set byte if not parity (PF = 0).
  | SETNP = 637
  /// Set byte if not sign (SF = 0).
  | SETNS = 638
  /// Set byte if not zero (ZF = 0).
  | SETNZ = 639
  /// Set byte if overflow (OF = 1).
  | SETO = 640
  /// Set byte if parity (PF = 1).
  | SETP = 641
  /// Set byte if sign (SF = 1).
  | SETS = 642
  /// Set busy bit in a supervisor shadow stack token.
  | SETSSBSY = 643
  /// Set byte if sign (ZF = 1).
  | SETZ = 644
  /// Store Fence.
  | SFENCE = 645
  /// Store Global Descriptor Table Register.
  | SGDT = 646
  /// Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords.
  | SHA1MSG1 = 647
  /// Perform a Final Calculation for the Next Four SHA1 Message Dwords.
  | SHA1MSG2 = 648
  /// Calculate SHA1 state E after four rounds.
  | SHA1NEXTE = 649
  /// Perform four rounds of SHA1 operations.
  | SHA1RNDS4 = 650
  /// Perform an intermediate calculation for the next 4 SHA256 message dwords.
  | SHA256MSG1 = 651
  /// Perform the final calculation for the next four SHA256 message dwords.
  | SHA256MSG2 = 652
  /// Perform two rounds of SHA256 operations.
  | SHA256RNDS2 = 653
  /// Shift.
  | SHL = 654
  /// Double Precision Shift Left.
  | SHLD = 655
  /// Shift logic left.
  | SHLX = 656
  /// Shift.
  | SHR = 657
  /// Double Precision Shift Right.
  | SHRD = 658
  /// Shift logic right.
  | SHRX = 659
  /// Shuffle Packed Double-Precision Floating-Point Values.
  | SHUFPD = 660
  /// Shuffle Packed Single-Precision Floating-Point Values.
  | SHUFPS = 661
  /// Store Interrupt Descriptor Table Register.
  | SIDT = 662
  /// Store Local Descriptor Table Register.
  | SLDT = 663
  /// Store Machine Status Word.
  | SMSW = 664
  /// Compute packed square roots of packed double-precision FP values.
  | SQRTPD = 665
  /// Compute square roots of packed single-precision floating-point values.
  | SQRTPS = 666
  /// Compute scalar square root of scalar double-precision FP values.
  | SQRTSD = 667
  /// Compute square root of scalar single-precision floating-point values.
  | SQRTSS = 668
  /// Set AC Flag in EFLAGS Register.
  | STAC = 669
  /// Set Carry Flag.
  | STC = 670
  /// Set Direction Flag.
  | STD = 671
  /// Set Interrupt Flag.
  | STI = 672
  /// Store MXCSR Register State.
  | STMXCSR = 673
  /// Store String (store AL).
  | STOSB = 674
  /// Store String (store EAX).
  | STOSD = 675
  /// Store String (store RAX).
  | STOSQ = 676
  /// Store String (store AX).
  | STOSW = 677
  /// Store Task Register.
  | STR = 678
  /// Subtract.
  | SUB = 679
  /// Subtract Packed Double-Precision Floating-Point Values.
  | SUBPD = 680
  /// Subtract Packed Single-Precision Floating-Point Values.
  | SUBPS = 681
  /// Subtract Scalar Double-Precision Floating-Point Values.
  | SUBSD = 682
  /// Subtract Scalar Single-Precision Floating-Point Values.
  | SUBSS = 683
  /// Swap GS Base Register.
  | SWAPGS = 684
  /// Fast System Call.
  | SYSCALL = 685
  /// Fast System Call.
  | SYSENTER = 686
  /// Fast Return from Fast System Call.
  | SYSEXIT = 687
  /// Return From Fast System Call.
  | SYSRET = 688
  /// Logical Compare.
  | TEST = 689
  /// Count the Number of Trailing Zero Bits.
  | TZCNT = 690
  /// Unordered Compare Scalar Double-Precision FP Values and Set EFLAGS.
  | UCOMISD = 691
  /// Unordered Compare Scalar Single-Precision FPValues and Set EFLAGS.
  | UCOMISS = 692
  /// Undefined instruction.
  | UD = 693
  /// Undefined Instruction (Raise invalid opcode exception).
  | UD2 = 694
  /// Unpack and Interleave High Packed Double-Precision Floating-Point Values.
  | UNPCKHPD = 695
  /// Unpack and Interleave High Packed Single-Precision Floating-Point Values.
  | UNPCKHPS = 696
  /// Unpack and Interleave Low Packed Double-Precision Floating-Point Values.
  | UNPCKLPD = 697
  /// Unpack and Interleave Low Packed Single-Precision Floating-Point Values.
  | UNPCKLPS = 698
  /// Packed Single-Precision Floating-Point Fused Multiply-Add.
  | V4FMADDPS = 699
  /// Scalar Single-Precision Floating-Point Fused Multiply-Add.
  | V4FMADDSS = 700
  /// Packed Single-Precision Floating-Point Fused Multiply-Add and Negate.
  | V4FNMADDPS = 701
  /// Scalar Single-Precision Floating-Point Fused Multiply-Add and Negate.
  | V4FNMADDSS = 702
  /// Add Packed Double-Precision Floating-Point Values.
  | VADDPD = 703
  /// Add Packed Double-Precision Floating-Point Values.
  | VADDPS = 704
  /// Add Scalar Double-Precision Floating-Point Values.
  | VADDSD = 705
  /// Add Scalar Single-Precision Floating-Point Values.
  | VADDSS = 706
  /// Packed Double-FP Add/Subtract.
  | VADDSUBPD = 707
  /// Packed Single-FP Add/Subtract.
  | VADDSUBPS = 708
  /// Perform One Round of an AES Decryption Flow.
  | VAESDEC = 709
  /// Perform Last Round of an AES Decryption Flow.
  | VAESDECLAST = 710
  /// Perform One Round of an AES Encryption Flow.
  | VAESENC = 711
  /// Perform Last Round of an AES Encryption Flow.
  | VAESENCLAST = 712
  /// Perform dword alignment of two concatenated source vectors.
  | VALIGND = 713
  /// Perform qword alignment of two concatenated source vectors.
  | VALIGNQ = 714
  /// Bitwise Logical AND of Packed Double-Precision Floating-Point Values.
  | VANDNPD = 715
  /// Bitwise Logical AND of Packed Single-Precision Floating-Point Values.
  | VANDNPS = 716
  /// Bitwise Logical AND NOT of Packed Double-Precision Floating-Point Values.
  | VANDPD = 717
  /// Bitwise Logical AND NOT of Packed Single-Precision Floating-Point Values.
  | VANDPS = 718
  /// Replace the VBLENDVPD instructions (using opmask as select control).
  | VBLENDMPD = 719
  /// Replace the VBLENDVPS instructions (using opmask as select control).
  | VBLENDMPS = 720
  /// Blend Packed Double-Precision Floats.
  | VBLENDPD = 721
  /// Blend Packed Single-Precision Floats.
  | VBLENDPS = 722
  /// Variable Blend Packed Double-Precision Floats.
  | VBLENDVPD = 723
  /// Variable Blend Packed Single-Precision Floats.
  | VBLENDVPS = 724
  /// Load with Broadcast Floating-Point Data.
  | VBROADCASTF128 = 725
  /// Broadcast 128 bits of int data in mem to low and high 128-bits in ymm1.
  | VBROADCASTI128 = 726
  /// Broadcast two dword elements.
  | VBROADCASTI32X2 = 727
  /// Broadcast four dword elements.
  | VBROADCASTI32X4 = 728
  /// Broadcast eight dword elements.
  | VBROADCASTI32X8 = 729
  /// Broadcast two qword elements.
  | VBROADCASTI64X2 = 730
  /// Broadcast four qword elements.
  | VBROADCASTI64X4 = 731
  /// Broadcast low double-precision floating-point element.
  | VBROADCASTSD = 732
  /// Broadcast Floating-Point Data.
  | VBROADCASTSS = 733
  /// Compare Packed Double-Precision Floating-Point Values.
  | VCMPPD = 734
  /// Compare Packed Single-Precision Floating-Point Values.
  | VCMPPS = 735
  /// Compare Scalar Double-Precision Floating-Point Values.
  | VCMPSD = 736
  /// Scalar Single-Precision Floating-Point Values.
  | VCMPSS = 737
  /// Compare Scalar Ordered Double-Precision FP Values and Set EFLAGS.
  | VCOMISD = 738
  /// Compare Scalar Ordered Single-Precision FP Values and Set EFLAGS.
  | VCOMISS = 739
  /// Compress packed DP elements of a vector.
  | VCOMPRESSPD = 740
  /// Compress packed SP elements of a vector.
  | VCOMPRESSPS = 741
  /// Convert two packed signed doubleword integers.
  | VCVTDQ2PD = 742
  /// Convert Packed Dword Integers to Packed Single-Precision FP Values.
  | VCVTDQ2PS = 743
  /// Convert Two Packed Single Data to One Packed BF16 Data.
  | VCVTNE2PS2BF16 = 744
  /// Convert Packed Single Data to Packed BF16 Data.
  | VCVTNEPS2BF16 = 745
  /// Convert Packed Double-Precision FP Values to Packed Doubleword Integers.
  | VCVTPD2DQ = 746
  /// Convert two packed double-precision floating-point values.
  | VCVTPD2PS = 747
  /// Convert Packed Double-Precision FP Values to Packed Quadword Integers.
  | VCVTPD2QQ = 748
  /// Convert Packed DP FP Values to Packed Unsigned DWord Integers.
  | VCVTPD2UDQ = 749
  /// Convert Packed DP FP Values to Packed Unsigned QWord Integers.
  | VCVTPD2UQQ = 750
  /// Convert 16-bit FP values to Single-Precision FP values.
  | VCVTPH2PS = 751
  /// Conv Packed Single-Precision FP Values to Packed Dbl-Precision FP Values.
  | VCVTPS2PD = 752
  /// Convert Single-Precision FP value to 16-bit FP value.
  | VCVTPS2PH = 753
  /// Convert Packed SP FP Values to Packed Signed QWord Int Values.
  | VCVTPS2QQ = 754
  /// Convert Packed SP FP Values to Packed Unsigned DWord Int Values.
  | VCVTPS2UDQ = 755
  /// Convert Packed SP FP Values to Packed Unsigned QWord Int Values.
  | VCVTPS2UQQ = 756
  /// Convert Packed Quadword Integers to Packed Double-Precision FP Values.
  | VCVTQQ2PD = 757
  /// Convert Packed Quadword Integers to Packed Single-Precision FP Values.
  | VCVTQQ2PS = 758
  /// Convert Scalar Double-Precision FP Value to Integer.
  | VCVTSD2SI = 759
  /// Convert Scalar Double-Precision FP Val to Scalar Single-Precision FP Val.
  | VCVTSD2SS = 760
  /// Convert Scalar Double-Precision FP Value to Unsigned Doubleword Integer.
  | VCVTSD2USI = 761
  /// Convert Dword Integer to Scalar Double-Precision FP Value.
  | VCVTSI2SD = 762
  /// Convert Dword Integer to Scalar Single-Precision FP Value.
  | VCVTSI2SS = 763
  /// Convert Scalar Single-Precision FP Val to Scalar Double-Precision FP Val.
  | VCVTSS2SD = 764
  /// Convert Scalar Single-Precision FP Value to Dword Integer.
  | VCVTSS2SI = 765
  /// Convert Scalar Single-Precision FP Value to Unsigned Doubleword Integer.
  | VCVTSS2USI = 766
  /// Conv with Trunc Packed Double-Precision FP Val to Packed Dword Integers.
  | VCVTTPD2DQ = 767
  /// Convert with Truncation Packed DP FP Values to Packed QWord Integers.
  | VCVTTPD2QQ = 768
  /// Convert with Truncation Packed DP FP Values to Packed Unsigned DWord Int.
  | VCVTTPD2UDQ = 769
  /// Convert with Truncation Packed DP FP Values to Packed Unsigned QWord Int.
  | VCVTTPD2UQQ = 770
  /// Conv with Trunc Packed Single-Precision FP Val to Packed Dword Integers.
  | VCVTTPS2DQ = 771
  /// Convert with Truncation Packed SP FP Values to Packed Signed QWord Int.
  | VCVTTPS2QQ = 772
  /// Convert with Truncation Packed SP FP Values to Packed Unsigned DWord Int.
  | VCVTTPS2UDQ = 773
  /// Convert with Truncation Packed SP FP Values to Packed Unsigned QWord Int.
  | VCVTTPS2UQQ = 774
  /// Convert with Truncation Scalar Double-Precision FP Value to Signed.
  | VCVTTSD2SI = 775
  /// Convert with Truncation Scalar DP FP Value to Unsigned Integer.
  | VCVTTSD2USI = 776
  /// Convert with Truncation Scalar Single-Precision FP Value to Dword Integer.
  | VCVTTSS2SI = 777
  /// Convert with Truncation Scalar Single-Precision FP Value to Unsigned Int.
  | VCVTTSS2USI = 778
  /// Convert Packed Unsigned DWord Integers to Packed DP FP Values.
  | VCVTUDQ2PD = 779
  /// Convert Packed Unsigned DWord Integers to Packed SP FP Values.
  | VCVTUDQ2PS = 780
  /// Convert Packed Unsigned QWord Integers to Packed DP FP Values.
  | VCVTUQQ2PD = 781
  /// Convert Packed Unsigned QWord Integers to Packed SP FP Values.
  | VCVTUQQ2PS = 782
  /// Convert an signed integer to the low DP FP elem and merge to a vector.
  | VCVTUSI2SD = 783
  /// Convert an signed integer to the low SP FP elem and merge to a vector.
  | VCVTUSI2SS = 784
  /// Convert an unsigned integer to the low DP FP elem and merge to a vector.
  | VCVTUSI2USD = 785
  /// Convert an unsigned integer to the low SP FP elem and merge to a vector.
  | VCVTUSI2USS = 786
  /// Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes.
  | VDBPSADBW = 787
  /// Divide Packed Double-Precision Floating-Point Values.
  | VDIVPD = 788
  /// Divide Packed Single-Precision Floating-Point Values.
  | VDIVPS = 789
  /// Divide Scalar Double-Precision Floating-Point Values.
  | VDIVSD = 790
  /// Divide Scalar Single-Precision Floating-Point Values.
  | VDIVSS = 791
  /// Dot Product of BF16 Pairs Accumulated into Packed Single Precision.
  | VDPBF16PS = 792
  /// Verify a Segment for Reading.
  | VERR = 793
  /// Verify a Segment for Writing.
  | VERW = 794
  /// Compute approximate base-2 exponential of packed DP FP elems of a vector.
  | VEXP2PD = 795
  /// Compute approximate base-2 exponential of packed SP FP elems of a vector.
  | VEXP2PS = 796
  /// Compute approximate base-2 exponential of the low DP FP elem of a vector.
  | VEXP2SD = 797
  /// Compute approximate base-2 exponential of the low SP FP elem of a vector.
  | VEXP2SS = 798
  /// Load Sparse Packed Double-Precision FP Values from Dense Memory.
  | VEXPANDPD = 799
  /// Load Sparse Packed Single-Precision FP Values from Dense Memory.
  | VEXPANDPS = 800
  /// Extract Packed Floating-Point Values.
  | VEXTRACTF128 = 801
  /// Extract a vector from a full-length vector with 32-bit granular update.
  | VEXTRACTF32X4 = 802
  /// Extract a vector from a full-length vector with 32-bit granular update.
  | VEXTRACTF32X8 = 803
  /// Extract a vector from a full-length vector with 64-bit granular update.
  | VEXTRACTF64X2 = 804
  /// Extract a vector from a full-length vector with 64-bit granular update.
  | VEXTRACTF64X4 = 805
  /// Extract packed Integer Values.
  | VEXTRACTI128 = 806
  /// Extract a vector from a full-length vector with 32-bit granular update.
  | VEXTRACTI32X4 = 807
  /// Extract a vector from a full-length vector with 32-bit granular update.
  | VEXTRACTI32X8 = 808
  /// Extract a vector from a full-length vector with 64-bit granular update.
  | VEXTRACTI64X2 = 809
  /// Extract a vector from a full-length vector with 64-bit granular update.
  | VEXTRACTI64X4 = 810
  /// Extract From Packed Single-Precision Floats.
  | VEXTRACTPS = 811
  /// Fix Up Special Packed Float64 Values.
  | VFIXUPIMMPD = 812
  /// Fix Up Special Packed Float32 Values.
  | VFIXUPIMMPS = 813
  /// Fix Up Special Scalar Float64 Value.
  | VFIXUPIMMSD = 814
  /// Fix Up Special Scalar Float32 Value.
  | VFIXUPIMMSS = 815
  /// Fused Multiply-Add of Packed Double-Precision Floating-Point Values.
  | VFMADD132PD = 816
  /// Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
  | VFMADD132PS = 817
  /// Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
  | VFMADD132SD = 818
  /// Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
  | VFMADD132SS = 819
  /// Fused Multiply-Add of Packed Double-Precision Floating-Point Values.
  | VFMADD213PD = 820
  /// Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
  | VFMADD213PS = 821
  /// Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
  | VFMADD213SD = 822
  /// Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
  | VFMADD213SS = 823
  /// Fused Multiply-Add of Packed Double-Precision Floating-Point Value.
  | VFMADD231PD = 824
  /// Fused Multiply-Add of Packed Single-Precision Floating-Point Values.
  | VFMADD231PS = 825
  /// Fused Multiply-Add of Scalar Double-Precision Floating-Point Values.
  | VFMADD231SD = 826
  /// Fused Multiply-Add of Scalar Single-Precision Floating-Point Values.
  | VFMADD231SS = 827
  /// Fused Multiply-Alternating Add/Sub of Packed Double-Precision FP Values.
  | VFMADDSUB132PD = 828
  /// Fused Multiply-Alternating Add/Sub of Packed Single-Precision FP Values.
  | VFMADDSUB132PS = 829
  /// Fused Multiply-Alternating Add/Sub of Packed Double-Precision FP Values.
  | VFMADDSUB213PD = 830
  /// Fused Multiply-Alternating Add/Sub of Packed Single-Precision FP Values.
  | VFMADDSUB213PS = 831
  /// Fused Multiply-Alternating Add/Sub of Packed Double-Precision FP Values.
  | VFMADDSUB231PD = 832
  /// Fused Multiply-Alternating Add/Sub of Packed Single-Precision FP Values.
  | VFMADDSUB231PS = 833
  /// Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
  | VFMSUB132PD = 834
  /// Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
  | VFMSUB132PS = 835
  /// Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
  | VFMSUB132SD = 836
  /// Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
  | VFMSUB132SS = 837
  /// Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
  | VFMSUB213PD = 838
  /// Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
  | VFMSUB213PS = 839
  /// Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
  | VFMSUB213SD = 840
  /// Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
  | VFMSUB213SS = 841
  /// Fused Multiply-Subtract of Packed Double-Precision Floating-Point Values.
  | VFMSUB231PD = 842
  /// Fused Multiply-Subtract of Packed Single-Precision Floating-Point Values.
  | VFMSUB231PS = 843
  /// Fused Multiply-Subtract of Scalar Double-Precision Floating-Point Values.
  | VFMSUB231SD = 844
  /// Fused Multiply-Subtract of Scalar Single-Precision Floating-Point Values.
  | VFMSUB231SS = 845
  /// Fused Multiply-Alternating Sub/Add of Packed Double-Precision FP Values.
  | VFMSUBADD132PD = 846
  /// Fused Multiply-Alternating Sub/Add of Packed Single-Precision FP Values.
  | VFMSUBADD132PS = 847
  /// Fused Multiply-Alternating Sub/Add of Packed Double-Precision FP Values.
  | VFMSUBADD213PD = 848
  /// Fused Multiply-Alternating Sub/Add of Packed Single-Precision FP Values.
  | VFMSUBADD213PS = 849
  /// Fused Multiply-Alternating Sub/Add of Packed Double-Precision FP Values.
  | VFMSUBADD231PD = 850
  /// Fused Multiply-Alternating Sub/Add of Packed Single-Precision FP Values.
  | VFMSUBADD231PS = 851
  /// Fused Negative Multiply-Add of Packed Double-Precision FP Values.
  | VFNMADD132PD = 852
  /// Fused Negative Mul-Add of Packed Single-Precision Floating-Point Values.
  | VFNMADD132PS = 853
  /// Fused Negative Multiply-Add of Scalar Double-Precision FP Values.
  | VFNMADD132SD = 854
  /// Fused Negative Mul-Add of Scalar Single-Precision Floating-Point Values.
  | VFNMADD132SS = 855
  /// Fused Negative Multiply-Add of Packed Double-Precision FP Values.
  | VFNMADD213PD = 856
  /// Fused Negative Mul-Add of Packed Single-Precision Floating-Point Values.
  | VFNMADD213PS = 857
  /// Fused Negative Multiply-Add of Scalar Double-Precision FP Values.
  | VFNMADD213SD = 858
  /// Fused Negative Mul-Add of Scalar Single-Precision Floating-Point Values.
  | VFNMADD213SS = 859
  /// Fused Negative Multiply-Add of Packed Double-Precision FP Values.
  | VFNMADD231PD = 860
  /// Fused Negative Mul-Add of Packed Single-Precision Floating-Point Values.
  | VFNMADD231PS = 861
  /// Fused Negative Multiply-Add of Scalar Double-Precision FP Values.
  | VFNMADD231SD = 862
  /// Fused Negative Mul-Add of Scalar Single-Precision Floating-Point Values.
  | VFNMADD231SS = 863
  /// Fused Negative Multiply-Subtract of Packed Double-Precision FP Values.
  | VFNMSUB132PD = 864
  /// Fused Negative Multiply-Subtract of Packed Single-Precision FP Values.
  | VFNMSUB132PS = 865
  /// Fused Negative Multiply-Subtract of Scalar Double-Precision FP Values.
  | VFNMSUB132SD = 866
  /// Fused Negative Multiply-Subtract of Scalar Single-Precision FP Values.
  | VFNMSUB132SS = 867
  /// Fused Negative Multiply-Subtract of Packed Double-Precision FP Values.
  | VFNMSUB213PD = 868
  /// Fused Negative Multiply-Subtract of Packed Single-Precision FP Values.
  | VFNMSUB213PS = 869
  /// Fused Negative Multiply-Subtract of Scalar Double-Precision FP Values.
  | VFNMSUB213SD = 870
  /// Fused Negative Multiply-Subtract of Scalar Single-Precision FP Values.
  | VFNMSUB213SS = 871
  /// Fused Negative Multiply-Subtract of Packed Double-Precision FP Values.
  | VFNMSUB231PD = 872
  /// Fused Negative Multiply-Subtract of Packed Single-Precision FP Values.
  | VFNMSUB231PS = 873
  /// Fused Negative Multiply-Subtract of Scalar Double-Precision FP Values.
  | VFNMSUB231SD = 874
  /// Fused Negative Multiply-Subtract of Scalar Single-Precision FP Values.
  | VFNMSUB231SS = 875
  /// Tests Types Of a Packed Float64 Values.
  | VFPCLASSPD = 876
  /// Tests Types Of a Packed Float32 Values.
  | VFPCLASSPS = 877
  /// Tests Types Of a Scalar Float64 Values.
  | VFPCLASSSD = 878
  /// Tests Types Of a Scalar Float32 Values.
  | VFPCLASSSS = 879
  /// Gather Packed DP FP Values Using Signed Dword/Qword Indices.
  | VGATHERDPD = 880
  /// Gather Packed SP FP values Using Signed Dword/Qword Indices.
  | VGATHERDPS = 881
  /// Sparse prefetch of packed DP FP vector with T0 hint using dword indices.
  | VGATHERPF0DPD = 882
  /// Sparse prefetch of packed SP FP vector with T0 hint using dword indices.
  | VGATHERPF0DPS = 883
  /// Sparse prefetch of packed DP FP vector with T0 hint using qword indices.
  | VGATHERPF0QPD = 884
  /// Sparse prefetch of packed SP FP vector with T0 hint using qword indices.
  | VGATHERPF0QPS = 885
  /// Sparse prefetch of packed DP FP vector with T1 hint using dword indices.
  | VGATHERPF1DPD = 886
  /// Sparse prefetch of packed SP FP vector with T1 hint using dword indices.
  | VGATHERPF1DPS = 887
  /// Sparse prefetch of packed DP FP vector with T1 hint using qword indices.
  | VGATHERPF1QPD = 888
  /// Sparse prefetch of packed SP FP vector with T1 hint using qword indices.
  | VGATHERPF1QPS = 889
  /// Gather Packed DP FP Values Using Signed Dword/Qword Indices.
  | VGATHERQPD = 890
  /// Gather Packed SP FP values Using Signed Dword/Qword Indices.
  | VGATHERQPS = 891
  /// Convert Exponents of Packed DP FP Values to DP FP Values.
  | VGETEXPPD = 892
  /// Convert Exponents of Packed SP FP Values to SP FP Values.
  | VGETEXPPS = 893
  /// Convert Exponents of Scalar DP FP Values to DP FP Value.
  | VGETEXPSD = 894
  /// Convert Exponents of Scalar SP FP Values to SP FP Value.
  | VGETEXPSS = 895
  /// Extract Float64 Vector of Normalized Mantissas from Float64 Vector.
  | VGETMANTPD = 896
  /// Extract Float32 Vector of Normalized Mantissas from Float32 Vector.
  | VGETMANTPS = 897
  /// Extract Float64 of Normalized Mantissas from Float64 Scalar.
  | VGETMANTSD = 898
  /// Extract Float32 Vector of Normalized Mantissa from Float32 Vector.
  | VGETMANTSS = 899
  /// Galois Field Affine Transformation Inverse.
  | VGF2P8AFFINEINVQB = 900
  /// Galois Field Affine Transformation.
  | VGF2P8AFFINEQB = 901
  /// Galois Field Multiply Bytes.
  | VGF2P8MULB = 902
  /// Packed Double-FP Horizontal Add.
  | VHADDPD = 903
  /// Packed Single-FP Horizontal Add.
  | VHADDPS = 904
  /// Packed Double-FP Horizontal Subtract.
  | VHSUBPD = 905
  /// Packed Single-FP Horizontal Subtract.
  | VHSUBPS = 906
  /// Insert Packed Floating-Point Values.
  | VINSERTF128 = 907
  /// Insert Packed Floating-Point Values.
  | VINSERTF32X4 = 908
  /// Insert Packed Floating-Point Values.
  | VINSERTF64X2 = 909
  /// Insert Packed Floating-Point Values.
  | VINSERTF64X4 = 910
  /// Insert Packed Integer Values.
  | VINSERTI128 = 911
  /// Insert 256 bits of packed doubleword integer values.
  | VINSERTI32X8 = 912
  /// Insert Packed Floating-Point Values.
  | VINSERTI64X2 = 913
  /// Insert 256 bits of packed quadword integer values.
  | VINSERTI64X4 = 914
  /// Insert Into Packed Single-Precision Floats.
  | VINSERTPS = 915
  /// Load Unaligned Integer 128 Bits.
  | VLDDQU = 916
  /// Conditional SIMD Packed Loads and Stores.
  | VMASKMOVPD = 917
  /// Conditional SIMD Packed Loads and Stores.
  | VMASKMOVPS = 918
  /// Return Maximum Packed Double-Precision Floating-Point Values.
  | VMAXPD = 919
  /// Maximum of Packed Single-Precision Floating-Point Values.
  | VMAXPS = 920
  /// Return Maximum Scalar Double-Precision Floating-Point Value.
  | VMAXSD = 921
  /// Return Maximum Scalar Single-Precision Floating-Point Value.
  | VMAXSS = 922
  /// Call to VM Monitor.
  | VMCALL = 923
  /// Clear Virtual-Machine Control Structure.
  | VMCLEAR = 924
  /// Invoke VM function.
  | VMFUNC = 925
  /// Return Minimum Packed Double-Precision Floating-Point Values.
  | VMINPD = 926
  /// Return Minimum Packed Single-Precision Floating-Point Values.
  | VMINPS = 927
  /// Return Minimum Scalar Double-Precision Floating-Point Value.
  | VMINSD = 928
  /// Return Minimum Scalar Single-Precision Floating-Point Value.
  | VMINSS = 929
  /// Launch Virtual Machine.
  | VMLAUNCH = 930
  /// Move Aligned Packed Double-Precision Floating-Point Values.
  | VMOVAPD = 931
  /// Move Aligned Packed Single-Precision Floating-Point Values.
  | VMOVAPS = 932
  /// Move Doubleword.
  | VMOVD = 933
  /// Move One Double-FP and Duplicate.
  | VMOVDDUP = 934
  /// Move Aligned Double Quadword.
  | VMOVDQA = 935
  /// Move Aligned Double Quadword.
  | VMOVDQA32 = 936
  /// Move Aligned Double Quadword.
  | VMOVDQA64 = 937
  /// Move Unaligned Double Quadword.
  | VMOVDQU = 938
  /// VMOVDQU with 16-bit granular conditional update.
  | VMOVDQU16 = 939
  /// Move Unaligned Double Quadword.
  | VMOVDQU32 = 940
  /// Move Unaligned Double Quadword.
  | VMOVDQU64 = 941
  /// VMOVDQU with 8-bit granular conditional update.
  | VMOVDQU8 = 942
  /// Move Packed Single-Precision Floating-Point Values High to Low.
  | VMOVHLPS = 943
  /// Move High Packed Double-Precision Floating-Point Value.
  | VMOVHPD = 944
  /// Move High Packed Single-Precision Floating-Point Values.
  | VMOVHPS = 945
  /// Move Packed Single-Precision Floating-Point Values Low to High.
  | VMOVLHPS = 946
  /// Move Low Packed Double-Precision Floating-Point Value.
  | VMOVLPD = 947
  /// Move Low Packed Single-Precision Floating-Point Values.
  | VMOVLPS = 948
  /// Extract Packed Double-Precision Floating-Point Sign Mask.
  | VMOVMSKPD = 949
  /// Extract Packed Single-Precision Floating-Point Sign Mask.
  | VMOVMSKPS = 950
  /// Load Double Quadword Non-Temporal Aligned Hint.
  | VMOVNTDQ = 951
  /// Store Packed Double-Precision FP Values Using Non-Temporal Hint.
  | VMOVNTPD = 952
  /// Store Packed Single-Precision FP Values Using Non-Temporal Hint.
  | VMOVNTPS = 953
  /// Move Quadword.
  | VMOVQ = 954
  /// Move Data from String to String (doubleword).
  | VMOVSD = 955
  /// Move Packed Single-FP High and Duplicate.
  | VMOVSHDUP = 956
  /// Move Packed Single-FP Low and Duplicate.
  | VMOVSLDUP = 957
  /// Move Scalar Single-Precision Floating-Point Values.
  | VMOVSS = 958
  /// Move Unaligned Packed Double-Precision Floating-Point Values.
  | VMOVUPD = 959
  /// Move Unaligned Packed Single-Precision Floating-Point Values.
  | VMOVUPS = 960
  /// Load Pointer to Virtual-Machine Control Structure.
  | VMPTRLD = 961
  /// Store Pointer to Virtual-Machine Control Structure.
  | VMPTRST = 962
  /// Reads a component from the VMCS and stores it into a destination operand.
  | VMREAD = 963
  /// Resume Virtual Machine.
  | VMRESUME = 964
  /// Multiply Packed Double-Precision Floating-Point Values.
  | VMULPD = 965
  /// Multiply Packed Single-Precision Floating-Point Values.
  | VMULPS = 966
  /// Multiply Scalar Double-Precision Floating-Point Values.
  | VMULSD = 967
  /// Multiply Scalar Single-Precision Floating-Point Values.
  | VMULSS = 968
  /// Writes a component to the VMCS from a source operand.
  | VMWRITE = 969
  /// Leave VMX Operation.
  | VMXOFF = 970
  /// Enter VMX Operation.
  | VMXON = 971
  /// Bitwise Logical OR of Double-Precision Floating-Point Values.
  | VORPD = 972
  /// Bitwise Logical OR of Single-Precision Floating-Point Values.
  | VORPS = 973
  /// Compute Intersection Between dwords.
  | VP2INTERSECTD = 974
  /// Compute Intersection Between qwords.
  | VP2INTERSECTQ = 975
  /// Dot Product of Signed Words with Dword Accumulation.
  | VP4DPWSSD = 976
  /// Dot Product of Signed Words with Dword Accumulation and Saturation.
  | VP4DPWSSDS = 977
  /// Packed Absolute Value (byte).
  | VPABSB = 978
  /// Packed Absolute Value (dword).
  | VPABSD = 979
  /// Packed Absolute Value (qword).
  | VPABSQ = 980
  /// Packed Absolute Value (word).
  | VPABSW = 981
  /// Pack with Signed Saturation.
  | VPACKSSDW = 982
  /// Pack with Signed Saturation.
  | VPACKSSWB = 983
  /// Pack with Unsigned Saturation.
  | VPACKUSDW = 984
  /// Pack with Unsigned Saturation.
  | VPACKUSWB = 985
  /// Add Packed byte Integers.
  | VPADDB = 986
  /// Add Packed Doubleword Integers.
  | VPADDD = 987
  /// Add Packed Quadword Integers.
  | VPADDQ = 988
  /// Add Packed Signed Integers with Signed Saturation (byte).
  | VPADDSB = 989
  /// Add Packed Signed Integers with Signed Saturation (word).
  | VPADDSW = 990
  /// Add Packed Unsigned Integers with Unsigned Saturation (byte).
  | VPADDUSB = 991
  /// Add Packed Unsigned Integers with Unsigned Saturation (word).
  | VPADDUSW = 992
  /// Add Packed word Integers.
  | VPADDW = 993
  /// Packed Align Right.
  | VPALIGNR = 994
  /// Logical AND.
  | VPAND = 995
  /// Logical AND NOT.
  | VPANDN = 996
  /// Average Packed Integers (byte).
  | VPAVGB = 997
  /// Average Packed Integers (word).
  | VPAVGW = 998
  /// Blend Packed Dwords.
  | VPBLENDD = 999
  /// Blend Byte/Word Vectors Using an Opmask Control.
  | VPBLENDMB = 1000
  /// Blend Int32/Int64 Vectors Using an OpMask Control.
  | VPBLENDMD = 1001
  /// Blend qword elements using opmask as select control.
  | VPBLENDMQ = 1002
  /// Blend word elements using opmask as select control.
  | VPBLENDMW = 1003
  /// Variable Blend Packed Bytes.
  | VPBLENDVB = 1004
  /// Blend Packed Words.
  | VPBLENDW = 1005
  /// Broadcast Integer Data.
  | VPBROADCASTB = 1006
  /// Broadcast from general-purpose register to vector register.
  | VPBROADCASTD = 1007
  /// Broadcast Mask to Vector Register.
  | VPBROADCASTM = 1008
  /// Broadcast low byte value in k1.
  | VPBROADCASTMB2Q = 1009
  /// Broadcast low word value in k1.
  | VPBROADCASTMW2D = 1010
  /// Broadcast from general-purpose register to vector register.
  | VPBROADCASTQ = 1011
  /// Broadcast from general-purpose register to vector register.
  | VPBROADCASTW = 1012
  /// Carry-Less Multiplication Quadword.
  | VPCLMULQDQ = 1013
  /// Compare packed signed bytes using specified primitive.
  | VPCMPB = 1014
  /// Compare packed signed dwords using specified primitive.
  | VPCMPD = 1015
  /// Compare Packed Data for Equal (byte).
  | VPCMPEQB = 1016
  /// Compare Packed Data for Equal (doubleword).
  | VPCMPEQD = 1017
  /// Compare Packed Data for Equal (quadword).
  | VPCMPEQQ = 1018
  /// Compare Packed Data for Equal (word).
  | VPCMPEQW = 1019
  /// Packed Compare Explicit Length Strings, Return Index.
  | VPCMPESTRI = 1020
  /// Packed Compare Explicit Length Strings, Return Mask.
  | VPCMPESTRM = 1021
  /// Compare Packed Signed Integers for Greater Than (byte).
  | VPCMPGTB = 1022
  /// Compare Packed Signed Integers for Greater Than (doubleword).
  | VPCMPGTD = 1023
  /// Compare Packed Data for Greater Than (qword).
  | VPCMPGTQ = 1024
  /// Compare Packed Signed Integers for Greater Than (word).
  | VPCMPGTW = 1025
  /// Packed Compare Implicit Length Strings, Return Index.
  | VPCMPISTRI = 1026
  /// Packed Compare Implicit Length Strings, Return Mask.
  | VPCMPISTRM = 1027
  /// Compare packed signed quadwords using specified primitive.
  | VPCMPQ = 1028
  /// Compare packed unsigned bytes using specified primitive.
  | VPCMPUB = 1029
  /// Compare packed unsigned dwords using specified primitive.
  | VPCMPUD = 1030
  /// Compare packed unsigned quadwords using specified primitive.
  | VPCMPUQ = 1031
  /// Compare packed unsigned words using specified primitive.
  | VPCMPUW = 1032
  /// Compare packed signed words using specified primitive.
  | VPCMPW = 1033
  /// Compare packed unsigned bytes using specified primitive.
  | VPCMUB = 1034
  /// Compare packed unsigned dwords using specified primitive.
  | VPCMUD = 1035
  /// Compare packed unsigned quadwords using specified primitive.
  | VPCMUQ = 1036
  /// Compare packed unsigned words using specified primitive.
  | VPCMUW = 1037
  /// Store Sparse Packed Byte Integer Values into Dense Memory/Register.
  | VPCOMPRESSB = 1038
  /// Store Sparse Packed Doubleword Integer Values into Dense Memory/Register.
  | VPCOMPRESSD = 1039
  /// Store Sparse Packed Quadword Integer Values into Dense Memory/Register.
  | VPCOMPRESSQ = 1040
  /// Store Sparse Packed Word Integer Values into Dense Memory/Register.
  | VPCOMPRESSW = 1041
  /// Detect conflicts within a vector of packed 32/64-bit integers.
  | VPCONFLICTD = 1042
  /// Detect conflicts within a vector of packed 64-bit integers.
  | VPCONFLICTQ = 1043
  /// Multiply and Add Unsigned and Signed Bytes.
  | VPDPBUSD = 1044
  /// Multiply and Add Unsigned and Signed Bytes with Saturation.
  | VPDPBUSDS = 1045
  /// Multiply and Add Signed Word Integers.
  | VPDPWSSD = 1046
  /// Multiply and Add Signed Word Integers with Saturation.
  | VPDPWSSDS = 1047
  /// Permute Floating-Point Values.
  | VPERM2F128 = 1048
  /// Permute Integer Values.
  | VPERM2I128 = 1049
  /// Permute packed bytes elements.
  | VPERMB = 1050
  /// Permute Packed Doublewords/Words Elements.
  | VPERMD = 1051
  /// Full Permute of Bytes from Two Tables Overwriting the Index.
  | VPERMI2B = 1052
  /// Full permute of two tables of dword elements overwriting the index vector.
  | VPERMI2D = 1053
  /// Full permute of two tables of DP elements overwriting the index vector.
  | VPERMI2PD = 1054
  /// Full permute of two tables of SP elements overwriting the index vector.
  | VPERMI2PS = 1055
  /// Full permute of two tables of qword elements overwriting the index vector.
  | VPERMI2Q = 1056
  /// Full Permute From Two Tables Overwriting the Index.
  | VPERMI2W = 1057
  /// Permute Double-Precision Floating-Point Values.
  | VPERMILPD = 1058
  /// Permute Single-Precision Floating-Point Values.
  | VPERMILPS = 1059
  /// Permute Double-Precision Floating-Point Elements.
  | VPERMPD = 1060
  /// Permute Single-Precision Floating-Point Elements.
  | VPERMPS = 1061
  /// Qwords Element Permutation.
  | VPERMQ = 1062
  /// Full permute of two tables of byte elements overwriting one source table.
  | VPERMT2B = 1063
  /// Full permute of two tables of dword elements overwriting one source table.
  | VPERMT2D = 1064
  /// Full permute of two tables of DP elements overwriting one source table.
  | VPERMT2PD = 1065
  /// Full permute of two tables of SP elements overwriting one source table.
  | VPERMT2PS = 1066
  /// Full permute of two tables of qword elements overwriting one source table.
  | VPERMT2Q = 1067
  /// Full permute of two tables of word elements overwriting one source table.
  | VPERMT2W = 1068
  /// Permute packed word elements.
  | VPERMW = 1069
  /// Load Sparse Packed Byte Integer Values from Dense Memory / Register.
  | VPEXPANDB = 1070
  /// Load Sparse Packed Doubleword Integer Values from Dense Memory / Register.
  | VPEXPANDD = 1071
  /// Load Sparse Packed Quadword Integer Values from Dense Memory / Register.
  | VPEXPANDQ = 1072
  /// Load Sparse Packed Word Integer Values from Dense Memory / Register.
  | VPEXPANDW = 1073
  /// Extract Byte.
  | VPEXTRB = 1074
  /// Extract DWord.
  | VPEXTRD = 1075
  /// Extract Word.
  | VPEXTRW = 1076
  /// Gather packed dword values using signed Dword/Qword indices.
  | VPGATHERDD = 1077
  /// Gather Packed Qword Values Using Signed Dword/Qword Indices.
  | VPGATHERDQ = 1078
  /// Gather Packed Dword Values Using Signed Dword/Qword Indices.
  | VPGATHERQD = 1079
  /// Gather Packed Qword Values Using Signed Dword/Qword Indices.
  | VPGATHERQQ = 1080
  /// Packed Horizontal Add (32-bit).
  | VPHADDD = 1081
  /// Packed Horizontal Add and Saturate (16-bit).
  | VPHADDSW = 1082
  /// Packed Horizontal Add (16-bit).
  | VPHADDW = 1083
  /// Packed Horizontal Word Minimum.
  | VPHMINPOSUW = 1084
  /// Packed Horizontal Subtract (32-bit).
  | VPHSUBD = 1085
  /// Packed Horizontal Subtract and Saturate (16-bit).
  | VPHSUBSW = 1086
  /// Packed Horizontal Subtract (16-bit).
  | VPHSUBW = 1087
  /// Insert Byte.
  | VPINSRB = 1088
  /// Insert Dword.
  | VPINSRD = 1089
  /// Insert Qword.
  | VPINSRQ = 1090
  /// Insert Word.
  | VPINSRW = 1091
  /// Count the number of leading zero bits of packed dword elements.
  | VPLZCNTD = 1092
  /// Count the number of leading zero bits of packed qword elements.
  | VPLZCNTQ = 1093
  /// Packed Multiply of Unsigned 52-bit and Add High 52-bit Products.
  | VPMADD52HUQ = 1094
  /// Packed Multiply of Unsigned 52-bit and Add Low 52-bit Products.
  | VPMADD52LUQ = 1095
  /// Multiply and Add Packed Integers.
  | VPMADDWD = 1096
  /// Conditional SIMD Integer Packed Loads and Stores.
  | VPMASKMOVD = 1097
  /// Conditional SIMD Integer Packed Loads and Stores.
  | VPMASKMOVQ = 1098
  /// Maximum of Packed Signed Integers (byte).
  | VPMAXSB = 1099
  /// Maximum of Packed Signed Integers (dword).
  | VPMAXSD = 1100
  /// Compute maximum of packed signed 64-bit integer elements.
  | VPMAXSQ = 1101
  /// Maximum of Packed Signed Word Integers.
  | VPMAXSW = 1102
  /// Maximum of Packed Unsigned Byte Integers.
  | VPMAXUB = 1103
  /// Maximum of Packed Unsigned Integers (dword).
  | VPMAXUD = 1104
  /// Compute maximum of packed unsigned 64-bit integer elements.
  | VPMAXUQ = 1105
  /// Maximum of Packed Unsigned Integers (word).
  | VPMAXUW = 1106
  /// Minimum of Packed Signed Integers (byte).
  | VPMINSB = 1107
  /// Minimum of Packed Signed Integers (dword).
  | VPMINSD = 1108
  /// Compute minimum of packed signed 64-bit integer elements.
  | VPMINSQ = 1109
  /// Minimum of Packed Signed Word Integers.
  | VPMINSW = 1110
  /// Minimum of Packed Unsigned Byte Integers.
  | VPMINUB = 1111
  /// Minimum of Packed Dword Integers.
  | VPMINUD = 1112
  /// Compute minimum of packed unsigned 64-bit integer elements.
  | VPMINUQ = 1113
  /// Minimum of Packed Unsigned Integers (word).
  | VPMINUW = 1114
  /// Convert a vector register in 32/64-bit granularity to an opmask register.
  | VPMOVB2D = 1115
  /// Convert a Vector Register to a Mask.
  | VPMOVB2M = 1116
  /// Convert dword vector register to mask register.
  | VPMOVD2M = 1117
  /// Down Convert DWord to Byte.
  | VPMOVDB = 1118
  /// Down Convert DWord to Word.
  | VPMOVDW = 1119
  /// Convert opmask register to vector register in 8-bit granularity.
  | VPMOVM2B = 1120
  /// Convert opmask register to vector register in 32-bit granularity.
  | VPMOVM2D = 1121
  /// Convert opmask register to vector register in 64-bit granularity.
  | VPMOVM2Q = 1122
  /// Convert opmask register to vector register in 16-bit granularity.
  | VPMOVM2W = 1123
  /// Move Byte Mask.
  | VPMOVMSKB = 1124
  /// Convert qword vector register to mask register.
  | VPMOVQ2M = 1125
  /// Down Convert QWord to Byte.
  | VPMOVQB = 1126
  /// Down Convert QWord to DWord.
  | VPMOVQD = 1127
  /// Down Convert QWord to Word.
  | VPMOVQW = 1128
  /// Down Convert DWord to Byte.
  | VPMOVSDB = 1129
  /// Down Convert DWord to Word.
  | VPMOVSDW = 1130
  /// Down Convert QWord to Byte.
  | VPMOVSQB = 1131
  /// Down Convert QWord to Dword.
  | VPMOVSQD = 1132
  /// Down Convert QWord to Word.
  | VPMOVSQW = 1133
  /// Down Convert Word to Byte.
  | VPMOVSWB = 1134
  /// Packed Move with Sign Extend (8-bit to 32-bit).
  | VPMOVSXBD = 1135
  /// Packed Move with Sign Extend (8-bit to 64-bit).
  | VPMOVSXBQ = 1136
  /// Packed Move with Sign Extend (8-bit to 16-bit).
  | VPMOVSXBW = 1137
  /// Packed Move with Sign Extend (32-bit to 64-bit).
  | VPMOVSXDQ = 1138
  /// Packed Move with Sign Extend (16-bit to 32-bit).
  | VPMOVSXWD = 1139
  /// Packed Move with Sign Extend (16-bit to 64-bit).
  | VPMOVSXWQ = 1140
  /// Down Convert DWord to Byte.
  | VPMOVUSDB = 1141
  /// Down Convert DWord to Word.
  | VPMOVUSDW = 1142
  /// Down Convert QWord to Byte.
  | VPMOVUSQB = 1143
  /// Down Convert QWord to DWord.
  | VPMOVUSQD = 1144
  /// Down Convert QWord to Word.
  | VPMOVUSQW = 1145
  /// Down Convert Word to Byte.
  | VPMOVUSWB = 1146
  /// Convert a vector register in 16-bit granularity to an opmask register.
  | VPMOVW2M = 1147
  /// Down convert word elements in a vector to byte elements using truncation.
  | VPMOVWB = 1148
  /// Packed Move with Zero Extend (8-bit to 32-bit).
  | VPMOVZXBD = 1149
  /// Packed Move with Zero Extend (8-bit to 64-bit).
  | VPMOVZXBQ = 1150
  /// Packed Move with Zero Extend (8-bit to 16-bit).
  | VPMOVZXBW = 1151
  /// Packed Move with Zero Extend (32-bit to 64-bit).
  | VPMOVZXDQ = 1152
  /// Packed Move with Zero Extend (16-bit to 32-bit).
  | VPMOVZXWD = 1153
  /// Packed Move with Zero Extend (16-bit to 64-bit).
  | VPMOVZXWQ = 1154
  /// Multiply Packed Doubleword Integers.
  | VPMULDQ = 1155
  /// Packed Multiply High with Round and Scale.
  | VPMULHRSW = 1156
  /// Multiply Packed Unsigned Integers and Store High Result.
  | VPMULHUW = 1157
  /// Multiply Packed Signed Integers and Store High Result.
  | VPMULHW = 1158
  /// Multiply Packed Integers and Store Low Result.
  | VPMULLD = 1159
  /// Multiply Packed Integers and Store Low Result.
  | VPMULLQ = 1160
  /// Multiply Packed Signed Integers and Store Low Result.
  | VPMULLW = 1161
  /// Select Packed Unaligned Bytes from Quadword Sources.
  | VPMULTISHIFTQB = 1162
  /// Multiply Packed Unsigned Doubleword Integers.
  | VPMULUDQ = 1163
  /// Return the Count of Number of Bits Set to 1 in byte.
  | VPOPCNTB = 1164
  /// Return the Count of Number of Bits Set to 1 in dword.
  | VPOPCNTD = 1165
  /// Return the Count of Number of Bits Set to 1 in qword.
  | VPOPCNTQ = 1166
  /// Return the Count of Number of Bits Set to 1 in word.
  | VPOPCNTW = 1167
  /// Bitwise Logical OR.
  | VPOR = 1168
  /// Rotate dword elem left by a constant shift count with conditional update.
  | VPROLD = 1169
  /// Rotate qword elem left by a constant shift count with conditional update.
  | VPROLQ = 1170
  /// Rotate dword element left by shift counts specified.
  | VPROLVD = 1171
  /// Rotate qword element left by shift counts specified.
  | VPROLVQ = 1172
  /// Rotate dword element right by a constant shift count.
  | VPRORD = 1173
  /// Rotate qword element right by a constant shift count.
  | VPRORQ = 1174
  /// Rotate dword element right by shift counts specified.
  | VPRORRD = 1175
  /// Rotate qword element right by shift counts specified.
  | VPRORRQ = 1176
  /// Rotate dword element right by shift counts specified.
  | VPRORVD = 1177
  /// Rotate qword element right by shift counts specified.
  | VPRORVQ = 1178
  /// Compute Sum of Absolute Differences.
  | VPSADBW = 1179
  /// Scatter dword elements in a vector to memory using dword indices.
  | VPSCATTERDD = 1180
  /// Scatter qword elements in a vector to memory using dword indices.
  | VPSCATTERDQ = 1181
  /// Scatter dword elements in a vector to memory using qword indices.
  | VPSCATTERQD = 1182
  /// Scatter qword elements in a vector to memory using qword indices.
  | VPSCATTERQQ = 1183
  /// Concatenate and Shift Packed Data Left Logical.
  | VPSHLDD = 1184
  /// Concatenate and Shift Packed Data Left Logical.
  | VPSHLDQ = 1185
  /// Concatenate and Variable Shift Packed Data Left Logical.
  | VPSHLDVD = 1186
  /// Concatenate and Variable Shift Packed Data Left Logical.
  | VPSHLDVQ = 1187
  /// Concatenate and Variable Shift Packed Data Left Logical.
  | VPSHLDVW = 1188
  /// Concatenate and Shift Packed Data Left Logical.
  | VPSHLDW = 1189
  /// Concatenate and Shift Packed Data Right Logical.
  | VPSHRDD = 1190
  /// Concatenate and Shift Packed Data Right Logical.
  | VPSHRDQ = 1191
  /// Concatenate and Variable Shift Packed Data Right Logical.
  | VPSHRDVD = 1192
  /// Concatenate and Variable Shift Packed Data Right Logical.
  | VPSHRDVQ = 1193
  /// Concatenate and Variable Shift Packed Data Right Logical.
  | VPSHRDVW = 1194
  /// Concatenate and Shift Packed Data Right Logical.
  | VPSHRDW = 1195
  /// Packed Shuffle Bytes.
  | VPSHUFB = 1196
  /// Shuffle Bits from Quadword Elements Using Byte Indexes into Mask.
  | VPSHUFBITQMB = 1197
  /// Shuffle Packed Doublewords.
  | VPSHUFD = 1198
  /// Shuffle Packed High Words.
  | VPSHUFHW = 1199
  /// Shuffle Packed Low Words.
  | VPSHUFLW = 1200
  /// Packed SIGN (byte).
  | VPSIGNB = 1201
  /// Packed SIGN (doubleword).
  | VPSIGND = 1202
  /// Packed SIGN (word).
  | VPSIGNW = 1203
  /// Shift Packed Data Left Logical (doubleword).
  | VPSLLD = 1204
  /// Shift Double Quadword Left Logical.
  | VPSLLDQ = 1205
  /// Shift Packed Data Left Logical (quadword).
  | VPSLLQ = 1206
  /// Variable Bit Shift Left Logical.
  | VPSLLVD = 1207
  /// Variable Bit Shift Left Logical.
  | VPSLLVQ = 1208
  /// Variable Bit Shift Left Logical.
  | VPSLLVW = 1209
  /// Shift Packed Data Left Logical (word).
  | VPSLLW = 1210
  /// Shift Packed Data Right Arithmetic (doubleword).
  | VPSRAD = 1211
  /// Shift qwords right by a constant shift count and shifting in sign bits.
  | VPSRAQ = 1212
  /// Variable Bit Shift Right Arithmetic.
  | VPSRAVD = 1213
  /// Shift qwords right by shift counts in a vector and shifting in sign bits.
  | VPSRAVQ = 1214
  /// Variable Bit Shift Right Arithmetic.
  | VPSRAVW = 1215
  /// Shift Packed Data Right Arithmetic (word).
  | VPSRAW = 1216
  /// Shift Packed Data Right Logical (doubleword).
  | VPSRLD = 1217
  /// Shift Double Quadword Right Logical.
  | VPSRLDQ = 1218
  /// Shift Packed Data Right Logical (quadword).
  | VPSRLQ = 1219
  /// Variable Bit Shift Right Logical.
  | VPSRLVD = 1220
  /// Variable Bit Shift Right Logical.
  | VPSRLVQ = 1221
  /// Variable Bit Shift Right Logical.
  | VPSRLVW = 1222
  /// Shift Packed Data Right Logical (word).
  | VPSRLW = 1223
  /// Subtract Packed Integers (byte).
  | VPSUBB = 1224
  /// Subtract Packed Integers (doubleword).
  | VPSUBD = 1225
  /// Subtract Packed Integers (quadword).
  | VPSUBQ = 1226
  /// Subtract Packed Signed Integers with Signed Saturation (byte).
  | VPSUBSB = 1227
  /// Subtract Packed Signed Integers with Signed Saturation (word).
  | VPSUBSW = 1228
  /// Subtract Packed Unsigned Integers with Unsigned Saturation (byte).
  | VPSUBUSB = 1229
  /// Subtract Packed Unsigned Integers with Unsigned Saturation (word).
  | VPSUBUSW = 1230
  /// Subtract Packed Integers (word).
  | VPSUBW = 1231
  /// Perform bitwise ternary logic operation of three vectors.
  | VPTERLOGD = 1232
  /// Perform bitwise ternary logic operation of three vectors.
  | VPTERLOGQ = 1233
  /// Bitwise Ternary Logic.
  | VPTERNLOGD = 1234
  /// Bitwise Ternary Logic.
  | VPTERNLOGQ = 1235
  /// Logical Compare.
  | VPTEST = 1236
  /// Perform bitwise AND of byte elems of two vecs and write results to opmask.
  | VPTESTMB = 1237
  /// Perform bitwise AND of dword elems of 2-vecs and write results to opmask.
  | VPTESTMD = 1238
  /// Perform bitwise AND of qword elems of 2-vecs and write results to opmask.
  | VPTESTMQ = 1239
  /// Perform bitwise AND of word elems of two vecs and write results to opmask.
  | VPTESTMW = 1240
  /// Perform bitwise NAND of byte elems of 2-vecs and write results to opmask.
  | VPTESTNMB = 1241
  /// Perform bitwise NAND of dword elems of 2-vecs and write results to opmask.
  | VPTESTNMD = 1242
  /// Perform bitwise NAND of qword elems of 2-vecs and write results to opmask.
  | VPTESTNMQ = 1243
  /// Perform bitwise NAND of word elems of 2-vecs and write results to opmask.
  | VPTESTNMW = 1244
  /// Unpack High Data.
  | VPUNPCKHBW = 1245
  /// Unpack High Data.
  | VPUNPCKHDQ = 1246
  /// Unpack High Data.
  | VPUNPCKHQDQ = 1247
  /// Unpack High Data.
  | VPUNPCKHWD = 1248
  /// Unpack Low Data.
  | VPUNPCKLBW = 1249
  /// Unpack Low Data.
  | VPUNPCKLDQ = 1250
  /// Unpack Low Data.
  | VPUNPCKLQDQ = 1251
  /// Unpack Low Data.
  | VPUNPCKLWD = 1252
  /// Logical Exclusive OR.
  | VPXOR = 1253
  /// Bitwise XOR of packed doubleword integers.
  | VPXORD = 1254
  /// Bitwise XOR of packed quadword integers.
  | VPXORQ = 1255
  /// Range Restriction Calculation For Packed Pairs of Float64 Values.
  | VRANGEPD = 1256
  /// Range Restriction Calculation For Packed Pairs of Float32 Values.
  | VRANGEPS = 1257
  /// Range Restriction Calculation From a pair of Scalar Float64 Values.
  | VRANGESD = 1258
  /// Range Restriction Calculation From a Pair of Scalar Float32 Values.
  | VRANGESS = 1259
  /// Compute Approximate Reciprocals of Packed Float64 Values.
  | VRCP14PD = 1260
  /// Compute Approximate Reciprocals of Packed Float32 Values.
  | VRCP14PS = 1261
  /// Compute Approximate Reciprocal of Scalar Float64 Value.
  | VRCP14SD = 1262
  /// Compute Approximate Reciprocal of Scalar Float32 Value.
  | VRCP14SS = 1263
  /// Computes the reciprocal approximation of the float64 values.
  | VRCP28PD = 1264
  /// Computes the reciprocal approximation of the float32 values.
  | VRCP28PS = 1265
  /// Computes the reciprocal approximation of the low float64 value.
  | VRCP28SD = 1266
  /// Computes the reciprocal approximation of the low float32 value.
  | VRCP28SS = 1267
  /// Compute reciprocals of packed single-precision floating-point values.
  | VRCPPS = 1268
  /// Compute Reciprocal of Scalar Single-Precision Floating-Point Values.
  | VRCPSS = 1269
  /// Perform Reduction Transformation on Packed Float64 Values.
  | VREDUCEPD = 1270
  /// Perform Reduction Transformation on Packed Float32 Values.
  | VREDUCEPS = 1271
  /// Perform a Reduction Transformation on a Scalar Float64 Value.
  | VREDUCESD = 1272
  /// Perform a Reduction Transformation on a Scalar Float32 Value.
  | VREDUCESS = 1273
  /// Round Packed Float64 Values To Include A Given Number Of Fraction Bits.
  | VRNDSCALEPD = 1274
  /// Round Packed Float32 Values To Include A Given Number Of Fraction Bits.
  | VRNDSCALEPS = 1275
  /// Round Scalar Float64 Value To Include A Given Number Of Fraction Bits.
  | VRNDSCALESD = 1276
  /// Round Scalar Float32 Value To Include A Given Number Of Fraction Bits.
  | VRNDSCALESS = 1277
  /// Round Packed Double-Precision Values.
  | VROUNDPD = 1278
  /// Round Packed Single-Precision Values.
  | VROUNDPS = 1279
  /// Round Scalar Double-Precision Value.
  | VROUNDSD = 1280
  /// Round Scalar Single-Precision Value.
  | VROUNDSS = 1281
  /// Compute Approximate Reciprocals of Square Roots of Packed Float64 Values.
  | VRSQRT14PD = 1282
  /// Compute Approximate Reciprocals of Square Roots of Packed Float32 Values.
  | VRSQRT14PS = 1283
  /// Compute Approximate Reciprocal of Square Root of Scalar Float64 Value.
  | VRSQRT14SD = 1284
  /// Compute Approximate Reciprocal of Square Root of Scalar Float32 Value.
  | VRSQRT14SS = 1285
  /// Computes the reciprocal square root of the float64 values.
  | VRSQRT28PD = 1286
  /// Computes the reciprocal square root of the float32 values.
  | VRSQRT28PS = 1287
  /// Computes the reciprocal square root of the low float64 value.
  | VRSQRT28SD = 1288
  /// Computes the reciprocal square root of the low float32 value.
  | VRSQRT28SS = 1289
  /// Compute Reciprocals of Square Roots of Packed Single-Precision FP Values.
  | VRSQRTPS = 1290
  /// Compute Reciprocal of Square Root of Scalar Single-Precision FP Value.
  | VRSQRTSS = 1291
  /// Scale Packed Float64 Values With Float64 Values.
  | VSCALEFPD = 1292
  /// Scale Packed Float32 Values With Float32 Values.
  | VSCALEFPS = 1293
  /// Scale Scalar Float64 Values With Float64 Values.
  | VSCALEFSD = 1294
  /// Scale Scalar Float32 Value With Float32 Value.
  | VSCALEFSS = 1295
  /// Multiply packed DP FP elements of a vector by powers.
  | VSCALEPD = 1296
  /// Multiply packed SP FP elements of a vector by powers.
  | VSCALEPS = 1297
  /// Multiply the low DP FP element of a vector by powers.
  | VSCALESD = 1298
  /// Multiply the low SP FP element of a vector by powers.
  | VSCALESS = 1299
  /// Scatter SP/DP FP elements in a vector to memory using dword indices.
  | VSCATTERDD = 1300
  /// Scatter packed double with signed dword indices.
  | VSCATTERDPD = 1301
  /// Scatter packed single with signed dword indices.
  | VSCATTERDPS = 1302
  /// Scatter SP/DP FP elements in a vector to memory using dword indices.
  | VSCATTERDQ = 1303
  /// Sparse prefetch packed DP FP with T0 hint to write using dword indices.
  | VSCATTERPF0DPD = 1304
  /// Sparse prefetch packed SP FP with T0 hint to write using dword indices.
  | VSCATTERPF0DPS = 1305
  /// Sparse prefetch packed DP FP with T0 hint to write using qword indices.
  | VSCATTERPF0QPD = 1306
  /// Sparse prefetch packed SP FP with T0 hint to write using qword indices.
  | VSCATTERPF0QPS = 1307
  /// Sparse prefetch packed DP FP with T1 hint to write using dword indices.
  | VSCATTERPF1DPD = 1308
  /// Sparse prefetch packed SP FP with T1 hint to write using dword indices.
  | VSCATTERPF1DPS = 1309
  /// Sparse prefetch packed DP FP with T1 hint to write using qword indices.
  | VSCATTERPF1QPD = 1310
  /// Sparse prefetch packed SP FP with T1 hint to write using qword indices.
  | VSCATTERPF1QPS = 1311
  /// Scatter SP/DP FP elements in a vector to memory using qword indices.
  | VSCATTERQD = 1312
  /// Scatter packed double with signed qword indices.
  | VSCATTERQPD = 1313
  /// Scatter packed single with signed qword indices.
  | VSCATTERQPS = 1314
  /// Scatter SP/DP FP elements in a vector to memory using qword indices.
  | VSCATTERQQ = 1315
  /// Shuffle 128-bit lanes of a vector with 32 bit granular conditional update.
  | VSHUFF32X4 = 1316
  /// Shuffle 128-bit lanes of a vector with 64 bit granular conditional update.
  | VSHUFF64X2 = 1317
  /// Shuffle 128-bit lanes of a vector with 32 bit granular conditional update.
  | VSHUFI32X4 = 1318
  /// Shuffle 128-bit lanes of a vector with 64 bit granular conditional update.
  | VSHUFI64X2 = 1319
  /// Shuffle Packed Double-Precision Floating-Point Values.
  | VSHUFPD = 1320
  /// Shuffle Packed Single-Precision Floating-Point Values.
  | VSHUFPS = 1321
  /// Compute packed square roots of packed double-precision FP values.
  | VSQRTPD = 1322
  /// Compute square roots of packed single-precision floating-point values.
  | VSQRTPS = 1323
  /// Compute scalar square root of scalar double-precision FP values.
  | VSQRTSD = 1324
  /// Compute square root of scalar single-precision floating-point values.
  | VSQRTSS = 1325
  /// Subtract Packed Double-Precision Floating-Point Values.
  | VSUBPD = 1326
  /// Subtract Packed Single-Precision Floating-Point Values.
  | VSUBPS = 1327
  /// Subtract Scalar Double-Precision Floating-Point Values.
  | VSUBSD = 1328
  /// Subtract Scalar Single-Precision Floating-Point Values.
  | VSUBSS = 1329
  /// Unordered Compare Scalar Double-Precision FP Values and Set EFLAGS.
  | VUCOMISD = 1330
  /// Unordered Compare Scalar Single-Precision FPValues and Set EFLAGS.
  | VUCOMISS = 1331
  /// Unpack and Interleave High Packed Double-Precision Floating-Point Values.
  | VUNPCKHPD = 1332
  /// Unpack and Interleave High Packed Single-Precision Floating-Point Values.
  | VUNPCKHPS = 1333
  /// Unpack and Interleave Low Packed Double-Precision Floating-Point Values.
  | VUNPCKLPD = 1334
  /// Unpack and Interleave Low Packed Single-Precision Floating-Point Values.
  | VUNPCKLPS = 1335
  /// Bitwise Logical XOR for Double-Precision Floating-Point Values.
  | VXORPD = 1336
  /// Bitwise Logical XOR for Single-Precision Floating-Point Values.
  | VXORPS = 1337
  /// Zero Upper Bits of YMM Registers.
  | VZEROUPPER = 1338
  /// Wait.
  | WAIT = 1339
  /// Write Back and Invalidate Cache.
  | WBINVD = 1340
  /// Write FS Segment Base.
  | WRFSBASE = 1341
  /// Write GS Segment Base.
  | WRGSBASE = 1342
  /// Write to Model Specific Register.
  | WRMSR = 1343
  /// Write Data to User Page Key Register.
  | WRPKRU = 1344
  /// Write to a shadow stack.
  | WRSSD = 1345
  /// Write to a shadow stack.
  | WRSSQ = 1346
  /// Write to a user mode shadow stack.
  | WRUSSD = 1347
  /// Write to a user mode shadow stack.
  | WRUSSQ = 1348
  /// Transactional Abort.
  | XABORT = 1349
  /// Prefix hint to the beginning of an HLE transaction region.
  | XACQUIRE = 1350
  /// Exchange and Add.
  | XADD = 1351
  /// Transactional Begin.
  | XBEGIN = 1352
  /// Exchange Register/Memory with Register.
  | XCHG = 1353
  /// Transactional End.
  | XEND = 1354
  /// Value of Extended Control Register.
  | XGETBV = 1355
  /// Table lookup translation.
  | XLAT = 1356
  /// Table Look-up Translation.
  | XLATB = 1357
  /// Logical Exclusive OR.
  | XOR = 1358
  /// Bitwise Logical XOR for Double-Precision Floating-Point Values.
  | XORPD = 1359
  /// Bitwise Logical XOR for Single-Precision Floating-Point Values.
  | XORPS = 1360
  /// Prefix hint to the end of an HLE transaction region.
  | XRELEASE = 1361
  /// Restore Processor Extended States.
  | XRSTOR = 1362
  /// Restore processor supervisor-mode extended states from memory.
  | XRSTORS = 1363
  /// Restore processor supervisor-mode extended states from memory.
  | XRSTORS64 = 1364
  /// Save Processor Extended States.
  | XSAVE = 1365
  /// Save processor extended states with compaction to memory.
  | XSAVEC = 1366
  /// Save processor extended states with compaction to memory.
  | XSAVEC64 = 1367
  /// Save Processor Extended States Optimized.
  | XSAVEOPT = 1368
  /// Save processor supervisor-mode extended states to memory.
  | XSAVES = 1369
  /// Save processor supervisor-mode extended states to memory.
  | XSAVES64 = 1370
  /// Set Extended Control Register.
  | XSETBV = 1371
  /// Test If In Transactional Execution.
  | XTEST = 1372
  /// Invalid Opcode.
  | InvalOP = 1373

// vim: set tw=80 sts=2 sw=2:

IntelOperands.fs
//这段代码定义了Intel体系结构指令操作数解析逻辑。
//主要功能包括:
//1. 定义操作数解析器OperandParser及其各种派生类,每个类对应一种操作数格式。
//2. 定义操作数类型,如寄存器表达式OprReg、内存表达式OprMem等。
//3. 提供各类辅助函数,如解析寄存器、立即数、内存等。
//4. 每个派生类实现具体的操作数解析逻辑。
//运算流程:
//1. 根据机器码特征构建ReadHelper对象,包含读取上下文。
//2. 选择对应的OperandParser实现类。 
//3. 解析寄存器、立即数等子表达式。
//4. 构建操作数对象,如OprReg、OprMem等。
//5. 返回解析结果,如OneOperand、TwoOperands等。
//所以这个模块定义了Intel体系结构完整的操作数解析流程,将机器码字节流解析为抽象的操作数树形表示。
//它与前端解码模块配合,实现从机器码到中间语言的转换,为后续分析提供数据结构支持。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.Intel.RegGroup
open B2R2.FrontEnd.BinLifter.Intel.Helper

/// Operand descriptor, which describes the shape of operands in an instruction.
type OprDesc =
  | RmGpr = 0
  | RmSeg = 1
  | GprCtrl = 2
  | GprDbg = 3
  | RMMmx = 4
  | MmMmx = 5
  | BmBnd = 6
  | RmBnd = 7
  | GprRm = 8
  | GprM = 9
  | MGpr = 10
  | SegRm = 11
  | BndBm = 12
  | BndRm = 13
  | CtrlGpr = 14
  | DbgGpr = 15
  | MmxRm = 16
  | MmxMm = 17
  | GprRMm = 18
  | RegImm8 = 19
  | Imm8Reg = 20
  | Imm8 = 21
  | Imm16 = 22
  | RegImm = 23
  | SImm8 = 24
  | Imm = 25
  | Es = 26
  | Cs = 27
  | Ss = 28
  | Ds = 29
  | Fs = 30
  | Gs = 31
  | ALDx = 32
  | EaxDx = 33
  | DxEax = 34
  | DxAL = 35
  | No = 36
  | Eax = 37
  | Ecx = 38
  | Edx = 39
  | Ebx = 40
  | Esp = 41
  | Ebp = 42
  | Esi = 43
  | Edi = 44
  | Rax = 45
  | Rcx = 46
  | Rdx = 47
  | Rbx = 48
  | Rsp = 49
  | Rbp = 50
  | Rsi = 51
  | Rdi = 52
  | RaxRax = 53
  | RaxRcx = 54
  | RaxRdx = 55
  | RaxRbx = 56
  | RaxRsp = 57
  | RaxRbp = 58
  | RaxRsi = 59
  | RaxRdi = 60
  | GprRmImm8 = 61
  | GprRmImm = 62
  | Rel8 = 63
  | Rel = 64
  | Dir = 65
  | RaxFar = 66
  | FarRax = 67
  | ALImm8 = 68
  | CLImm8 = 69
  | DLImm8 = 70
  | BLImm8 = 71
  | AhImm8 = 72
  | ChImm8 = 73
  | DhImm8 = 74
  | BhImm8 = 75
  | RaxImm = 76
  | RcxImm = 77
  | RdxImm = 78
  | RbxImm = 79
  | RspImm = 80
  | RbpImm = 81
  | RsiImm = 82
  | RdiImm = 83
  | ImmImm = 84
  | RmImm = 85
  | RmImm8 = 86
  | MmxImm8 = 87
  | Mem = 88
  | M1 = 89
  | RmCL = 90
  | XmmVvXm = 91
  | GprVvRm = 92
  | XmVvXmm = 93
  | Gpr = 94
  | RmXmmImm8 = 95
  | XmmRmImm8 = 96
  | MmxMmImm8 = 97
  | MmxRmImm8 = 98
  | GprMmxImm8 = 99
  | XmmVvXmImm8 = 100
  | XmmVvXmXmm = 101
  | XmRegImm8 = 102
  | GprRmVv = 103
  | VvRmImm8 = 104
  | RmGprCL = 105
  | XmmXmXmm0 = 106
  | XmmXmVv = 107
  | VvRm = 108
  | GprRmImm8Imm8 = 109
  | RmImm8Imm8 = 110
  | KnVvXm = 111
  | GprKn = 112
  | KnVvXmImm8 = 113
  | KnGpr = 114

module internal OperandParsingHelper =
  /// Find a specific reg. The bitmask will be used to extract a specific REX
  /// bit (R/X/B).
  let inline private findReg sz rex bitmask (n: int) =
    let r = int (grpEAX sz) + n
    let r =
      if rex = REXPrefix.NOREX then r
      else
        if (int rex &&& bitmask) > 0 then r + 8
        elif sz > 8<rt> || ((n &&& 4) = 0) then r
        else r + 12
    LanguagePrimitives.EnumOfValue<int, Register> r

  /// Registers defined by the SIB index field.
  let findRegSIBIdx sz rex (n: int) = findReg sz rex 2 n

  /// Registers defined by the SIB base field, or base registers defined by the
  /// RM field (first three rows of Table 2-2), or registers defined by REG bit
  /// of the opcode, which can change the symbol by REX bits.
  let findRegRmAndSIBBase sz rex (n: int) = findReg sz rex 1 n

  /// Registers defined by REG field of the ModR/M byte.
  let findRegRBits sz rex (n: int): Register = findReg sz rex 4 n

  /// Registers defined by REG bit of the opcode: some instructions such as PUSH
  /// make use of its opcode to represent the REG bit. REX bits *cannot* change
  /// the symbol.
  let findRegNoREX sz rex (n: int): Register =
    let r = int (grpEAX sz) + n
    let r =
      if rex = REXPrefix.NOREX then r
      else
        if sz > 8<rt> || ((n &&& 4) = 0) then r
        else r + 12
    LanguagePrimitives.EnumOfValue<int, Register> r

  let inline getOprFromRegGrpNoREX rgrp (rhlp: ReadHelper) =
    findRegNoREX rhlp.RegSize rhlp.REXPrefix rgrp |> OprReg

  let inline getOprFromRegGrpREX rgrp (rhlp: ReadHelper) =
    findRegRmAndSIBBase rhlp.RegSize rhlp.REXPrefix rgrp |> OprReg

  let parseSignedImm span (rhlp: ReadHelper) = function
    | 1 -> rhlp.ReadInt8 span |> int64
    | 2 -> rhlp.ReadInt16 span |> int64
    | 4 -> rhlp.ReadInt32 span |> int64
    | 8 -> rhlp.ReadInt64 span
    | _ -> raise ParsingFailureException

  let parseUnsignedImm span (rhlp: ReadHelper) = function
    | 1 -> rhlp.ReadUInt8 span |> uint64
    | 2 -> rhlp.ReadUInt16 span |> uint64
    | 4 -> rhlp.ReadUInt32 span |> uint64
    | 8 -> rhlp.ReadUInt64 span
    | _ -> raise ParsingFailureException

  /// EVEX uses compressed displacement. See the manual Chap. 15 of Vol. 1.
  let compressDisp vInfo disp =
    match vInfo with
    | None -> disp
    | Some { VectorLength = 128<rt>; VEXType = t }
      when t &&& VEXType.EVEX = VEXType.EVEX -> disp * 16L
    | Some { VectorLength = 256<rt>; VEXType = t }
        when t &&& VEXType.EVEX = VEXType.EVEX -> disp * 32L
    | Some { VectorLength = 512<rt>; VEXType = t }
        when t &&& VEXType.EVEX = VEXType.EVEX -> disp * 64L
    | _ -> disp

  let parseOprMem span (rhlp: ReadHelper) b s dispSz =
    let memSz = rhlp.MemEffOprSize
    if dispSz = 0 then OprMem (b, s, None, memSz)
    else
#if LCACHE
      rhlp.MarkHashEnd ()
#endif
      let disp = parseSignedImm span rhlp dispSz
      let disp = compressDisp rhlp.VEXInfo disp
      OprMem (b, s, Some disp, memSz)

  let parseOprImm span (rhlp: ReadHelper) immSize =
#if LCACHE
    rhlp.MarkHashEnd ()
#endif
    let imm = parseUnsignedImm span rhlp (RegType.toByteWidth immSize)
    OprImm (int64 imm, immSize)

  let parseOprSImm span (rhlp: ReadHelper) immSize =
#if LCACHE
    rhlp.MarkHashEnd ()
#endif
    let imm = parseSignedImm span rhlp (RegType.toByteWidth immSize)
    OprImm (imm, immSize)

  /// The first 24 rows of Table 2-1. of the manual Vol. 2A.
  /// The index of this tbl is a number that is a concatenation of (mod) and
  /// (r/m) field of the ModR/M byte. Each element is a tuple of base register,
  /// scaled index register, and the size of the displacement.
  /// Table for scales (of SIB). This tbl is indexbed by the scale value of SIB.
  let parseMEM16 span rhlp modRM =
    let m = getMod modRM
    let rm = getRM modRM
    match (m <<< 3) ||| rm with (* Concatenation of mod and rm bit *)
    | 0 -> parseOprMem span rhlp (Some R.BX) (Some (R.SI, Scale.X1)) 0
    | 1 -> parseOprMem span rhlp (Some R.BX) (Some (R.DI, Scale.X1)) 0
    | 2 -> parseOprMem span rhlp (Some R.BP) (Some (R.SI, Scale.X1)) 0
    | 3 -> parseOprMem span rhlp (Some R.BP) (Some (R.DI, Scale.X1)) 0
    | 4 -> parseOprMem span rhlp (Some R.SI) None 0
    | 5 -> parseOprMem span rhlp (Some R.DI) None 0
    | 6 -> parseOprMem span rhlp None None 2
    | 7 -> parseOprMem span rhlp (Some R.BX) None 0
    (* Mod 01b *)
    | 8 -> parseOprMem span rhlp (Some R.BX) (Some (R.SI, Scale.X1)) 1
    | 9 -> parseOprMem span rhlp (Some R.BX) (Some (R.DI, Scale.X1)) 1
    | 10 -> parseOprMem span rhlp (Some R.BP) (Some (R.SI, Scale.X1)) 1
    | 11 -> parseOprMem span rhlp (Some R.BP) (Some (R.DI, Scale.X1)) 1
    | 12 -> parseOprMem span rhlp (Some R.SI) None 1
    | 13 -> parseOprMem span rhlp (Some R.DI) None 1
    | 14 -> parseOprMem span rhlp (Some R.BP) None 1
    | 15 -> parseOprMem span rhlp (Some R.BX) None 1
    (* Mod 10b *)
    | 16 -> parseOprMem span rhlp (Some R.BX) (Some (R.SI, Scale.X1)) 2
    | 17 -> parseOprMem span rhlp (Some R.BX) (Some (R.DI, Scale.X1)) 2
    | 18 -> parseOprMem span rhlp (Some R.BP) (Some (R.SI, Scale.X1)) 2
    | 19 -> parseOprMem span rhlp (Some R.BP) (Some (R.DI, Scale.X1)) 2
    | 20 -> parseOprMem span rhlp (Some R.SI) None 2
    | 21 -> parseOprMem span rhlp (Some R.DI) None 2
    | 22 -> parseOprMem span rhlp (Some R.BP) None 2
    | 23 -> parseOprMem span rhlp (Some R.BX) None 2
    | _ -> raise ParsingFailureException

  let inline hasREXX rexPref = rexPref &&& REXPrefix.REXX = REXPrefix.REXX

  let getScaledIndex s i (rhlp: ReadHelper) =
    let rexPref = rhlp.REXPrefix
    (* Handling a special case with REXX and SIB index = 0b100 (ESP) *)
    if i = 0b100 && (not <| hasREXX rexPref) then None
    else
      let r = findRegSIBIdx rhlp.MemEffAddrSize rexPref i
      Some (r, LanguagePrimitives.EnumOfValue<int, Scale> (1 <<< s))

  /// See Notes 1 of Table 2-3 of the manual Vol. 2A
  let getSIBBaseReg b (rhlp: ReadHelper) modVal =
    let rexPref = rhlp.REXPrefix
    if b = int RegGrp.RG5 && modVal = 0b00uy then None
    else Some (findRegRmAndSIBBase rhlp.MemEffAddrSize rexPref b)

  let inline private getSIB b =
    struct ((b >>> 6) &&& 0b11, (b >>> 3) &&& 0b111, b &&& 0b111)

  let parseSIB span (rhlp: ReadHelper) modVal =
    let struct (s, i, b) = rhlp.ReadByte span |> int |> getSIB
    let si = getScaledIndex s i rhlp
    let baseReg = getSIBBaseReg b rhlp modVal
    struct (si, baseReg, b)

  let baseRMReg (rhlp: ReadHelper) regGrp =
    findRegRmAndSIBBase rhlp.MemEffAddrSize rhlp.REXPrefix (int regGrp) |> Some

  let sibWithDisp span (rhlp: ReadHelper) b si dispSz oprSz =
    let vInfo = rhlp.VEXInfo
#if LCACHE
    rhlp.MarkHashEnd ()
#endif
    let disp = parseSignedImm span rhlp dispSz
    let disp = compressDisp vInfo disp
    OprMem (b, si, Some disp, oprSz)

  let parseOprMemWithSIB span rhlp modVal dispSz =
    let struct (si, b, bgrp) = parseSIB span rhlp modVal
    let oprSize = rhlp.MemEffOprSize
    if dispSz > 0 then sibWithDisp span rhlp b si dispSz oprSize
    else
      if (modVal = 0b00000000uy || modVal = 0b10000000uy)
        && bgrp = int RegGrp.RG5 then
        sibWithDisp span rhlp b si 4 oprSize
      elif modVal = 0b01000000uy && bgrp = int RegGrp.RG5 then
        sibWithDisp span rhlp b si 1 oprSize
      else OprMem (b, si, None, oprSize)

  /// RIP-relative addressing (see Section 2.2.1.6. of Vol. 2A).
  let parseOprRIPRelativeMem span (rhlp: ReadHelper) disp =
    if rhlp.WordSize = WordSize.Bit64 then
      if hasAddrSz rhlp.Prefixes then
        parseOprMem span rhlp (Some R.EIP) None disp
      else parseOprMem span rhlp (Some R.RIP) None disp
    else parseOprMem span rhlp None None disp

  open type RegGrp

  /// The first 24 rows of Table 2-2. of the manual Vol. 2A.
  /// The index of this tbl is a number that is a concatenation of (mod) and
  /// (r/m) field of the ModR/M byte. Each element is a tuple of (MemLookupType,
  /// and the size of the displacement). If the first value of the tuple (register
  /// group) is None, it means we need to look up the SIB tbl (Table 2-3). If
  /// not, then it represents the reg group of the base reigster.
  let parseMEM32 span rhlp modRM =
    let modVal = modRM &&& 0b11000000uy
    match modVal >>> 3 ||| (modRM &&& 0b00000111uy) with
    (* Mod 00b *)
    | 0uy -> parseOprMem span rhlp (baseRMReg rhlp RG0) None 0
    | 1uy -> parseOprMem span rhlp (baseRMReg rhlp RG1) None 0
    | 2uy -> parseOprMem span rhlp (baseRMReg rhlp RG2) None 0
    | 3uy -> parseOprMem span rhlp (baseRMReg rhlp RG3) None 0
    | 4uy -> parseOprMemWithSIB span rhlp modVal 0
    | 5uy -> parseOprRIPRelativeMem span rhlp 4
    | 6uy -> parseOprMem span rhlp (baseRMReg rhlp RG6) None 0
    | 7uy -> parseOprMem span rhlp (baseRMReg rhlp RG7) None 0
    (* Mod 01b *)
    | 8uy -> parseOprMem span rhlp (baseRMReg rhlp RG0) None 1
    | 9uy -> parseOprMem span rhlp (baseRMReg rhlp RG1) None 1
    | 10uy -> parseOprMem span rhlp (baseRMReg rhlp RG2) None 1
    | 11uy -> parseOprMem span rhlp (baseRMReg rhlp RG3) None 1
    | 12uy -> parseOprMemWithSIB span rhlp modVal 1
    | 13uy -> parseOprMem span rhlp (baseRMReg rhlp RG5) None 1
    | 14uy -> parseOprMem span rhlp (baseRMReg rhlp RG6) None 1
    | 15uy -> parseOprMem span rhlp (baseRMReg rhlp RG7) None 1
    (* Mod 10b *)
    | 16uy -> parseOprMem span rhlp (baseRMReg rhlp RG0) None 4
    | 17uy -> parseOprMem span rhlp (baseRMReg rhlp RG1) None 4
    | 18uy -> parseOprMem span rhlp (baseRMReg rhlp RG2) None 4
    | 19uy -> parseOprMem span rhlp (baseRMReg rhlp RG3) None 4
    | 20uy -> parseOprMemWithSIB span rhlp modVal 4
    | 21uy -> parseOprMem span rhlp (baseRMReg rhlp RG5) None 4
    | 22uy -> parseOprMem span rhlp (baseRMReg rhlp RG6) None 4
    | 23uy -> parseOprMem span rhlp (baseRMReg rhlp RG7) None 4
    | _ -> raise ParsingFailureException

  let parseMemory modRM span (rhlp: ReadHelper) =
    if rhlp.MemEffAddrSize = 16<rt> then parseMEM16 span rhlp modRM
    else parseMEM32 span rhlp modRM

  let parseMemOrReg modRM span (rhlp: ReadHelper) =
    if modRM &&& 0b11000000uy = 0b11000000uy then
      findRegRmAndSIBBase rhlp.MemEffRegSize rhlp.REXPrefix (getRM modRM)
      |> OprReg
    else parseMemory modRM span rhlp

  let parseVVVVReg (rhlp: ReadHelper) =
    match rhlp.VEXInfo with
    | None -> raise ParsingFailureException
    | Some vInfo when vInfo.VectorLength = 512<rt> ->
      Register.zmm (int vInfo.VVVV) |> OprReg
    | Some vInfo when vInfo.VectorLength = 256<rt> ->
      Register.ymm (int vInfo.VVVV) |> OprReg
    | Some vInfo ->
      Register.xmm (int vInfo.VVVV) |> OprReg

  let parseVEXtoGPR (rhlp: ReadHelper) =
    match rhlp.VEXInfo with
    | None -> raise ParsingFailureException
    | Some vInfo ->
      let grp = (int vInfo.VVVV) &&& 0b111
      int (grpEAX rhlp.RegSize) + grp
      |> LanguagePrimitives.EnumOfValue<int, Register>
      |> OprReg

  let parseMMXReg n =
    Register.mm n |> OprReg

  let parseSegReg n =
    if n < 6 then Register.seg n |> OprReg
    else raise ParsingFailureException

  let parseBoundRegister n =
    Register.bound n |> OprReg

  let parseControlReg n =
    Register.control n |> OprReg

  let parseDebugReg n =
    Register.debug n |> OprReg

  let parseOpMaskReg n =
    Register.opmask n |> OprReg

  let parseOprOnlyDisp span (rhlp: ReadHelper) =
    let dispSz = RegType.toByteWidth rhlp.MemEffAddrSize
    parseOprMem span rhlp None None dispSz

  let getImmZ (rhlp: ReadHelper) =
    if rhlp.MemEffOprSize = 64<rt> || rhlp.MemEffOprSize = 32<rt> then 32<rt>
    else rhlp.MemEffOprSize

  let opGprImm span rhlp regGrp =
    let o1 = getOprFromRegGrpREX (int regGrp) rhlp
    let o2 = parseOprSImm span rhlp rhlp.MemEffOprSize
    TwoOperands (o1, o2)

  let parseOprForRelJmp span (rhlp: ReadHelper) immSz =
#if LCACHE
    rhlp.MarkHashEnd ()
#endif
    let immSz = RegType.toByteWidth immSz
    let offset = parseSignedImm span rhlp immSz
    let relOffset = offset + int64 (rhlp.ParsedLen ())
    OprDirAddr (Relative (relOffset))

open OperandParsingHelper

type internal OpRmGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    TwoOperands (opr1, opr2)

type internal OpRmSeg () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = parseSegReg (getReg modRM)
    TwoOperands (opr1, opr2)

type internal OpGprCtrl () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then raise ParsingFailureException
    else
      let opr1 = parseMemOrReg modRM span rhlp
      let opr2 = parseControlReg (getReg modRM)
      TwoOperands (opr1, opr2)

type internal OpGprDbg () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then raise ParsingFailureException
    else
      let opr1 = parseMemOrReg modRM span rhlp
      let opr2 = parseDebugReg (getReg modRM)
      TwoOperands (opr1, opr2)

type internal OpRMMmx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = parseMMXReg (getReg modRM)
    TwoOperands (opr1, opr2)

type internal OpMmMmx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemory modRM span rhlp
    let opr2 = parseMMXReg (getReg modRM)
    TwoOperands (opr1, opr2)

type internal OpBmBnd () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      if modIsReg modRM then parseBoundRegister (getRM modRM)
      else parseMemory modRM span rhlp
    let opr2 = parseBoundRegister (getReg modRM)
    TwoOperands (opr1, opr2)

type internal OpRmBnd () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = parseBoundRegister (getReg modRM)
    TwoOperands (opr1, opr2)

type internal OpGprRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpGprM () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then
      let opr1 =
        findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
      let opr2 = parseMemory modRM span rhlp
      TwoOperands (opr1, opr2)
    else raise ParsingFailureException

type internal OpMGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then
      let opr1 = parseMemory modRM span rhlp
      let opr2 =
        findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
      TwoOperands (opr1, opr2)
    else raise ParsingFailureException

type internal OpSegRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseSegReg (getReg modRM)
    let opr2 = parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpBndBm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseBoundRegister (getReg modRM)
    let opr2 =
      if modIsReg modRM then parseBoundRegister (getRM modRM)
      else parseMemory modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpBndRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseBoundRegister (getReg modRM)
    let opr2 = parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpCtrlGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then raise ParsingFailureException
    else
      let opr1 = parseControlReg (getReg modRM)
      let opr2 = parseMemOrReg modRM span rhlp
      TwoOperands (opr1, opr2)

type internal OpDbgGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    if modIsMemory modRM then raise ParsingFailureException
    else
      let opr1 = parseDebugReg (getReg modRM)
      let opr2 = parseMemOrReg modRM span rhlp
      TwoOperands (opr1, opr2)

type internal OpMmxRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMMXReg (getReg modRM)
    let opr2 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemory modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpMmxMm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMMXReg (getReg modRM)
    let opr2 = parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpGprRMm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpRegImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpNoREX (int RegGrp.RG0) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpImm8Reg () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = parseOprImm span rhlp 8<rt>
    let o2 = getOprFromRegGrpNoREX (int RegGrp.RG0) rhlp
    TwoOperands (o1, o2)

type internal OpImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprImm span rhlp 8<rt>
    OneOperand opr

type internal OpImm16 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprImm span rhlp 16<rt>
    OneOperand opr

type internal OpRegImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpNoREX (int RegGrp.RG0) rhlp
    let o2 = parseOprSImm span rhlp (getImmZ rhlp)
    TwoOperands (o1, o2)

type internal OpSImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprSImm span rhlp 8<rt>
    OneOperand opr

type internal OpImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprSImm span rhlp (getImmZ rhlp)
    OneOperand opr

type internal OpEs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.ES)

type internal OpCs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.CS)

type internal OpSs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.SS)

type internal OpDs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.DS)

type internal OpFs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.FS)

type internal OpGs () =
  inherit OperandParser ()
  override __.Render (_, _) =
    OneOperand (OprReg R.GS)

type internal OpALDx () =
  inherit OperandParser ()
  override __.Render (_, _) =
    TwoOperands (OprReg R.AL, OprReg R.DX)

type internal OpEaxDx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let reg = if hasOprSz rhlp.Prefixes then R.AX else R.EAX
    TwoOperands (OprReg reg, OprReg R.DX)

type internal OpDxEax () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let reg = if hasOprSz rhlp.Prefixes then R.AX else R.EAX
    TwoOperands (OprReg R.DX, OprReg reg)

type internal OpDxAL () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    TwoOperands (OprReg R.DX, OprReg R.AL)

type internal OpNo () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    NoOperand

type internal OpEax () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    OneOperand o

type internal OpEcx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG1)  rhlp
    OneOperand o

type internal OpEdx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG2)  rhlp
    OneOperand o

type internal OpEbx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG3)  rhlp
    OneOperand o

type internal OpEsp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG4)  rhlp
    OneOperand o

type internal OpEbp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG5)  rhlp
    OneOperand o

type internal OpEsi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG6)  rhlp
    OneOperand o

type internal OpEdi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpNoREX (int RegGrp.RG7)  rhlp
    OneOperand o

type internal OpRax () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG0) rhlp
    OneOperand o

type internal OpRcx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG1) rhlp
    OneOperand o

type internal OpRdx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG2) rhlp
    OneOperand o

type internal OpRbx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG3) rhlp
    OneOperand o

type internal OpRsp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG4) rhlp
    OneOperand o

type internal OpRbp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG5) rhlp
    OneOperand o

type internal OpRsi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG6) rhlp
    OneOperand o

type internal OpRdi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o = getOprFromRegGrpREX (int RegGrp.RG7) rhlp
    OneOperand o

type internal OpRaxRax () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 =
      getOprFromRegGrpREX (int RegGrp.RG0) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRcx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG1) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRdx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 =
      getOprFromRegGrpREX (int RegGrp.RG2) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRbx () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG3) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRsp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG4) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRbp () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG5) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRsi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG6) rhlp
    TwoOperands (o1, o2)

type internal OpRaxRdi () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = getOprFromRegGrpREX (int RegGrp.RG7) rhlp
    TwoOperands (o1, o2)

type internal OpGprRmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let o1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let o2 = parseMemOrReg modRM span rhlp
    let opr3 = parseOprSImm span rhlp 8<rt>
    ThreeOperands (o1, o2, opr3)

type internal OpGprRmImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let o1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let o2 = parseMemOrReg modRM span rhlp
    let opr3 = parseOprSImm span rhlp (getImmZ rhlp)
    ThreeOperands (o1, o2, opr3)

type internal OpRel8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprForRelJmp span rhlp 8<rt>
    OneOperand opr

type internal OpRel () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr = parseOprForRelJmp span rhlp (getImmZ rhlp)
    OneOperand opr

type internal OpDir () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let addrSz = RegType.toByteWidth rhlp.MemEffAddrSize
    let addrValue = parseUnsignedImm span rhlp addrSz
    let selector = rhlp.ReadInt16 span
    let absAddr = Absolute (selector, addrValue, RegType.fromByteWidth addrSz)
    let opr = OprDirAddr absAddr
    OneOperand opr

type internal OpRaxFar () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    let o2 = parseOprOnlyDisp span rhlp
    TwoOperands (o1, o2)

type internal OpFarRax () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = parseOprOnlyDisp span rhlp
    let o2 =
      getOprFromRegGrpNoREX (int RegGrp.RG0)  rhlp
    TwoOperands (o1, o2)

type internal OpALImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG0) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpCLImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG1) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpDLImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG2) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpBLImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG3) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpAhImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG4) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpChImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG5) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpDhImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG6) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpBhImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let o1 = getOprFromRegGrpREX (int RegGrp.RG7) rhlp
    let o2 = parseOprImm span rhlp 8<rt>
    TwoOperands (o1, o2)

type internal OpRaxImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG0

type internal OpRcxImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG1

type internal OpRdxImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG2

type internal OpRbxImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG3

type internal OpRspImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG4

type internal OpRbpImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG5

type internal OpRsiImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG6

type internal OpRdiImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    opGprImm span rhlp RegGrp.RG7

type internal OpImmImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let opr1 = parseOprImm span rhlp 16<rt>
    let opr2 = parseOprImm span rhlp 8<rt>
    TwoOperands (opr1, opr2)

type internal OpRmImm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = parseOprSImm span rhlp (getImmZ rhlp)
    TwoOperands (opr1, opr2)

type internal OpRmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = parseOprSImm span rhlp 8<rt>
    TwoOperands (opr1, opr2)

type internal OpMmxImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemory modRM span rhlp
    let opr2 = parseOprSImm span rhlp 8<rt>
    TwoOperands (opr1, opr2)

type internal OpMem () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr = parseMemOrReg modRM span rhlp
    OneOperand opr

type internal OpM1 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr = parseMemOrReg modRM span rhlp
    TwoOperands (opr, OprImm (1L, 0<rt>))

type internal OpRmCL () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr = parseMemOrReg modRM span rhlp
    TwoOperands (opr, OprReg R.CL)

type internal OpXmmVvXm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr3 = parseMemOrReg modRM span rhlp
    ThreeOperands (opr1, parseVVVVReg rhlp, opr3)

type internal OpGprVvRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseVEXtoGPR rhlp
    let opr3 = parseMemOrReg modRM span rhlp
    ThreeOperands (opr1, opr2, opr3)

type internal OpXmVvXmm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr3 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    ThreeOperands (opr1, parseVVVVReg rhlp, opr3)

type internal OpGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr =
      findRegRmAndSIBBase rhlp.RegSize rhlp.REXPrefix (getRM modRM) |> OprReg
    OneOperand opr

type internal OpRmXmmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpXmmRmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseMemOrReg modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpMmxMmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMMXReg (getReg modRM)
    let opr2 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemory modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpMmxRmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMMXReg (getReg modRM)
    let opr2 = parseMemOrReg modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpGprMmxImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 =
      if modIsReg modRM then parseMMXReg (getRM modRM)
      else parseMemory modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpXmmVvXmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseVVVVReg rhlp
    let opr3 = parseMemOrReg modRM span rhlp
    let opr4 = parseOprImm span rhlp 8<rt>
    FourOperands (opr1, opr2, opr3, opr4)

type internal OpXmmVvXmXmm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseVVVVReg rhlp
    let opr3 = parseMemOrReg modRM span rhlp
    let mask = if rhlp.WordSize = WordSize.Bit32 then 0b0111uy else 0b1111uy
    let imm8 = (rhlp.ReadUInt8 (span) >>> 4) &&& mask |> int (* imm8[7:4] *)
    let opr4 = findRegNoREX rhlp.RegSize rhlp.REXPrefix imm8 |> OprReg
    FourOperands (opr1, opr2, opr3, opr4)

type internal OpXmRegImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpGprRmVv () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseMemOrReg modRM span rhlp
    let opr3 = parseVEXtoGPR rhlp
    ThreeOperands (opr1, opr2, opr3)

type internal OpVvRmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr2 = parseMemOrReg modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (parseVVVVReg rhlp, opr2, opr3)

type internal OpRmGprCL () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseMemOrReg modRM span rhlp
    let opr2 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr3 = Register.CL |> OprReg
    ThreeOperands (opr1, opr2, opr3)

type internal OpXmmXmXmm0 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseMemOrReg modRM span rhlp
    ThreeOperands (opr1, opr2, OprReg R.XMM0)

type internal OpXmmXmVv () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseMemOrReg modRM span rhlp
    ThreeOperands (opr1, opr2, parseVVVVReg rhlp)

type internal OpVvRm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseVEXtoGPR rhlp
    let opr2 = parseMemOrReg modRM span rhlp
    TwoOperands (opr1, opr2)

type internal OpGprRmImm8Imm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 =
      if modIsMemory modRM then raise ParsingFailureException
      else parseMemOrReg modRM span rhlp
    let opr3 = parseOprImm span rhlp 8<rt>
    let opr4 = parseOprImm span rhlp 8<rt>
    FourOperands (opr1, opr2, opr3, opr4)

type internal OpRmImm8Imm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 =
      if modIsMemory modRM then raise ParsingFailureException
      else parseMemOrReg modRM span rhlp
    let opr2 = parseOprImm span rhlp 8<rt>
    let opr3 = parseOprImm span rhlp 8<rt>
    ThreeOperands (opr1, opr2, opr3)

type internal OpKnVvXm () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseOpMaskReg (getReg modRM)
    let opr3 = parseMemOrReg modRM span rhlp
    ThreeOperands (opr1, parseVVVVReg rhlp, opr3)

type internal OpGprKn () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getReg modRM) |> OprReg
    let opr2 = parseOpMaskReg (getRM modRM)
    TwoOperands (opr1, opr2)

type internal OpKnVvXmImm8 () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseOpMaskReg (getReg modRM)
    let opr2 = parseVVVVReg rhlp
    let opr3 = parseMemOrReg modRM span rhlp
    let opr4 = parseOprImm span rhlp 8<rt>
    FourOperands (opr1, opr2, opr3, opr4)

type internal OpKnGpr () =
  inherit OperandParser ()
  override __.Render (span, rhlp) =
    let modRM = rhlp.ReadByte span
    let opr1 = parseOpMaskReg (getReg modRM)
    let opr2 = findRegRBits rhlp.RegSize rhlp.REXPrefix (getRM modRM) |> OprReg
    TwoOperands (opr1, opr2)

IntelParser.fs
//这段代码定义了Intel体系结构指令的解析器:
//-  inheritance自Parser,实现指令解析接口
//-  定义各种操作数、长度计算器和一字节指令解析器
//-  解析前缀,识别REX前缀和操作模式
//-  根据操作码获取对应一字节指令解析器进行解析
//主要功能:
//1. 实现Intel指令的解析 
//2. 识别并处理前缀信息
//3. 获取对应的解析逻辑进行指令解析
//4. 返回统一的Instruction对象
//优点:
//1. 完整实现了Intel指令集的解析
//2. 将前缀和一字节opcode解耦 
//3. 提供了易于扩展的设计
//4. 对外隐藏体系结构细节
//它针对Intel体系结构定义了专用的指令解析器,完全实现了Intel指令的解析流程。对外提供统一的指令接口,密封体系细节。

namespace B2R2.FrontEnd.BinLifter.Intel

open System
open B2R2
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.Helper
open LanguagePrimitives
open type Prefix

/// Parser for Intel (x86 or x86-64) instructions. Parser will return a
/// platform-agnostic instruction type (Instruction).
type IntelParser (wordSz) =
  inherit Parser ()

  let oparsers =
    [| OpRmGpr () :> OperandParser
       OpRmSeg () :> OperandParser
       OpGprCtrl () :> OperandParser
       OpGprDbg () :> OperandParser
       OpRMMmx () :> OperandParser
       OpMmMmx () :> OperandParser
       OpBmBnd () :> OperandParser
       OpRmBnd () :> OperandParser
       OpGprRm () :> OperandParser
       OpGprM () :> OperandParser
       OpMGpr () :> OperandParser
       OpSegRm () :> OperandParser
       OpBndBm () :> OperandParser
       OpBndRm () :> OperandParser
       OpCtrlGpr () :> OperandParser
       OpDbgGpr () :> OperandParser
       OpMmxRm () :> OperandParser
       OpMmxMm () :> OperandParser
       OpGprRMm () :> OperandParser
       OpRegImm8 () :> OperandParser
       OpImm8Reg () :> OperandParser
       OpImm8 () :> OperandParser
       OpImm16 () :> OperandParser
       OpRegImm () :> OperandParser
       OpSImm8 () :> OperandParser
       OpImm () :> OperandParser
       OpEs () :> OperandParser
       OpCs () :> OperandParser
       OpSs () :> OperandParser
       OpDs () :> OperandParser
       OpFs () :> OperandParser
       OpGs () :> OperandParser
       OpALDx () :> OperandParser
       OpEaxDx () :> OperandParser
       OpDxEax () :> OperandParser
       OpDxAL () :> OperandParser
       OpNo () :> OperandParser
       OpEax () :> OperandParser
       OpEcx () :> OperandParser
       OpEdx () :> OperandParser
       OpEbx () :> OperandParser
       OpEsp () :> OperandParser
       OpEbp () :> OperandParser
       OpEsi () :> OperandParser
       OpEdi () :> OperandParser
       OpRax () :> OperandParser
       OpRcx () :> OperandParser
       OpRdx () :> OperandParser
       OpRbx () :> OperandParser
       OpRsp () :> OperandParser
       OpRbp () :> OperandParser
       OpRsi () :> OperandParser
       OpRdi () :> OperandParser
       OpRaxRax () :> OperandParser
       OpRaxRcx () :> OperandParser
       OpRaxRdx () :> OperandParser
       OpRaxRbx () :> OperandParser
       OpRaxRsp () :> OperandParser
       OpRaxRbp () :> OperandParser
       OpRaxRsi () :> OperandParser
       OpRaxRdi () :> OperandParser
       OpGprRmImm8 () :> OperandParser
       OpGprRmImm () :> OperandParser
       OpRel8 () :> OperandParser
       OpRel () :> OperandParser
       OpDir () :> OperandParser
       OpRaxFar () :> OperandParser
       OpFarRax () :> OperandParser
       OpALImm8 () :> OperandParser
       OpCLImm8 () :> OperandParser
       OpDLImm8 () :> OperandParser
       OpBLImm8 () :> OperandParser
       OpAhImm8 () :> OperandParser
       OpChImm8 () :> OperandParser
       OpDhImm8 () :> OperandParser
       OpBhImm8 () :> OperandParser
       OpRaxImm () :> OperandParser
       OpRcxImm () :> OperandParser
       OpRdxImm () :> OperandParser
       OpRbxImm () :> OperandParser
       OpRspImm () :> OperandParser
       OpRbpImm () :> OperandParser
       OpRsiImm () :> OperandParser
       OpRdiImm () :> OperandParser
       OpImmImm () :> OperandParser
       OpRmImm () :> OperandParser
       OpRmImm8 () :> OperandParser
       OpMmxImm8 () :> OperandParser
       OpMem () :> OperandParser
       OpM1 () :> OperandParser
       OpRmCL () :> OperandParser
       OpXmmVvXm () :> OperandParser
       OpGprVvRm () :> OperandParser
       OpXmVvXmm () :> OperandParser
       OpGpr () :> OperandParser
       OpRmXmmImm8 () :> OperandParser
       OpXmmRmImm8 () :> OperandParser
       OpMmxMmImm8 () :> OperandParser
       OpMmxRmImm8 () :> OperandParser
       OpGprMmxImm8 () :> OperandParser
       OpXmmVvXmImm8 () :> OperandParser
       OpXmmVvXmXmm () :> OperandParser
       OpXmRegImm8 () :> OperandParser
       OpGprRmVv () :> OperandParser
       OpVvRmImm8 () :> OperandParser
       OpRmGprCL () :> OperandParser
       OpXmmXmXmm0 () :> OperandParser
       OpXmmXmVv () :> OperandParser
       OpVvRm () :> OperandParser
       OpGprRmImm8Imm8 () :> OperandParser
       OpRmImm8Imm8 () :> OperandParser
       OpKnVvXm () :> OperandParser
       OpGprKn () :> OperandParser
       OpKnVvXmImm8 () :> OperandParser
       OpKnGpr () :> OperandParser |]

  let szcomputers =
    [| SzByte () :> InsSizeComputer
       SzWord () :> InsSizeComputer
       SzDef () :> InsSizeComputer
       SzVecDef () :> InsSizeComputer
       SzDV () :> InsSizeComputer
       SzD () :> InsSizeComputer
       SzMemW () :> InsSizeComputer
       SzRegW () :> InsSizeComputer
       SzWV () :> InsSizeComputer
       SzD64 () :> InsSizeComputer
       SzPZ () :> InsSizeComputer
       SzDDq () :> InsSizeComputer
       SzDqDq () :> InsSizeComputer
       SzDqdDq () :> InsSizeComputer
       SzDqdDqMR () :> InsSizeComputer
       SzDqqDq () :> InsSizeComputer
       SzDqqDqMR () :> InsSizeComputer
       SzXqX () :> InsSizeComputer
       SzDqqDqWS () :> InsSizeComputer
       SzVyDq () :> InsSizeComputer
       SzVyDqMR () :> InsSizeComputer
       SzDY () :> InsSizeComputer
       SzQDq () :> InsSizeComputer
       SzDqqQ () :> InsSizeComputer
       SzDqQ () :> InsSizeComputer
       SzDqdY () :> InsSizeComputer
       SzDqqY () :> InsSizeComputer
       SzDqY () :> InsSizeComputer
       SzDq () :> InsSizeComputer
       SzDQ () :> InsSizeComputer
       SzQQ () :> InsSizeComputer
       SzYQ () :> InsSizeComputer
       SzYQRM () :> InsSizeComputer
       SzDwQ () :> InsSizeComputer
       SzDwDq () :> InsSizeComputer
       SzDwDqMR () :> InsSizeComputer
       SzQD () :> InsSizeComputer
       SzDqd () :> InsSizeComputer
       SzXDq () :> InsSizeComputer
       SzDqX () :> InsSizeComputer
       SzXD () :> InsSizeComputer
       SzDqqdqX () :> InsSizeComputer
       SzDqddqX () :> InsSizeComputer
       SzDqwDq () :> InsSizeComputer
       SzDqwX () :> InsSizeComputer
       SzDqQqq () :> InsSizeComputer
       SzDqbX () :> InsSizeComputer
       SzDbDq () :> InsSizeComputer
       SzBV () :> InsSizeComputer
       SzQ () :> InsSizeComputer
       SzS () :> InsSizeComputer
       SzDX () :> InsSizeComputer
       SzDqdXz () :> InsSizeComputer
       SzDqqX () :> InsSizeComputer
       SzP () :> InsSizeComputer
       SzPRM () :> InsSizeComputer
       SzXqXz () :> InsSizeComputer
       SzXXz () :> InsSizeComputer
       SzXzX () :> InsSizeComputer
       SzXzXz () :> InsSizeComputer
       SzDqqQq () :> InsSizeComputer
       SzDqqXz () :> InsSizeComputer
       SzQqXz () :> InsSizeComputer
       SzQqXzRM () :> InsSizeComputer
       SzDqdX () :> InsSizeComputer
       SzDXz () :> InsSizeComputer
       SzQXz () :> InsSizeComputer
       SzDqQq () :> InsSizeComputer
       SzDqXz () :> InsSizeComputer
       SzYDq () :> InsSizeComputer
       SzQq () :> InsSizeComputer
       SzDqwdX () :> InsSizeComputer
       SzY () :> InsSizeComputer |]

  let oneByteParsers =
    [| OneOp00 () :> ParsingJob
       OneOp01 () :> ParsingJob
       OneOp02 () :> ParsingJob
       OneOp03 () :> ParsingJob
       OneOp04 () :> ParsingJob
       OneOp05 () :> ParsingJob
       OneOp06 () :> ParsingJob
       OneOp07 () :> ParsingJob
       OneOp08 () :> ParsingJob
       OneOp09 () :> ParsingJob
       OneOp0A () :> ParsingJob
       OneOp0B () :> ParsingJob
       OneOp0C () :> ParsingJob
       OneOp0D () :> ParsingJob
       OneOp0E () :> ParsingJob
       OneOp0F () :> ParsingJob
       OneOp10 () :> ParsingJob
       OneOp11 () :> ParsingJob
       OneOp12 () :> ParsingJob
       OneOp13 () :> ParsingJob
       OneOp14 () :> ParsingJob
       OneOp15 () :> ParsingJob
       OneOp16 () :> ParsingJob
       OneOp17 () :> ParsingJob
       OneOp18 () :> ParsingJob
       OneOp19 () :> ParsingJob
       OneOp1A () :> ParsingJob
       OneOp1B () :> ParsingJob
       OneOp1C () :> ParsingJob
       OneOp1D () :> ParsingJob
       OneOp1E () :> ParsingJob
       OneOp1F () :> ParsingJob
       OneOp20 () :> ParsingJob
       OneOp21 () :> ParsingJob
       OneOp22 () :> ParsingJob
       OneOp23 () :> ParsingJob
       OneOp24 () :> ParsingJob
       OneOp25 () :> ParsingJob
       OneOp26 () :> ParsingJob
       OneOp27 () :> ParsingJob
       OneOp28 () :> ParsingJob
       OneOp29 () :> ParsingJob
       OneOp2A () :> ParsingJob
       OneOp2B () :> ParsingJob
       OneOp2C () :> ParsingJob
       OneOp2D () :> ParsingJob
       OneOp2E () :> ParsingJob
       OneOp2F () :> ParsingJob
       OneOp30 () :> ParsingJob
       OneOp31 () :> ParsingJob
       OneOp32 () :> ParsingJob
       OneOp33 () :> ParsingJob
       OneOp34 () :> ParsingJob
       OneOp35 () :> ParsingJob
       OneOp36 () :> ParsingJob
       OneOp37 () :> ParsingJob
       OneOp38 () :> ParsingJob
       OneOp39 () :> ParsingJob
       OneOp3A () :> ParsingJob
       OneOp3B () :> ParsingJob
       OneOp3C () :> ParsingJob
       OneOp3D () :> ParsingJob
       OneOp3E () :> ParsingJob
       OneOp3F () :> ParsingJob
       OneOp40 () :> ParsingJob
       OneOp41 () :> ParsingJob
       OneOp42 () :> ParsingJob
       OneOp43 () :> ParsingJob
       OneOp44 () :> ParsingJob
       OneOp45 () :> ParsingJob
       OneOp46 () :> ParsingJob
       OneOp47 () :> ParsingJob
       OneOp48 () :> ParsingJob
       OneOp49 () :> ParsingJob
       OneOp4A () :> ParsingJob
       OneOp4B () :> ParsingJob
       OneOp4C () :> ParsingJob
       OneOp4D () :> ParsingJob
       OneOp4E () :> ParsingJob
       OneOp4F () :> ParsingJob
       OneOp50 () :> ParsingJob
       OneOp51 () :> ParsingJob
       OneOp52 () :> ParsingJob
       OneOp53 () :> ParsingJob
       OneOp54 () :> ParsingJob
       OneOp55 () :> ParsingJob
       OneOp56 () :> ParsingJob
       OneOp57 () :> ParsingJob
       OneOp58 () :> ParsingJob
       OneOp59 () :> ParsingJob
       OneOp5A () :> ParsingJob
       OneOp5B () :> ParsingJob
       OneOp5C () :> ParsingJob
       OneOp5D () :> ParsingJob
       OneOp5E () :> ParsingJob
       OneOp5F () :> ParsingJob
       OneOp60 () :> ParsingJob
       OneOp61 () :> ParsingJob
       OneOp62 () :> ParsingJob
       OneOp63 () :> ParsingJob
       OneOp64 () :> ParsingJob
       OneOp65 () :> ParsingJob
       OneOp66 () :> ParsingJob
       OneOp67 () :> ParsingJob
       OneOp68 () :> ParsingJob
       OneOp69 () :> ParsingJob
       OneOp6A () :> ParsingJob
       OneOp6B () :> ParsingJob
       OneOp6C () :> ParsingJob
       OneOp6D () :> ParsingJob
       OneOp6E () :> ParsingJob
       OneOp6F () :> ParsingJob
       OneOp70 () :> ParsingJob
       OneOp71 () :> ParsingJob
       OneOp72 () :> ParsingJob
       OneOp73 () :> ParsingJob
       OneOp74 () :> ParsingJob
       OneOp75 () :> ParsingJob
       OneOp76 () :> ParsingJob
       OneOp77 () :> ParsingJob
       OneOp78 () :> ParsingJob
       OneOp79 () :> ParsingJob
       OneOp7A () :> ParsingJob
       OneOp7B () :> ParsingJob
       OneOp7C () :> ParsingJob
       OneOp7D () :> ParsingJob
       OneOp7E () :> ParsingJob
       OneOp7F () :> ParsingJob
       OneOp80 () :> ParsingJob
       OneOp81 () :> ParsingJob
       OneOp82 () :> ParsingJob
       OneOp83 () :> ParsingJob
       OneOp84 () :> ParsingJob
       OneOp85 () :> ParsingJob
       OneOp86 () :> ParsingJob
       OneOp87 () :> ParsingJob
       OneOp88 () :> ParsingJob
       OneOp89 () :> ParsingJob
       OneOp8A () :> ParsingJob
       OneOp8B () :> ParsingJob
       OneOp8C () :> ParsingJob
       OneOp8D () :> ParsingJob
       OneOp8E () :> ParsingJob
       OneOp8F () :> ParsingJob
       OneOp90 () :> ParsingJob
       OneOp91 () :> ParsingJob
       OneOp92 () :> ParsingJob
       OneOp93 () :> ParsingJob
       OneOp94 () :> ParsingJob
       OneOp95 () :> ParsingJob
       OneOp96 () :> ParsingJob
       OneOp97 () :> ParsingJob
       OneOp98 () :> ParsingJob
       OneOp99 () :> ParsingJob
       OneOp9A () :> ParsingJob
       OneOp9B () :> ParsingJob
       OneOp9C () :> ParsingJob
       OneOp9D () :> ParsingJob
       OneOp9E () :> ParsingJob
       OneOp9F () :> ParsingJob
       OneOpA0 () :> ParsingJob
       OneOpA1 () :> ParsingJob
       OneOpA2 () :> ParsingJob
       OneOpA3 () :> ParsingJob
       OneOpA4 () :> ParsingJob
       OneOpA5 () :> ParsingJob
       OneOpA6 () :> ParsingJob
       OneOpA7 () :> ParsingJob
       OneOpA8 () :> ParsingJob
       OneOpA9 () :> ParsingJob
       OneOpAA () :> ParsingJob
       OneOpAB () :> ParsingJob
       OneOpAC () :> ParsingJob
       OneOpAD () :> ParsingJob
       OneOpAE () :> ParsingJob
       OneOpAF () :> ParsingJob
       OneOpB0 () :> ParsingJob
       OneOpB1 () :> ParsingJob
       OneOpB2 () :> ParsingJob
       OneOpB3 () :> ParsingJob
       OneOpB4 () :> ParsingJob
       OneOpB5 () :> ParsingJob
       OneOpB6 () :> ParsingJob
       OneOpB7 () :> ParsingJob
       OneOpB8 () :> ParsingJob
       OneOpB9 () :> ParsingJob
       OneOpBA () :> ParsingJob
       OneOpBB () :> ParsingJob
       OneOpBC () :> ParsingJob
       OneOpBD () :> ParsingJob
       OneOpBE () :> ParsingJob
       OneOpBF () :> ParsingJob
       OneOpC0 () :> ParsingJob
       OneOpC1 () :> ParsingJob
       OneOpC2 () :> ParsingJob
       OneOpC3 () :> ParsingJob
       OneOpC4 () :> ParsingJob
       OneOpC5 () :> ParsingJob
       OneOpC6 () :> ParsingJob
       OneOpC7 () :> ParsingJob
       OneOpC8 () :> ParsingJob
       OneOpC9 () :> ParsingJob
       OneOpCA () :> ParsingJob
       OneOpCB () :> ParsingJob
       OneOpCC () :> ParsingJob
       OneOpCD () :> ParsingJob
       OneOpCE () :> ParsingJob
       OneOpCF () :> ParsingJob
       OneOpD0 () :> ParsingJob
       OneOpD1 () :> ParsingJob
       OneOpD2 () :> ParsingJob
       OneOpD3 () :> ParsingJob
       OneOpD4 () :> ParsingJob
       OneOpD5 () :> ParsingJob
       OneOpD6 () :> ParsingJob
       OneOpD7 () :> ParsingJob
       OneOpD8 () :> ParsingJob
       OneOpD9 () :> ParsingJob
       OneOpDA () :> ParsingJob
       OneOpDB () :> ParsingJob
       OneOpDC () :> ParsingJob
       OneOpDD () :> ParsingJob
       OneOpDE () :> ParsingJob
       OneOpDF () :> ParsingJob
       OneOpE0 () :> ParsingJob
       OneOpE1 () :> ParsingJob
       OneOpE2 () :> ParsingJob
       OneOpE3 () :> ParsingJob
       OneOpE4 () :> ParsingJob
       OneOpE5 () :> ParsingJob
       OneOpE6 () :> ParsingJob
       OneOpE7 () :> ParsingJob
       OneOpE8 () :> ParsingJob
       OneOpE9 () :> ParsingJob
       OneOpEA () :> ParsingJob
       OneOpEB () :> ParsingJob
       OneOpEC () :> ParsingJob
       OneOpED () :> ParsingJob
       OneOpEE () :> ParsingJob
       OneOpEF () :> ParsingJob
       OneOpF0 () :> ParsingJob
       OneOpF1 () :> ParsingJob
       OneOpF2 () :> ParsingJob
       OneOpF3 () :> ParsingJob
       OneOpF4 () :> ParsingJob
       OneOpF5 () :> ParsingJob
       OneOpF6 () :> ParsingJob
       OneOpF7 () :> ParsingJob
       OneOpF8 () :> ParsingJob
       OneOpF9 () :> ParsingJob
       OneOpFA () :> ParsingJob
       OneOpFB () :> ParsingJob
       OneOpFC () :> ParsingJob
       OneOpFD () :> ParsingJob
       OneOpFE () :> ParsingJob
       OneOpFF () :> ParsingJob |]

  /// Split a byte value into two fileds (high 3 bits; low 5 bits), and
  /// categorize prefix values into 8 groups based on the high 3 bits (= 2^3).
  /// The below array is a collection of bitmaps that maps the low 5-bit value
  /// to a bit value indicating whether the given byte value is a prefix value
  /// or not.
  let prefixCheck =
    [| 0x0u        (* 000xxxxx = cannot be a prefix value *)
       0x40404040u (* 001xxxxx = 26/2e/36/3e is possible *)
       0x0u        (* 010xxxxx = cannot be a prefix value *)
       0x000000f0u (* 011xxxxx = 64/65/66/67 is possible *)
       0x0u
       0x0u
       0x0u
       0x000d0000u (* 111xxxxx = f0/f2/f3 is possible *) |]

  let rhlp = ReadHelper (wordSz, oparsers, szcomputers)

  member inline private __.ParsePrefix (span: ByteSpan) =
    let mutable pos = 0
    let mutable pref = PrxNone
    let mutable b = span[0]
    while ((prefixCheck[(int b >>> 5)] >>> (int b &&& 0b11111)) &&& 1u) > 0u do
      match b with
      | 0xF0uy -> pref <- PrxLOCK ||| (ClearGrp1PrefMask &&& pref)
      | 0xF2uy -> pref <- PrxREPNZ ||| (ClearGrp1PrefMask &&& pref)
      | 0xF3uy -> pref <- PrxREPZ ||| (ClearGrp1PrefMask &&& pref)
      | 0x2Euy -> pref <- PrxCS ||| (ClearSegMask &&& pref)
      | 0x36uy -> pref <- PrxSS ||| (ClearSegMask &&& pref)
      | 0x3Euy -> pref <- PrxDS ||| (ClearSegMask &&& pref)
      | 0x26uy -> pref <- PrxES ||| (ClearSegMask &&& pref)
      | 0x64uy -> pref <- PrxFS ||| (ClearSegMask &&& pref)
      | 0x65uy -> pref <- PrxGS ||| (ClearSegMask &&& pref)
      | 0x66uy -> pref <- PrxOPSIZE ||| pref
      | 0x67uy -> pref <- PrxADDRSIZE ||| pref
      | _ -> pos <- pos - 1
      pos <- pos + 1
      b <- span[pos]
    rhlp.Prefixes <- pref
    pos

  member inline private __.ParseREX (bs: ByteSpan, pos, rex: REXPrefix byref) =
    if wordSz = WordSize.Bit32 then pos
    else
      let rb = bs[pos] |> int
      if rb &&& 0b11110000 = 0b01000000 then
        rex <- EnumOfValue rb
        pos + 1
      else pos

  override __.Parse (bs: byte[], addr) =
    __.Parse (ReadOnlySpan bs, addr)

  override __.Parse (span: ByteSpan, addr) =
    let mutable rex = REXPrefix.NOREX
    let prefEndPos = __.ParsePrefix span
    let nextPos = __.ParseREX (span, prefEndPos, &rex)
    rhlp.VEXInfo <- None
    rhlp.InsAddr <- addr
    rhlp.REXPrefix <- rex
    rhlp.CurrPos <- nextPos
#if LCACHE
    rhlp.MarkPrefixEnd (prefEndPos)
#endif
    oneByteParsers[int (rhlp.ReadByte span)].Run (span, rhlp) :> Instruction

  override __.OperationMode with get() = ArchOperationMode.NoMode and set _ = ()

// vim: set tw=80 sts=2 sw=2:

IntelParsingHelper.fs
//这里解析了x86指令集的二字节和三字节指令。
//主要功能点:
//1. 定义了各种操作数类型、大小常量等。
//2. 根据操作码和操作数组合,定义了每个指令的结构(操作码、操作数描述符等)。
//3. 根据前缀标志、REX字位等判断指令类型(普通/VEX/EVEX),并调用相应的翻译函数。
//4. 根据操作组号调用相应的函数解析组指令。
//5. 指令翻译入口函数,根据操作码不同调用不同子模块进行解析。
//6. 支持前缀修饰(LOCK/REP等),64位模式判断,带条件码更新的二元操作翻译等。
//7. 提供Intel MPX扩展指令集的支持。
//整体流程为:
//1. 从字节流读取操作码
//2. 根据操作码和MOD/RM等信息判断指令类型
//3. 调用相应的解析函数进行解码
//4. 获取操作数结构
//5. 调用下层生成中间表示
//6. 返回翻译结果
//它给上层提供了x86二三字节指令的统一翻译接口。

namespace B2R2.FrontEnd.BinLifter.Intel

open System
open B2R2
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.Helper
open LanguagePrimitives
open type Opcode

type OD = OprDesc
type internal SZ = SizeKind

module internal ParsingHelper = begin
#if !EMULATION
  let inline ensure32 (rhlp: ReadHelper) =
    if WordSize.is64 rhlp.WordSize then raise ParsingFailureException else ()

  let inline ensure64 (rhlp: ReadHelper) =
    if WordSize.is32 rhlp.WordSize then raise ParsingFailureException else ()

  let inline ensureVEX128 (rhlp: ReadHelper) =
    match rhlp.VEXInfo with
    | Some { VectorLength = 256<rt> } -> raise ParsingFailureException
    | _ -> ()
#endif

  let inline getVVVV b = ~~~ (b >>> 3) &&& 0b01111uy

  let getVPrefs b =
    match b &&& 0b00000011uy with
    | 0b01uy -> Prefix.PrxOPSIZE
    | 0b10uy -> Prefix.PrxREPZ
    | 0b11uy -> Prefix.PrxREPNZ
    | _ -> Prefix.PrxNone

  let getTwoVEXInfo (span: ByteSpan) (rex: byref<REXPrefix>) pos =
    let b = span[pos]
    rex <- rex ||| if (b >>> 7) = 0uy then REXPrefix.REXR else REXPrefix.NOREX
    let vLen = if ((b >>> 2) &&& 0b000001uy) = 0uy then 128<rt> else 256<rt>
    { VVVV = getVVVV b
      VectorLength = vLen
      VEXType = VEXType.VEXTwoByteOp
      VPrefixes = getVPrefs b
      EVEXPrx = None }

  let pickVEXType b1 =
    match b1 &&& 0b00011uy with
    | 0b01uy -> VEXType.VEXTwoByteOp
    | 0b10uy -> VEXType.VEXThreeByteOpOne
    | 0b11uy -> VEXType.VEXThreeByteOpTwo
    | _ -> raise ParsingFailureException

  let getVREXPref (b1: byte) b2 =
    let w = (b2 &&& 0b10000000uy) >>> 4
    let rxb = (~~~ b1) >>> 5
    let rex = w ||| rxb ||| 0b1000000uy
    if rex &&& 0b1111uy = 0uy then REXPrefix.NOREX
    else EnumOfValue<int, REXPrefix> (int rex)

  let getThreeVEXInfo (span: ByteSpan) (rex: byref<REXPrefix>) pos =
    let b1 = span[pos]
    let b2 = span[pos + 1]
    let vLen = if ((b2 >>> 2) &&& 0b000001uy) = 0uy then 128<rt> else 256<rt>
    rex <- rex ||| getVREXPref b1 b2
    { VVVV = getVVVV b2
      VectorLength = vLen
      VEXType = pickVEXType b1
      VPrefixes = getVPrefs b2
      EVEXPrx = None }

  let getVLen = function
    | 0b00uy -> 128<rt>
    | 0b01uy -> 256<rt>
    | 0b10uy -> 512<rt>
    | 0b11uy -> raise ParsingFailureException
    | _ -> raise ParsingFailureException

  let getEVEXInfo (span: ByteSpan) (rex: byref<REXPrefix>) pos =
    let b1 = span[pos]
    let b2 = span[pos + 1]
    let l'l = span[pos + 2] >>> 5 &&& 0b011uy
    let vLen = getVLen l'l
    let aaa = span[pos + 2] &&& 0b111uy
    let z =
      if (span[pos + 2] >>> 7 &&& 0b1uy) = 0uy then Zeroing
      else Merging
    let b = (span[pos + 2] >>> 4) &&& 0b1uy
    let e = Some { AAA = aaa; Z = z; B = b }
    rex <- rex ||| getVREXPref b1 b2
    { VVVV = getVVVV b2
      VectorLength = vLen
      VEXType = pickVEXType b1 ||| VEXType.EVEX
      VPrefixes = getVPrefs b2
      EVEXPrx = e }

  let exceptionalOperationSize opcode (rhlp: ReadHelper) =
    match opcode with
    | Opcode.PUSH | Opcode.POP -> rhlp.OperationSize <- rhlp.MemEffOprSize
    | Opcode.MOVSB | Opcode.INSB
    | Opcode.STOSB | Opcode.LODSB
    | Opcode.OUTSB | Opcode.SCASB -> rhlp.OperationSize <- 8<rt>
    | Opcode.OUTSW -> rhlp.OperationSize <- 16<rt>
    | Opcode.OUTSD -> rhlp.OperationSize <- 32<rt>
    | _ -> ()

  let inline newInsInfo (rhlp: ReadHelper) opcode oprs =
    IntelInstruction (rhlp.InsAddr,
                      uint32 (rhlp.ParsedLen ()),
                      rhlp.WordSize,
                      rhlp.Prefixes,
                      rhlp.REXPrefix,
                      rhlp.VEXInfo,
                      opcode,
                      oprs,
                      rhlp.OperationSize,
                      rhlp.MemEffAddrSize
                      (* rhlp.GetInsID () *))

  (* Table A-7/15 of Volume 2
     (D8/DC Opcode Map When ModR/M Byte is within 00H to BFH) *)
  let getD8OpWithin00toBF b =
    match getReg b with
    | 0b000 -> FADD
    | 0b001 -> FMUL
    | 0b010 -> FCOM
    | 0b011 -> FCOMP
    | 0b100 -> FSUB
    | 0b101 -> FSUBR
    | 0b110 -> FDIV
    | 0b111 -> FDIVR
    | _ -> raise ParsingFailureException

  let getDCOpWithin00toBF b = getD8OpWithin00toBF b

  (* Table A-8 of Volume 2
     (D8 Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getD8OpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FADD
    | b when b >= 0xC8uy && b <= 0xCFuy -> FMUL
    | b when b >= 0xD0uy && b <= 0xD7uy -> FCOM
    | b when b >= 0xD8uy && b <= 0xDFuy -> FCOMP
    | b when b >= 0xE0uy && b <= 0xE7uy -> FSUB
    | b when b >= 0xE8uy && b <= 0xEFuy -> FSUBR
    | b when b >= 0xF0uy && b <= 0xF7uy -> FDIV
    | b when b >= 0xF8uy && b <= 0xFFuy -> FDIVR
    | _ -> raise ParsingFailureException

  (* Table A-9 of Volume 2
     (D9 Opcode Map When ModR/M Byte is Within 00H to BFH) *)
  let getD9OpWithin00toBF b =
    match getReg b with
    | 0b000 -> FLD
    | 0b010 -> FST
    | 0b011 -> FSTP
    | 0b100 -> FLDENV
    | 0b101 -> FLDCW
    | 0b110 -> FNSTENV
    | 0b111 -> FNSTCW
    | _ -> raise ParsingFailureException

  (* Table A-10 of Volume 2
     (D9 Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getD9OpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FLD
    | b when b >= 0xC8uy && b <= 0xCFuy -> FXCH
    | 0xD0uy -> FNOP
    | 0xE0uy -> FCHS
    | 0xE1uy -> FABS
    | 0xE4uy -> FTST
    | 0xE5uy -> FXAM
    | 0xE8uy -> FLD1
    | 0xE9uy -> FLDL2T
    | 0xEAuy -> FLDL2E
    | 0xEBuy -> FLDPI
    | 0xECuy -> FLDLG2
    | 0xEDuy -> FLDLN2
    | 0xEEuy -> FLDZ
    | 0xF0uy -> F2XM1
    | 0xF1uy -> FYL2X
    | 0xF2uy -> FPTAN
    | 0xF3uy -> FPATAN
    | 0xF4uy -> FXTRACT
    | 0xF5uy -> FPREM1
    | 0xF6uy -> FDECSTP
    | 0xF7uy -> FINCSTP
    | 0xF8uy -> FPREM
    | 0xF9uy -> FYL2XP1
    | 0xFAuy -> FSQRT
    | 0xFBuy -> FSINCOS
    | 0xFCuy -> FRNDINT
    | 0xFDuy -> FSCALE
    | 0xFEuy -> FSIN
    | 0xFFuy -> FCOS
    | _ -> raise ParsingFailureException

  (* Table A-11/19 of Volume 2
     (DA/DE Opcode Map When ModR/M Byte is Within 00H to BFH) *)
  let getDAOpWithin00toBF b =
    match getReg b with
    | 0b000 -> FIADD
    | 0b001 -> FIMUL
    | 0b010 -> FICOM
    | 0b011 -> FICOMP
    | 0b100 -> FISUB
    | 0b101 -> FISUBR
    | 0b110 -> FIDIV
    | 0b111 -> FIDIVR
    | _ -> raise ParsingFailureException

  let getDEOpWithin00toBF b = getDAOpWithin00toBF b

  (* Table A-12 of Volume 2
     (DA Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDAOpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FCMOVB
    | b when b >= 0xC8uy && b <= 0xCFuy -> FCMOVE
    | b when b >= 0xD0uy && b <= 0xD7uy -> FCMOVBE
    | b when b >= 0xD8uy && b <= 0xDFuy -> FCMOVU
    | 0xE9uy -> FUCOMPP
    | _ -> raise ParsingFailureException

  (* Table A-13 of Volume 2
     (DB Opcode Map When ModR/M Byte is Within 00H to BFH) *)
  let getDBOpWithin00toBF b =
    match getReg b with
    | 0b000 -> FILD
    | 0b001 -> FISTTP
    | 0b010 -> FIST
    | 0b011 -> FISTP
    | 0b101 -> FLD
    | 0b111 -> FSTP
    | _ -> raise ParsingFailureException

  (* Table A-14 of Volume 2
     (DB Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDBOpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FCMOVNB
    | b when b >= 0xC8uy && b <= 0xCFuy -> FCMOVNE
    | b when b >= 0xD0uy && b <= 0xD7uy -> FCMOVNBE
    | b when b >= 0xD8uy && b <= 0xDFuy -> FCMOVNU
    | b when b >= 0xE8uy && b <= 0xEFuy -> FUCOMI
    | b when b >= 0xF0uy && b <= 0xF7uy -> FCOMI
    | 0xE2uy -> FCLEX
    | 0xE3uy -> FINIT
    | _ -> raise ParsingFailureException

  (* Table A-16 of Volume 2
     (DC Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDCOpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FADD
    | b when b >= 0xC8uy && b <= 0xCFuy -> FMUL
    | b when b >= 0xE0uy && b <= 0xE7uy -> FSUBR
    | b when b >= 0xE8uy && b <= 0xEFuy -> FSUB
    | b when b >= 0xF0uy && b <= 0xF7uy -> FDIVR
    | b when b >= 0xF8uy && b <= 0xFFuy -> FDIV
    | _ -> raise ParsingFailureException

  (* Table A-17 of Volume 2
     (DD Opcode Map When ModR/M Byte is Within 00H to BFH) *)
  let getDDOpWithin00toBF b =
    match getReg b with
    | 0b000 -> FLD
    | 0b001 -> FISTTP
    | 0b010 -> FST
    | 0b011 -> FSTP
    | 0b100 -> FRSTOR
    | 0b110 -> FNSAVE
    | 0b111 -> FNSTSW
    | _ -> raise ParsingFailureException

  (* Table A-18 of Volume 2
     (DD Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDDOpcodeOutside00toBF b =
    match b with
    | b when b >= 0xC0uy && b <= 0xC7uy -> FFREE
    | b when b >= 0xD0uy && b <= 0xD7uy -> FST
    | b when b >= 0xD8uy && b <= 0xDFuy -> FSTP
    | b when b >= 0xE0uy && b <= 0xE7uy -> FUCOM
    | b when b >= 0xE8uy && b <= 0xEFuy -> FUCOMP
    | _ -> raise ParsingFailureException

  (* Table A-20 of Volume 2
     (DE Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDEOpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy -> FADDP
    | b when b >= 0xC8uy && b <= 0xCFuy -> FMULP
    | 0xD9uy -> FCOMPP
    | b when b >= 0xE0uy && b <= 0xE7uy -> FSUBRP
    | b when b >= 0xE8uy && b <= 0xEFuy -> FSUBP
    | b when b >= 0xF0uy && b <= 0xF7uy -> FDIVRP
    | b when b >= 0xF8uy && b <= 0xFFuy -> FDIVP
    | _ -> raise ParsingFailureException

  (* Table A-21 of Volume 2
     (DF Opcode Map When ModR/M Byte is Within 00H to BFH) *)
  let getDFOpWithin00toBF b =
    match getReg b with
    | 0b000 -> FILD
    | 0b001 -> FISTTP
    | 0b010 -> FIST
    | 0b011 -> FISTP
    | 0b100 -> FBLD
    | 0b101 -> FILD
    | 0b110 -> FBSTP
    | 0b111 -> FISTP
    | _ -> raise ParsingFailureException

  (* Table A-22 of Volume 2
     (DF Opcode Map When ModR/M Byte is Outside 00H to BFH) *)
  let getDFOpcodeOutside00toBF = function
    | b when b >= 0xC0uy && b <= 0xC7uy ->
      FFREEP (* FIXME: Undocumented x87 instructions *)
    | 0xE0uy -> FNSTSW
    | b when b >= 0xE8uy && b <= 0xEFuy -> FUCOMIP
    | b when b >= 0xF0uy && b <= 0xF7uy -> FCOMIP
    | _ -> raise ParsingFailureException

  let getD8OverBF b =
    getD8OpcodeOutside00toBF b, TwoOperands (OprReg R.ST0, getRM b |> getSTReg)

  let getD9OverBF b =
    getD9OpcodeOutside00toBF b,
    if b < 0xC0uy || b >= 0xD0uy then NoOperand
    else OneOperand (getRM b |> getSTReg)

  let getDAOverBF b =
    getDAOpcodeOutside00toBF b,
    if b = 0xE9uy then NoOperand
    else TwoOperands (OprReg R.ST0, getRM b |> getSTReg)

  let getDBOverBF b =
    getDBOpcodeOutside00toBF b,
    if b = 0xE2uy || b = 0xE3uy then NoOperand
    else TwoOperands (OprReg R.ST0, getRM b |> getSTReg)

  let getDCOverBF b =
    getDCOpcodeOutside00toBF b, TwoOperands (getRM b |> getSTReg, OprReg R.ST0)

  let getDDOverBF b =
    getDDOpcodeOutside00toBF b,
    if b < 0xE0uy || b >= 0xE8uy then getRM b |> getSTReg |> OneOperand
    else TwoOperands (getRM b |> getSTReg, OprReg R.ST0)

  let getDEOverBF b =
    getDEOpcodeOutside00toBF b,
    if b = 0xD9uy then NoOperand
    else TwoOperands (getRM b |> getSTReg, OprReg R.ST0)

  let getDFOverBF b =
    let op = getDFOpcodeOutside00toBF b
    if b = 0xE0uy then op, OprReg R.AX |> OneOperand
    elif b >= 0xC0uy && b <= 0xC7uy then op, OneOperand (getRM b |> getSTReg)
    else op, TwoOperands (OprReg R.ST0, getRM b |> getSTReg)

  let getD9EscEffOprSizeByModRM = function
   | 0b000 | 0b010 | 0b011 -> 32<rt> (* single-real *)
   | 0b100 | 0b110 -> 224<rt> (* 14/28 bytes (Vol.1 8-11 8.1.10) *)
   | 0b101 | 0b111 -> 16<rt> (* 2 bytes *)
   | _ -> raise ParsingFailureException

  let getDBEscEffOprSizeByModRM = function
   | 0b101 | 0b111 -> 80<rt> (* extended-real *)
   | 0b000 | 0b001 | 0b010 | 0b011 -> 32<rt> (* dword-integer *)
   | _ -> raise ParsingFailureException

  let getDDEscEffOprSizeByModRM = function
   | 0b000 | 0b010 | 0b011 -> 64<rt> (* double-real *)
   | 0b001 -> 64<rt> (* integer64 *)
   | 0b100 | 0b110 -> 864<rt> (* 94/108 bytes *)
   | 0b111 -> 16<rt> (* 2 bytes *)
   | _ -> raise ParsingFailureException

  let getDFEscEffOprSizeByModRM = function
   | 0b000 | 0b001 | 0b010 | 0b011 -> 16<rt> (* word-integer *)
   | 0b100 | 0b110 -> 80<rt> (* packed-BCD *)
   | 0b101 | 0b111 -> 64<rt> (* qword-integer *)
   | _ -> raise ParsingFailureException

  let getEscEffOprSizeByESCOp = function
    | 0xD8uy -> 32<rt> (* single-real *)
    | 0xDAuy -> 32<rt> (* dword-integer *)
    | 0xDCuy -> 64<rt> (* double-real *)
    | 0xDEuy -> 16<rt> (* word-integer *)
    | _ -> raise ParsingFailureException

  let selectPrefix (rhlp: ReadHelper) =
    match rhlp.VEXInfo with
    | None -> rhlp.Prefixes
    | Some v -> v.VPrefixes

  /// Not Encodable
  let notEn _ = raise ParsingFailureException

  let nor0F10 = function
    | MPref.MPrxNP -> struct (MOVUPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (MOVUPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (MOVSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (MOVSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F10Mem = function
    | MPref.MPrxNP -> struct (VMOVUPS, OD.GprRm, SZ.VecDef) (* VpsWps *)
    | MPref.MPrx66 -> struct (VMOVUPD, OD.GprRm, SZ.VecDef) (* VpdWpd *)
    | MPref.MPrxF3 -> struct (VMOVSS, OD.GprRm, SZ.DqdDq) (* VdqMd *)
    | MPref.MPrxF2 -> struct (VMOVSD, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F10Reg = function
    | MPref.MPrxNP -> struct (VMOVUPS, OD.GprRm, SZ.VecDef) (* VpsWps *)
    | MPref.MPrx66 -> struct (VMOVUPD, OD.GprRm, SZ.VecDef) (* VpdWpd *)
    | MPref.MPrxF3 -> struct (VMOVSS, OD.XmmVvXm, SZ.VecDef) (* VxHxWss *)
    | MPref.MPrxF2 -> struct (VMOVSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWsd *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F11 = function
    | MPref.MPrxNP -> struct (MOVUPS, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrx66 -> struct (MOVUPD, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrxF3 -> struct (MOVSS, OD.RmGpr, SZ.DqdDqMR) (* WdqdVdq *)
    | MPref.MPrxF2 -> struct (MOVSD, OD.RmGpr, SZ.DqqDq) (* WdqqVdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F11Mem = function
    | MPref.MPrxNP -> struct (VMOVUPS, OD.RmGpr, SZ.VecDef) (* WpsVps *)
    | MPref.MPrx66 -> struct (VMOVUPD, OD.RmGpr, SZ.VecDef) (* WpdVpd *)
    | MPref.MPrxF3 -> struct (VMOVSS, OD.RmGpr, SZ.DqdDqMR) (* MdVdq *)
    | MPref.MPrxF2 -> struct (VMOVSD, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F11Reg = function
    | MPref.MPrxNP -> struct (VMOVUPS, OD.RmGpr, SZ.VecDef) (* WpsVps *)
    | MPref.MPrx66 -> struct (VMOVUPD, OD.RmGpr, SZ.VecDef) (* WpdVpd *)
    | MPref.MPrxF3 -> struct (VMOVSS, OD.XmVvXmm, SZ.VecDef) (* WssHxVss *)
    | MPref.MPrxF2 -> struct (VMOVSD, OD.XmVvXmm, SZ.VecDef) (* WsdHxVsd *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F12Mem = function
    | MPref.MPrxNP -> struct (MOVLPS, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrx66 -> struct (MOVLPD, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | MPref.MPrxF3 -> struct (MOVSLDUP, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2 -> struct (MOVDDUP, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F12Reg = function
    | MPref.MPrxNP -> struct (MOVHLPS, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrx66 -> struct (MOVLPD, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | MPref.MPrxF3 -> struct (MOVSLDUP, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2 -> struct (MOVDDUP, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F12Mem = function
    | MPref.MPrxNP ->
      struct (VMOVLPS, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrx66 -> struct (VMOVLPD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqMq *)
    | MPref.MPrxF3 -> struct (VMOVSLDUP, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2 -> struct (VMOVDDUP, OD.GprRm, SZ.XqX) (* VxWxq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F12Reg = function
    | MPref.MPrxNP ->
      struct (VMOVHLPS, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrx66 -> struct (VMOVLPD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqMq *)
    | MPref.MPrxF3 -> struct (VMOVSLDUP, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2 -> struct (VMOVDDUP, OD.GprRm, SZ.XqX) (* VxWxq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F13 = function
    | MPref.MPrxNP -> struct (MOVLPS, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrx66 -> struct (MOVLPD, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F13 = function
    | MPref.MPrxNP -> struct (VMOVLPS, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrx66 -> struct (VMOVLPD, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F14 = function
    | MPref.MPrxNP -> struct (UNPCKLPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (UNPCKLPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F14 = function
    | MPref.MPrxNP ->
      struct (VUNPCKLPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrx66 ->
      struct (VUNPCKLPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F15 = function
    | MPref.MPrxNP -> struct (UNPCKHPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (UNPCKHPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F15 = function
    | MPref.MPrxNP ->
      struct (VUNPCKHPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrx66 ->
      struct (VUNPCKHPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F16Mem = function
    | MPref.MPrxNP -> struct (MOVHPS, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | MPref.MPrx66 -> struct (MOVHPD, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | MPref.MPrxF3 -> struct (MOVSHDUP, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F16Reg = function
    | MPref.MPrxNP -> struct (MOVLHPS, OD.GprRm, SZ.DqDq) (* VdqUdq *)
    | MPref.MPrx66 -> struct (MOVHPD, OD.GprRm, SZ.DqqDq) (* VdqMq *)
    | MPref.MPrxF3 -> struct (MOVSHDUP, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F16Mem = function
    | MPref.MPrxNP -> struct (VMOVHPS, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqMq *)
    | MPref.MPrx66 -> struct (VMOVHPD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqMq *)
    | MPref.MPrxF3 -> struct (VMOVSHDUP, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F16Reg = function
    | MPref.MPrxNP ->
      struct (VMOVLHPS, OD.XmmVvXm, SZ.DqDq) (* VdqHdqUdq *)
    | MPref.MPrx66 ->
      struct (VMOVHPD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqMq *)
    | MPref.MPrxF3 -> struct (VMOVSHDUP, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F17 = function
    | MPref.MPrxNP -> struct (MOVHPS, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrx66 -> struct (MOVHPD, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F17 = function
    | MPref.MPrxNP -> struct (VMOVHPS, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrx66 -> struct (VMOVHPD, OD.RmGpr, SZ.DqqDq) (* MqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F1A = function
    | MPref.MPrxNP -> struct (BNDLDX, OD.BndRm, SZ.VyDq) (* BNMib *)
    | MPref.MPrx66 -> struct (BNDMOV, OD.BndBm, SZ.DqqDqWS) (* BNBNdqq *)
    | MPref.MPrxF3 -> struct (BNDCL, OD.BndRm, SZ.VyDq) (* BNEv *)
    | MPref.MPrxF2 -> struct (BNDCU, OD.BndRm, SZ.VyDq) (* BNEv *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F1B = function
    | MPref.MPrxNP -> struct (BNDSTX, OD.RmBnd, SZ.VyDqMR) (* MibBN *)
    | MPref.MPrx66 -> struct (BNDMOV, OD.BmBnd, SZ.DqqDqWS) (* BNdqqBN *)
    | MPref.MPrxF3 -> struct (BNDMK, OD.BndRm, SZ.VyDq) (* BNMv *)
    | MPref.MPrxF2 -> struct (BNDCN, OD.BndRm, SZ.VyDq) (* BNEv *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F28 = function
    | MPref.MPrxNP -> struct (MOVAPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (MOVAPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F28 = function
    | MPref.MPrxNP -> struct (VMOVAPS, OD.GprRm, SZ.VecDef) (* VpsWps *)
    | MPref.MPrx66 -> struct (VMOVAPD, OD.GprRm, SZ.VecDef) (* VpdWpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F29 = function
    | MPref.MPrxNP -> struct (MOVAPS, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrx66 -> struct (MOVAPD, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F29 = function
    | MPref.MPrxNP -> struct (VMOVAPS, OD.RmGpr, SZ.VecDef) (* WpsVps *)
    | MPref.MPrx66 -> struct (VMOVAPD, OD.RmGpr, SZ.VecDef) (* WpdVpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2A = function
    | MPref.MPrxNP -> struct (CVTPI2PS, OD.GprRMm, SZ.QDq) (* VdqQpi *)
    | MPref.MPrx66 -> struct (CVTPI2PD, OD.GprRMm, SZ.QDq) (* VdqQpi *)
    | MPref.MPrxF3 -> struct (CVTSI2SS, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | MPref.MPrxF2 -> struct (CVTSI2SD, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2A = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VCVTSI2SS, OD.XmmVvXm, SZ.VyDq) (* VssHssEy *)
    | MPref.MPrxF2 ->
      struct (VCVTSI2SD, OD.XmmVvXm, SZ.VyDq) (* VsdHsdEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2B = function
    | MPref.MPrxNP -> struct (MOVNTPS, OD.RmGpr, SZ.DqDq) (* MdqVdq *)
    | MPref.MPrx66 -> struct (MOVNTPD, OD.RmGpr, SZ.DqDq) (* MdqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2B = function
    | MPref.MPrxNP -> struct (VMOVNTPS, OD.RmGpr, SZ.VecDef) (* MpsVps *)
    | MPref.MPrx66 -> struct (VMOVNTPD, OD.RmGpr, SZ.VecDef) (* MpdVpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2C = function
    | MPref.MPrxNP ->
      struct (CVTTPS2PI, OD.MmxMm, SZ.DqqQ) (* PpiWdqq *)
    | MPref.MPrx66 -> struct (CVTTPD2PI, OD.MmxMm, SZ.DqQ) (* PpiWdq *)
    | MPref.MPrxF3 -> struct (CVTTSS2SI, OD.GprRm, SZ.DqdY) (* GyWdqd *)
    | MPref.MPrxF2 -> struct (CVTTSD2SI, OD.GprRm, SZ.DqqY) (* GyWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2C = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VCVTTSS2SI, OD.GprRm, SZ.DqdY) (* GyWdqd *)
    | MPref.MPrxF2 -> struct (VCVTTSD2SI, OD.GprRm, SZ.DqqY) (* GyWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2D = function
    | MPref.MPrxNP -> struct (CVTPS2PI, OD.MmxMm, SZ.DqqQ) (* PpiWdqq *)
    | MPref.MPrx66 -> struct (CVTPD2PI, OD.MmxMm, SZ.DqQ) (* PpiWdq *)
    | MPref.MPrxF3 -> struct (CVTSS2SI, OD.GprRm, SZ.DqdY) (* GyWdqd *)
    | MPref.MPrxF2 -> struct (CVTSD2SI, OD.GprRm, SZ.DqqY) (* GyWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2D = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VCVTSS2SI, OD.GprRm, SZ.DqdY) (* GyWdqd *)
    | MPref.MPrxF2 -> struct (VCVTSD2SI, OD.GprRm, SZ.DqqY) (* GyWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2E = function
    | MPref.MPrxNP -> struct (UCOMISS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrx66 -> struct (UCOMISD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2E = function
    | MPref.MPrxNP -> struct (VUCOMISS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrx66 -> struct (VUCOMISD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F2F = function
    | MPref.MPrxNP -> struct (COMISS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrx66 -> struct (COMISD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F2F = function
    | MPref.MPrxNP -> struct (VCOMISS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrx66 -> struct (VCOMISD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F50 = function
    | MPref.MPrxNP -> struct (MOVMSKPS, OD.GprRm, SZ.DqY) (* GyUdq *)
    | MPref.MPrx66 -> struct (MOVMSKPD, OD.GprRm, SZ.DqY) (* GyUdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F50 = function
    | MPref.MPrxNP -> struct (VMOVMSKPS, OD.GprRm, SZ.DqY) (* GyUdq *)
    | MPref.MPrx66 -> struct (VMOVMSKPD, OD.GprRm, SZ.DqY) (* GyUdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F51 = function
    | MPref.MPrxNP -> struct (SQRTPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (SQRTPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (SQRTSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (SQRTSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F51 = function
    | MPref.MPrxNP -> struct (VSQRTPS, OD.GprRm, SZ.VecDef) (* VpsWps *)
    | MPref.MPrx66 -> struct (VSQRTPD, OD.GprRm, SZ.VecDef) (* VpdWpd *)
    | MPref.MPrxF3 ->
      struct (VSQRTSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VSQRTSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F52 = function
    | MPref.MPrxNP -> struct (RSQRTPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (RSQRTSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F52 = function
    | MPref.MPrxNP -> struct (VRSQRTPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VRSQRTSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd*)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F53 = function
    | MPref.MPrxNP -> struct (RCPPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (RCPSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F53 = function
    | MPref.MPrxNP -> struct (VRCPPS, OD.GprRm, SZ.VecDef) (* VxHx *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VRCPSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F54 = function
    | MPref.MPrxNP -> struct (ANDPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (ANDPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F54 = function
    | MPref.MPrxNP ->
      struct (VANDPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VANDPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F55 = function
    | MPref.MPrxNP -> struct (ANDNPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (ANDNPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F55 = function
    | MPref.MPrxNP ->
      struct (VANDNPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VANDNPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F56 = function
    | MPref.MPrxNP -> struct (ORPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (ORPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F56 = function
    | MPref.MPrxNP -> struct (VORPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 -> struct (VORPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F57 = function
    | MPref.MPrxNP -> struct (XORPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (XORPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F57 = function
    | MPref.MPrxNP ->
      struct (VXORPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VXORPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F58 = function
    | MPref.MPrxNP -> struct (ADDPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (ADDPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (ADDSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (ADDSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F58 = function
    | MPref.MPrxNP ->
      struct (VADDPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VADDPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VADDSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VADDSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F59 = function
    | MPref.MPrxNP -> struct (MULPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (MULPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (MULSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (MULSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F59 = function
    | MPref.MPrxNP ->
      struct (VMULPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VMULPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VMULSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VMULSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5A = function
    | MPref.MPrxNP -> struct (CVTPS2PD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrx66 -> struct (CVTPD2PS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (CVTSS2SD, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (CVTSD2SS, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5A = function
    | MPref.MPrxNP ->
      struct (VCVTPS2PD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrx66 -> struct (VCVTPD2PS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 ->
      struct (VCVTSS2SD, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VCVTSD2SS, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F5AW0 = function
    | MPref.MPrxNP -> struct (VCVTPS2PD, OD.GprRm, SZ.XqXz) (* VZxzWxq *)
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F5AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTPD2PS, OD.GprRm, SZ.XzX) (* VxWZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5B = function
    | MPref.MPrxNP -> struct (CVTDQ2PS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (CVTPS2DQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (CVTTPS2DQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5B = function
    | MPref.MPrxNP -> struct (VCVTDQ2PS, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VCVTTPS2DQ, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5C = function
    | MPref.MPrxNP -> struct (SUBPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (SUBPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (SUBSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (SUBSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5C = function
    | MPref.MPrxNP ->
      struct (VSUBPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VSUBPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VSUBSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VSUBSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5D = function
    | MPref.MPrxNP -> struct (MINPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (MINPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (MINSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (MINSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5D = function
    | MPref.MPrxNP ->
      struct (VMINPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VMINPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VMINSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VMINSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F5DW0 = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VMINSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5E = function
    | MPref.MPrxNP -> struct (DIVPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (DIVPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (DIVSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (DIVSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5E = function
    | MPref.MPrxNP ->
      struct (VDIVPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VDIVPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VDIVSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VDIVSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F5F = function
    | MPref.MPrxNP -> struct (MAXPS, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrx66 -> struct (MAXPD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (MAXSS, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF2 -> struct (MAXSD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F5F = function
    | MPref.MPrxNP ->
      struct (VMAXPS, OD.XmmVvXm, SZ.VecDef) (* VpsHpsWps *)
    | MPref.MPrx66 ->
      struct (VMAXPD, OD.XmmVvXm, SZ.VecDef) (* VpdHpdWpd *)
    | MPref.MPrxF3 ->
      struct (VMAXSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2 ->
      struct (VMAXSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F5FW0 = function
    | MPref.MPrxNP -> struct (VMAXPS, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VMAXSS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F5FW1 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 ->
      struct (VMAXSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F60 = function
    | MPref.MPrxNP -> struct (PUNPCKLBW, OD.MmxRm, SZ.DQ) (* PqQd *)
    | MPref.MPrx66 -> struct (PUNPCKLBW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F60 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKLBW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F61 = function
    | MPref.MPrxNP -> struct (PUNPCKLWD, OD.MmxRm, SZ.DQ) (* PqQd *)
    | MPref.MPrx66 -> struct (PUNPCKLWD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F61 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKLWD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F62 = function
    | MPref.MPrxNP -> struct (PUNPCKLDQ, OD.MmxRm, SZ.DQ) (* PqQd *)
    | MPref.MPrx66 -> struct (PUNPCKLDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F62 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKLDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F63 = function
    | MPref.MPrxNP -> struct (PACKSSWB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PACKSSWB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F63 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPACKSSWB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F64 = function
    | MPref.MPrxNP -> struct (PCMPGTB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPGTB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F64 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPGTB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F65 = function
    | MPref.MPrxNP -> struct (PCMPGTW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPGTW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F65 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPGTW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F66 = function
    | MPref.MPrxNP -> struct (PCMPGTD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPGTD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F66 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPGTD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F67 = function
    | MPref.MPrxNP -> struct (PACKUSWB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PACKUSWB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F67 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPACKUSWB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F68 = function
    | MPref.MPrxNP -> struct (PUNPCKHBW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PUNPCKHBW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F68 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKHBW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F69 = function
    | MPref.MPrxNP -> struct (PUNPCKHWD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PUNPCKHWD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F69 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKHWD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6A = function
    | MPref.MPrxNP -> struct (PUNPCKHDQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PUNPCKHDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6A = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKHDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6B = function
    | MPref.MPrxNP -> struct (PACKSSDW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PACKSSDW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPACKSSDW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PUNPCKLQDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKLQDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PUNPCKHQDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPUNPCKHQDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6EW1 = function
    | MPref.MPrxNP -> struct (MOVQ, OD.MmxMm, SZ.YQRM) (* PqEy *)
    | MPref.MPrx66 -> struct (MOVQ, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6EW0 = function
    | MPref.MPrxNP -> struct (MOVD, OD.MmxMm, SZ.YQRM) (* PqEy *)
    | MPref.MPrx66 -> struct (MOVD, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVQ, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVD, OD.GprRm, SZ.VyDq) (* VdqEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F6F = function
    | MPref.MPrxNP -> struct (MOVQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (MOVDQA, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (MOVDQU, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F6F = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVDQA, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> struct (VMOVDQU, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F6FW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMOVDQA64, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF3 ->
      struct (VMOVDQU64, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF2 ->
      struct (VMOVDQU16, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F6FW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMOVDQA32, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF3 ->
      struct (VMOVDQU32, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF2 -> struct (VMOVDQU8, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F70 = function
    | MPref.MPrxNP -> struct (PSHUFW, OD.MmxMmImm8, SZ.QQ) (* PqQqIb *)
    | MPref.MPrx66 -> struct (PSHUFD, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3 ->
      struct (PSHUFHW, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF2 ->
      struct (PSHUFLW, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F70 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSHUFD, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | MPref.MPrxF3 ->
      struct (VPSHUFHW, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | MPref.MPrxF2 ->
      struct (VPSHUFLW, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F74 = function
    | MPref.MPrxNP -> struct (PCMPEQB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPEQB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F74 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPEQB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F75 = function
    | MPref.MPrxNP -> struct (PCMPEQW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPEQW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F75 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPEQW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F76 = function
    | MPref.MPrxNP -> struct (PCMPEQD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PCMPEQD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F76 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPEQD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F77 = function
    | MPref.MPrxNP -> struct (EMMS, OD.No, SZ.Def) (* NoOpr *)
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F77 = function
    | MPref.MPrxNP -> struct (VZEROUPPER, OD.No, SZ.Def) (* NoOpr *)
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F78 = function
    | MPref.MPrxNP -> struct (VMREAD, OD.RmGpr, SZ.Y) (* EyGy *)
    | MPref.MPrx66 -> (* FIXME: Undocumented instruction *)
      struct (EXTRQ, OD.RmImm8Imm8, SZ.Dq) (* VdqUdqIbIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> (* FIXME: Undocumented instruction *)
      struct (INSERTQ, OD.GprRmImm8Imm8, SZ.Dq) (* VdqUdqIbIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F78W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTTPS2UQQ, OD.GprRm, SZ.XqXz) (* VZxzWxq *)
    | MPref.MPrxF3 -> struct (VCVTTSS2USI, OD.GprRm, SZ.DqdY) (* VdWdqq *)
    | MPref.MPrxF2 -> struct (VCVTTSD2USI, OD.GprRm, SZ.DqqY) (* VqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F78W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTTPD2UQQ, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> struct (VCVTTSS2USI, OD.GprRm, SZ.DqdY) (* VdWdqq *)
    | MPref.MPrxF2 -> struct (VCVTTSD2USI, OD.GprRm, SZ.DqqY) (* VqWdqq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTTPS2QQ, OD.GprRm, SZ.XqX) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTTPD2QQ, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> struct (VCVTUQQ2PD, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VCVTUSI2SS, OD.XmmVvXm, SZ.DDq) (* VdqHdqWd *)
    | MPref.MPrxF2 ->
      struct (VCVTUSI2SD, OD.XmmVvXm, SZ.DDq) (* VdqHdqWd *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VCVTUSI2SS, OD.XmmVvXm, SZ.QDq) (* VdqHdqWq *)
    | MPref.MPrxF2 ->
      struct (VCVTUSI2SD, OD.XmmVvXm, SZ.QDq) (* VdqHdqWq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F7C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VHADDPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 ->
      struct (VHADDPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F7D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VHSUBPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 ->
      struct (VHSUBPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F7EW1 = function
    | MPref.MPrxNP -> struct (MOVQ, OD.RMMmx, SZ.YQ) (* EyPq *)
    | MPref.MPrx66 -> struct (MOVQ, OD.RmGpr, SZ.VyDqMR) (* EyVdq *)
    | MPref.MPrxF3 -> struct (MOVQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F7EW0 = function
    | MPref.MPrxNP -> struct (MOVD, OD.RMMmx, SZ.YQ) (* EyPq *)
    | MPref.MPrx66 -> struct (MOVD, OD.RmGpr, SZ.VyDqMR) (* EyVdq *)
    | MPref.MPrxF3 -> struct (MOVQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F7EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVQ, OD.RmGpr, SZ.VyDqMR) (* EyVdq *)
    | MPref.MPrxF3 -> struct (VMOVQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F7EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVD, OD.RmGpr, SZ.VyDqMR) (* EyVdq *)
    | MPref.MPrxF3 -> struct (VMOVQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F7F = function
    | MPref.MPrxNP -> struct (MOVQ, OD.MmMmx, SZ.QQ) (* QqPq *)
    | MPref.MPrx66 -> struct (MOVDQA, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrxF3 -> struct (MOVDQU, OD.RmGpr, SZ.DqDq) (* WdqVdq *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F7F = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVDQA, OD.RmGpr, SZ.VecDef) (* WxVx *)
    | MPref.MPrxF3 -> struct (VMOVDQU, OD.RmGpr, SZ.VecDef) (* WxVx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7FW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMOVDQA64, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | MPref.MPrxF3 ->
      struct (VMOVDQU64, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | MPref.MPrxF2 ->
      struct (VMOVDQU16, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F7FW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMOVDQA32, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | MPref.MPrxF3 ->
      struct (VMOVDQU32, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | MPref.MPrxF2 ->
      struct (VMOVDQU8, OD.RmGpr, SZ.VecDef) (* WZxzVZxz *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FC2 = function
    | MPref.MPrxNP ->
      struct (CMPPS, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrx66 ->
      struct (CMPPD, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3 ->
      struct (CMPSS, OD.XmmRmImm8, SZ.DqdDq) (* VdqWdqdIb *)
    | MPref.MPrxF2 ->
      struct (CMPSD, OD.XmmRmImm8, SZ.DqqDq) (* VdqWdqqIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FC2 = function
    | MPref.MPrxNP ->
      struct (VCMPPS, OD.XmmVvXmImm8, SZ.VecDef) (* VpsHpsWpsIb *)
    | MPref.MPrx66 ->
      struct (VCMPPD, OD.XmmVvXmImm8, SZ.VecDef) (* VpdHpdWpdIb *)
    | MPref.MPrxF3 ->
      struct (VCMPSS, OD.XmmVvXmImm8, SZ.VecDef) (* VssHssWssIb *)
    | MPref.MPrxF2 ->
      struct (VCMPSD, OD.XmmVvXmImm8, SZ.VecDef) (* VsdHsdWsdIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FC2W0 = function
    | MPref.MPrxNP ->
      struct (VCMPPS, OD.KnVvXmImm8, SZ.XzXz) (* KnHxWxIb *)
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FC2W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VCMPPD, OD.KnVvXmImm8, SZ.XzXz) (* KnHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FC4 = function
    | MPref.MPrxNP -> struct (PINSRW, OD.MmxRmImm8, SZ.DwQ) (* PqEdwIb *)
    | MPref.MPrx66 ->
      struct (PINSRW, OD.XmmRmImm8, SZ.DwDq) (* VdqEdwIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FC4 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRW, OD.XmmVvXmImm8, SZ.DwDq) (* VdqHdqEdwIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FC5 = function
    | MPref.MPrxNP -> struct (PEXTRW, OD.GprMmxImm8, SZ.QD) (* GdNqIb *)
    | MPref.MPrx66 -> struct (PEXTRW, OD.XmmRmImm8, SZ.Dqd) (* GdUdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FC5 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPEXTRW, OD.XmmRmImm8, SZ.Dqd) (* GdUdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FC6 = function
    | MPref.MPrxNP -> struct (SHUFPS, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrx66 -> struct (SHUFPD, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FC6 = function
    | MPref.MPrxNP ->
      struct (VSHUFPS, OD.XmmVvXmImm8, SZ.VecDef) (* VpsHpsWpsIb *)
    | MPref.MPrx66 ->
      struct (VSHUFPD, OD.XmmVvXmImm8, SZ.VecDef) (* VpdHpdWpdIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VADDSUBPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 ->
      struct (VADDSUBPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD1 = function
    | MPref.MPrxNP -> struct (PSRLW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSRLW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSRLW, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD2 = function
    | MPref.MPrxNP -> struct (PSRLD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSRLD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD2 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSRLD, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD3 = function
    | MPref.MPrxNP -> struct (PSRLQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSRLQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD3 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSRLQ, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD4 = function
    | MPref.MPrxNP -> struct (PADDQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD4 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD5 = function
    | MPref.MPrxNP -> struct (PMULLW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMULLW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD5 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULLW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD6 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (MOVQ, OD.RmGpr, SZ.DqqDq) (* WdqqVdq *)
    | MPref.MPrxF3 -> struct (MOVQ2DQ, OD.GprRMm, SZ.QDq) (* VdqNq *)
    | MPref.MPrxF2 -> struct (MOVDQ2Q, OD.MmxMm, SZ.DqQ) (* PqUdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD6 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVQ, OD.RmGpr, SZ.DqqDq) (* WdqqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD7 = function
    | MPref.MPrxNP -> struct (PMOVMSKB, OD.GprRMm, SZ.QD) (* GdNq *)
    | MPref.MPrx66 -> struct (PMOVMSKB, OD.GprRm, SZ.Dqd) (* GdUdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD7 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVMSKB, OD.GprRm, SZ.XD) (* GdUx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD8 = function
    | MPref.MPrxNP -> struct (PSUBUSB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBUSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD8 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBUSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FD9 = function
    | MPref.MPrxNP -> struct (PSUBUSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBUSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FD9 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBUSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDA = function
    | MPref.MPrxNP -> struct (PMINUB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMINUB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDA = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINUB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDB = function
    | MPref.MPrxNP -> struct (PAND, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PAND, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDB = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPAND, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDC = function
    | MPref.MPrxNP -> struct (PADDUSB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDUSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDC = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDUSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDD = function
    | MPref.MPrxNP -> struct (PADDUSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDUSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDD = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDUSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDE = function
    | MPref.MPrxNP -> struct (PMAXUB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMAXUB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDE = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMAXUB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FDF = function
    | MPref.MPrxNP -> struct (PANDN, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PANDN, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FDF = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPANDN, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE0 = function
    | MPref.MPrxNP -> struct (PAVGB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PAVGB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPAVGB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE1 = function
    | MPref.MPrxNP -> struct (PSRAW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSRAW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSRAW, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE2 = function
    | MPref.MPrxNP -> struct (PSRAD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSRAD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE2 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSRAD, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE3 = function
    | MPref.MPrxNP -> struct (PAVGW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PAVGW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE3 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPAVGW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE4 = function
    | MPref.MPrxNP -> struct (PMULHUW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMULHUW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE4 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULHUW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE5 = function
    | MPref.MPrxNP -> struct (PMULHW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMULHW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE5 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULHW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE6 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (CVTTPD2DQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> struct (CVTDQ2PD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF2 -> struct (CVTPD2DQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE6 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VCVTTPD2DQ, OD.GprRm, SZ.DqX) (* VdqWx *)
    | MPref.MPrxF3 -> struct (VCVTDQ2PD, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF2 -> struct (VCVTPD2DQ, OD.GprRm, SZ.DqX) (* VdqWpd *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FE6W0 = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VCVTDQ2PD, OD.GprRm, SZ.XXz) (* VZxzWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FE6W1 = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VCVTQQ2PD, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE7 = function
    | MPref.MPrxNP -> struct (MOVNTQ, OD.RMMmx, SZ.QQ) (* MqPq *)
    | MPref.MPrx66 -> struct (MOVNTDQ, OD.RmGpr, SZ.DqDq) (* MdqVdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE7 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVNTDQ, OD.RmGpr, SZ.VecDef) (* MxVx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FE7W1 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FE7W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VMOVNTDQ, OD.RmGpr, SZ.VecDef) (* MZxzVZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE8 = function
    | MPref.MPrxNP -> struct (PSUBSB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE8 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FE9 = function
    | MPref.MPrxNP -> struct (PSUBSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FE9 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FEA = function
    | MPref.MPrxNP -> struct (PMINSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMINSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FEA = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FEB = function
    | MPref.MPrxNP -> struct (POR, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (POR, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FEB = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPOR, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FEC = function
    | MPref.MPrxNP -> struct (PADDSB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FEC = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FED = function
    | MPref.MPrxNP -> struct (PADDSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FED = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FEE = function
    | MPref.MPrxNP -> struct (PMAXSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMAXSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FEE = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMAXSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FEF = function
    | MPref.MPrxNP -> struct (PXOR, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PXOR, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FEF = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPXOR, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FEFW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPXORD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0FEFW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPXORQ, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (LDDQU, OD.GprRm, SZ.DqDq) (* VdqMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (VLDDQU, OD.GprRm, SZ.VecDef) (* VxMx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF1 = function
    | MPref.MPrxNP -> struct (PSLLW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSLLW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSLLW, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF2 = function
    | MPref.MPrxNP -> struct (PSLLD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSLLD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF2 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSLLD, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF3 = function
    | MPref.MPrxNP -> struct (PSLLQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSLLQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF3 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSLLQ, OD.XmmVvXm, SZ.DqX) (* VxHxWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF4 = function
    | MPref.MPrxNP -> struct (PMULUDQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMULUDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF4 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULUDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF5 = function
    | MPref.MPrxNP -> struct (PMADDWD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMADDWD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF5 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMADDWD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF6 = function
    | MPref.MPrxNP -> struct (PSADBW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSADBW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF6 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSADBW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF8 = function
    | MPref.MPrxNP -> struct (PSUBB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF8 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FF9 = function
    | MPref.MPrxNP -> struct (PSUBW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FF9 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FFA = function
    | MPref.MPrxNP -> struct (PSUBD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FFA = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FFB = function
    | MPref.MPrxNP -> struct (PSUBQ, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSUBQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FFB = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSUBQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FFC = function
    | MPref.MPrxNP -> struct (PADDB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FFC = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FFD = function
    | MPref.MPrxNP -> struct (PADDW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FFD = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0FFE = function
    | MPref.MPrxNP -> struct (PADDD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PADDD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0FFE = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPADDD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3800 = function
    | MPref.MPrxNP -> struct (PSHUFB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSHUFB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3800 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHUFB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3801 = function
    | MPref.MPrxNP -> struct (PHADDW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHADDW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3801 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHADDW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3802 = function
    | MPref.MPrxNP -> struct (PHADDD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHADDD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3802 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHADDD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3803 = function
    | MPref.MPrxNP -> struct (PHADDSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHADDSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3803 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHADDSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3805 = function
    | MPref.MPrxNP -> struct (PHSUBW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHSUBW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3805 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHSUBW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3806 = function
    | MPref.MPrxNP -> struct (PHSUBD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHSUBD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3806 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHSUBD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3807 = function
    | MPref.MPrxNP -> struct (PHSUBSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PHSUBSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3807 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPHSUBSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3808 = function
    | MPref.MPrxNP -> struct (PSIGNB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSIGNB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3808 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSIGNB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3809 = function
    | MPref.MPrxNP -> struct (PSIGNW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSIGNW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3809 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSIGNW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F380A = function
    | MPref.MPrxNP -> struct (PSIGND, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PSIGND, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F380A = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSIGND, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F380B = function
    | MPref.MPrxNP -> struct (PMULHRSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PMULHRSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F380B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMULHRSW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F380CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMILPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3814W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPRORVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3814W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPRORVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3815 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (BLENDVPD, OD.XmmXmXmm0, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3816W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPERMPS, OD.XmmVvXm, SZ.Qq) (* VqqHqqWqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3817 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PTEST, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3817 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPTEST, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3818W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VBROADCASTSS, OD.GprRm, SZ.DX) (* VxMd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3818W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTSS, OD.GprRm, SZ.DqdXz) (* VZxzWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3819W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTSD, OD.GprRm, SZ.DqqQq) (* VqqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3819W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTSD, OD.GprRm, SZ.DqqXz) (* VZxzWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F381C = function
    | MPref.MPrxNP -> struct (PABSB, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PABSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F381AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTF128, OD.GprRm, SZ.DqQq) (* VqqMdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F381C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPABSB, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F381D = function
    | MPref.MPrxNP -> struct (PABSW, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PABSW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F381D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPABSW, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F381E = function
    | MPref.MPrxNP -> struct (PABSD, OD.MmxRm, SZ.QQ) (* PqQq *)
    | MPref.MPrx66 -> struct (PABSD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F381E = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPABSD, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F381FW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPABSQ, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3820 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXBW, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3820 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVSXBW, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3821 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXBD, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3821 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVSXBD, OD.GprRm, SZ.DqddqX) (* VxWdqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3822 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXBQ, OD.GprRm, SZ.DqwDq) (* VdqWdqw *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3822 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVSXBQ, OD.GprRm, SZ.DqwdX) (* VxWdqwd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3823 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXWD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3823 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVSXWD, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3824 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXWQ, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3824 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVSXWQ, OD.GprRm, SZ.DqddqX) (* VxWdqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3825 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVSXDQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3825 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVSXDQ, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3828 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMULDQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3828 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULDQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3829 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PCMPEQQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3829 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPEQQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F382AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VPBROADCASTMB2Q, OD.GprKn, SZ.VecDef) (* VxKn *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F382B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PACKUSDW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F382B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPACKUSDW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F382CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMASKMOVPS, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F382CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCALEFPS, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F382CW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCALEFPD, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F382DW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMASKMOVPD, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F382DW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCALEFSS, OD.XmmVvXm, SZ.DqdDqMR) (* VdqHdqMd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F382DW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCALEFSD, OD.XmmVvXm, SZ.DqqDqMR) (* VdqHdqMq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F382EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMASKMOVPS, OD.XmVvXmm, SZ.VecDef) (* MxHxVx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F382FW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VMASKMOVPD, OD.XmVvXmm, SZ.VecDef) (* MxHxVx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3830 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXBW, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3830 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVZXBW, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3830 = function
    | MPref.MPrxNP
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VPMOVWB, OD.RmGpr, SZ.QqXz) (* WqqVZxz *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3831 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXBD, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3831 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVZXBD, OD.GprRm, SZ.DqddqX) (* VxWdqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3832 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXBQ, OD.GprRm, SZ.DqwDq) (* VdqWdqw *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3832 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVZXBQ, OD.GprRm, SZ.DqwdX) (* VxWdqwd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3833 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXWD, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3833 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVZXWD, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3833 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVZXWD, OD.GprRm, SZ.XqXz) (* VZxzWxq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3834 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXWQ, OD.GprRm, SZ.DqdDq) (* VdqWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3834 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMOVZXWQ, OD.GprRm, SZ.DqddqX) (* VxWdqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3835 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMOVZXDQ, OD.GprRm, SZ.DqqDq) (* VdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3835 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMOVZXDQ, OD.GprRm, SZ.DqqdqX) (* VxWdqqdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3836W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMD, OD.XmmVvXm, SZ.Qq) (* VqqHqqWqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3837 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PCMPGTQ, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3837 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCMPGTQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3838 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMINSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3838 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3839 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMINSD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3839 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3839W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VPMOVD2M, OD.KnGpr, SZ.VecDef) (* KnWx *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383A = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMINUW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383A = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINUW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F383AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (VPBROADCASTMW2D, OD.GprKn, SZ.VecDef) (* VxKn *)
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMINUD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMINUD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMAXSB, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMAXSB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMAXSD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMAXSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383E = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMAXUW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383E = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMAXUW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F383F = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMAXUD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F383F = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMAXUD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3840 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PMULLD, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3840 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMULLD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3841 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PHMINPOSUW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3841 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPHMINPOSUW, OD.GprRm, SZ.DqDq) (* VdqWdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3843W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGETEXPSD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3845W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSRLVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3845W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSRLVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3846W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSRAVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3847W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSLLVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3847W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPSLLVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F384DW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VRCP14SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3850W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPBUSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3850W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPBUSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3851W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPBUSDS, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3851W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPBUSDS, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3852W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPWSSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3852W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPWSSD, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3 -> struct (VDPBF16PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF2 -> struct (VP4DPWSSD, OD.XmmVvXm, SZ.XDq) (* VzHzMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3853W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPWSSDS, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3853W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPDPWSSDS, OD.XmmVvXm, SZ.VecDef) (* VxHxWdx *)
    | MPref.MPrxF3
    | MPref.MPrxF2 -> struct (VP4DPWSSDS, OD.XmmVvXm, SZ.XDq) (* VzHzMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3854W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPOPCNTB, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3854W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPOPCNTW, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3855W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPOPCNTD, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3855W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPOPCNTQ, OD.GprRm, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3858W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTD, OD.GprRm, SZ.DqdX) (* VxWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3858W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTD, OD.GprRm, SZ.DqdXz) (* VZxzWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3859W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTQ, OD.GprRm, SZ.DqqX) (* VxWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3859W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI32X2, OD.GprRm, SZ.DqqX) (* VxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3859W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTQ, OD.GprRm, SZ.DqqXz) (* VZxzWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F385AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI128, OD.GprRm, SZ.DqQqq) (* VqqMdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F385AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI32X4, OD.GprM, SZ.XDq) (* VxMdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F385AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI64X2, OD.GprM, SZ.XDq) (* VxMdq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F385BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI32X8, OD.GprM, SZ.QqXzRM) (* VdqqMqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F385BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBROADCASTI64X4, OD.GprM, SZ.QqXzRM) (* VdqqMqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3862W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPEXPANDB, OD.GprRm, SZ.VecDef) (* VxHx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3862W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPEXPANDW, OD.GprRm, SZ.VecDef) (* VxHx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3863W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCOMPRESSB, OD.RmGpr, SZ.VecDef) (* VxHx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3863W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPCOMPRESSW, OD.RmGpr, SZ.VecDef) (* VxHx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> raise ParsingFailureException
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3868W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (VP2INTERSECTD, OD.KnVvXm, SZ.VecDef) (* KnHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3868W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (VP2INTERSECTQ, OD.KnVvXm, SZ.VecDef) (* KnHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3870W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDVW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3871W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3871W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3872W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 ->
      struct (VCVTNEPS2BF16, OD.GprRm, SZ.XzX) (* VxWx *)
    | MPref.MPrxF2 ->
      struct (VCVTNE2PS2BF16, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3872W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDVW, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3873W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDVD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3873W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3875W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMI2W, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3876W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMI2D, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3877W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMI2PD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3878 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3878 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTB, OD.GprRm, SZ.DqbX) (* VxWdqb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3879W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTW, OD.GprRm, SZ.DqwX) (* VxWdqw *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTB, OD.GprRm, SZ.DXz) (* VZxzRd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTW, OD.GprRm, SZ.DXz) (* VZxzRd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTD, OD.GprRm, SZ.DXz) (* VZxzRd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387CW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBROADCASTQ, OD.GprRm, SZ.QXz) (* VZxzRq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387DW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPERMT2B, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F387DW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPERMT2W, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3883W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMULTISHIFTQB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F388CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMASKMOVD, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F388CW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMASKMOVQ, OD.XmmVvXm, SZ.VecDef) (* VxHxMx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F388DW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPERMB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F388EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMASKMOVD, OD.XmVvXmm, SZ.VecDef) (* MxVxHx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F388EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPMASKMOVQ, OD.XmVvXmm, SZ.VecDef) (* MxVxHx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F388FW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHUFBITQMB, OD.KnVvXm, SZ.VecDef) (* KnHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3890W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPGATHERDD, OD.XmmXmVv, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3890W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPGATHERDQ, OD.XmmXmVv, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3890W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPGATHERDD, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3891W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPGATHERQD, OD.XmmVvXm, SZ.Dq) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3891W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPGATHERQQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3892W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGATHERDPS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3892W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGATHERDPD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3892W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGATHERDPS, OD.GprRm, SZ.VecDef) (* VZxzWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3893W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGATHERQPS, OD.XmmXmVv, SZ.Dq) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3893W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGATHERQPD, OD.XmmXmVv, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3896W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3896W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3896W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3896W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3897W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3897W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3897W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3897W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3898W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3898W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3898W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD132PD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3899W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD132SS, OD.XmmVvXm, SZ.DqdXz) (* VxHxWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3899W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD132SD, OD.XmmVvXm, SZ.DqqX) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F389AW0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (V4FMADDPS, OD.XmmVvXm, SZ.XDq) (* VzHzMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB132SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB132SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F389BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB132SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (V4FMADDSS, OD.XmmVvXm, SZ.Dq) (* VdqHdqMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFNMADD132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389CW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFNMADD132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F389CW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD132PD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389DW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD132SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389DW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD132SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F389DW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD132SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB132PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB132PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389FW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB132SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F389FW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB132SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38A2W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERDPS, OD.RmGpr, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38A2W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERDPD, OD.RmGpr, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38A3W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERQPS, OD.RmGpr, SZ.XzX) (* VxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38A3W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERQPD, OD.RmGpr, SZ.VecDef) (* VxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A6W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A6W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB213PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A7W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A7W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD213PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A8W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A8W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD213PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38A8W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD213PS, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A9W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD213SS, OD.XmmVvXm, SZ.DqdXz) (* VxHxWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38A9W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD213SD, OD.XmmVvXm, SZ.DqqX) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AAW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFMSUB213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AAW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFMSUB213PD, OD.XmmVvXm, SZ.DqqX) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38AAW0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (V4FNMADDPS, OD.XmmVvXm, SZ.DqXz) (* VzHzMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ABW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFMSUB213SS, OD.XmmVvXm, SZ.DqdX) (* VxHxWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ABW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VFMSUB213SD, OD.XmmVvXm, SZ.DqqX) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38ABW0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (V4FNMADDSS, OD.XmmVvXm, SZ.Dq) (* VdqHdqMdq *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ACW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ACW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD213PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ADW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD213SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38ADW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD213SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38ADW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD213SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AEW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB213PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AEW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB213PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AFW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB213SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38AFW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB213SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38B4W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMADD52LUQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38B5W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPMADD52HUQ, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B6W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B6W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADDSUB231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B7W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B7W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUBADD231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B8W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B8W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38B8W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD231PD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B9W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD231SS, OD.XmmVvXm, SZ.DqdXz) (* VxHxWdqd *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38B9W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMADD231SD, OD.XmmVvXm, SZ.DqqX) (* VxHxWdqq *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BAW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BAW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BBW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB231SS, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BBW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB231SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38BBW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFMSUB231SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BCW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BCW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38BCW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231PD, OD.XmmVvXm, SZ.XzXz) (* VZxzHxWZxz *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BDW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BDW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38BDW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMADD231SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BEW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB231PS, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BEW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB231PD, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BFW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB231SS, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38BFW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VFNMSUB231SD, OD.XmmVvXm, SZ.DqdDq) (* VdqHdqWdqd *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C61W0 = function (* C6 /1 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF0DPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C61W1 = function (* C6 /1 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF0DPD, OD.Mem, SZ.Qq) (* Wqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C62W0 = function (* C6 /2 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF1DPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C62W1 = function (* C6 /2 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF1DPD, OD.Mem, SZ.Qq) (* Wqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C65W0 = function (* C6 /5 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF0DPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C65W1 = function (* C6 /5 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF0DPD, OD.Mem, SZ.Qq) (* Wqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C66W0 = function (* C6 /6 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF1DPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C66W1 = function (* C6 /6 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF1DPD, OD.Mem, SZ.Qq) (* Wqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C71W0 = function (* C7 /1 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF0QPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C71W1 = function (* C7 /1 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF0QPD, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C72W0 = function (* C7 /2 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF1QPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C72W1 = function (* C7 /2 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VGATHERPF1QPD, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C75W0 = function (* C7 /5 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF0QPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C75W1 = function (* C7 /5 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF0QPD, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C76W0 = function (* C7 /6 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF1QPS, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38C76W1 = function (* C7 /6 *)
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VSCATTERPF1QPD, OD.Mem, SZ.VecDef) (* Wdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38CBW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VRCP28SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38CDW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VRSQRT28SD, OD.XmmVvXm, SZ.DqqDq) (* VdqHdqWdqq *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38CFW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGF2P8MULB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38CFW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGF2P8MULB, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38DC = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESENC, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38DC = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESENC, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38DD = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESENCLAST, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38DD = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESENCLAST, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38DE = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESDEC, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38DE = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESDEC, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38DF = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESDECLAST, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F38DF = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VAESDECLAST, OD.XmmVvXm, SZ.VecDef) (* VxHxWx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F0 = function
    | MPref.MPrxNP -> struct (MOVBE, OD.GprRm, SZ.Def) (* GyMy *)
    | MPref.MPrx66 -> struct (MOVBE, OD.GprRm, SZ.Word) (* GwMw *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (CRC32, OD.GprRm, SZ.BV) (* GvEb *)
    | MPref.MPrx66F2 -> struct (CRC32, OD.GprRm, SZ.BV) (* GvEb *)
    | _ -> raise ParsingFailureException

  let nor0F38F1 = function
    | MPref.MPrxNP -> struct (MOVBE, OD.RmGpr, SZ.Def) (* MyGy *)
    | MPref.MPrx66 -> struct (MOVBE, OD.RmGpr, SZ.Word) (* MwGw *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (CRC32, OD.GprRm, SZ.Def) (* GvEy *)
    | MPref.MPrx66F2 -> struct (CRC32, OD.GprRm, SZ.WV) (* GvEw *)
    | _ -> raise ParsingFailureException

  let vex0F38F2 = function
    | MPref.MPrxNP -> struct (ANDN, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F5W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (WRUSSD, OD.MGpr, SZ.Def) (* EyGy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F5W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (WRUSSQ, OD.RmGpr, SZ.Def) (* EyGy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38F5W0 = function
    | MPref.MPrxNP -> struct (BZHI, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (PEXT, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | MPref.MPrxF2 -> struct (PDEP, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38F5W1 = function
    | MPref.MPrxNP -> struct (BZHI, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | MPref.MPrx66 -> raise ParsingFailureException
    | MPref.MPrxF3 -> struct (PEXT, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | MPref.MPrxF2 -> struct (PDEP, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F6W0 = function
    | MPref.MPrxNP -> struct (WRSSD, OD.GprRm, SZ.Def) (* GyEy *)
    | MPref.MPrx66 -> struct (ADCX, OD.GprRm, SZ.Def) (* GyEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F6W1 = function
    | MPref.MPrxNP -> struct (WRSSQ, OD.GprRm, SZ.Def) (* GyEy *)
    | MPref.MPrx66 -> struct (ADCX, OD.GprRm, SZ.Def) (* GyEy *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38F6W0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (MULX, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38F6W1 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (MULX, OD.GprVvRm, SZ.Def) (* GyByEy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F38F7 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F38F7 = function
    | MPref.MPrxNP -> struct (BEXTR, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | MPref.MPrx66 -> struct (SHLX, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | MPref.MPrxF3 -> struct (SARX, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | MPref.MPrxF2 -> struct (SHRX, OD.GprRmVv, SZ.Def) (* GyEyBy *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A00W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMQ, OD.XmmRmImm8, SZ.Qq) (* VqqWqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A01W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMPD, OD.XmmRmImm8, SZ.Qq) (* VqqWqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A02W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBLENDD, OD.XmmVvXmImm8, SZ.VecDef) (* VxVxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A04W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMILPS, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A05W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERMILPD, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A06W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERM2F128, OD.XmmVvXmImm8, SZ.Qq) (* VqqHqqWqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A08 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (ROUNDPS, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A08 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VROUNDPS, OD.XmmRmImm8, SZ.VecDef) (* VxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A09 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (ROUNDPD, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A09 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VROUNDPD, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0A = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VROUNDSS, OD.XmmVvXmImm8, SZ.DqdDq) (* VdqHdqWdqdIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A0B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (ROUNDSD, OD.XmmRmImm8, SZ.DqqDq) (* VdqWdqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0B = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VROUNDSD, OD.XmmVvXmImm8, SZ.DqqDq) (* VdqHdqWdqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A0BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VRNDSCALESD, OD.XmmVvXmImm8, SZ.DqqDq) (* VdqHdqWdqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A0C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (BLENDPS, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0C = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBLENDPS, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0D = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBLENDPD, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0E = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBLENDW, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A0F = function
    | MPref.MPrxNP -> struct (PALIGNR, OD.MmxMmImm8, SZ.QQ) (* PqQqIb *)
    | MPref.MPrx66 ->
      struct (PALIGNR, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A0F = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPALIGNR, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A15 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PEXTRW, OD.XmRegImm8, SZ.DwDq) (* EdwVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A14W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPEXTRB, OD.XmRegImm8, SZ.DbDq) (* EdbVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A15 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPEXTRW, OD.XmRegImm8, SZ.DwDq) (* EdwVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A16 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PEXTRD, OD.XmRegImm8, SZ.DwDq) (* EdwVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A16 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPEXTRD, OD.XmRegImm8, SZ.DwDq) (* EdwVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A17 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (EXTRACTPS, OD.RmXmmImm8, SZ.DDq) (* EdVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A17 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTPS, OD.RmXmmImm8, SZ.DDq) (* EdVdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A18W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTF128, OD.XmmVvXmImm8, SZ.DqQqq) (* VqqHqqWdqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A19W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTF128, OD.XmRegImm8, SZ.DqQq) (* WdqVqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A19W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTF32X4, OD.XmRegImm8, SZ.DqXz) (* WdqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A19W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTF64X2, OD.XmRegImm8, SZ.DqXz) (* WdqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A1AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTF64X4, OD.XmmVvXmImm8, SZ.QqXzRM) (* VZxzHxWqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A1BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTF32X8, OD.XmRegImm8, SZ.QqXz) (* WZqqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A1BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTF64X4, OD.XmRegImm8, SZ.QqXz) (* WZqqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A1EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPUD, OD.KnVvXmImm8, SZ.VecDef) (* KnHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A1EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPUQ, OD.KnVvXmImm8, SZ.VecDef) (* KnHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A20 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (PINSRB, OD.XmmRmImm8, SZ.DbDq) (* VdqEdbIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A20 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRB, OD.XmmVvXmImm8, SZ.DbDq) (* VdqHdqEdbIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A21 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTPS, OD.XmmVvXmImm8, SZ.DqdDq) (* VdqHdqUdqdIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A22W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRD, OD.XmmVvXmImm8, SZ.YDq) (* VdqHdqEyIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A22W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRQ, OD.XmmVvXmImm8, SZ.YDq) (* VdqHdqEyIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A22W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRD, OD.XmmVvXmImm8, SZ.YDq) (* VdqHdqEyIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A22W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPINSRQ, OD.XmmVvXmImm8, SZ.YDq) (* VdqHdqEyIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A25W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPTERNLOGD, OD.XmmVvXmImm8, SZ.XzXz) (* VZxzHxWZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A25W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPTERNLOGQ, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A27W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGETMANTSD, OD.XmmVvXmImm8, SZ.DqqDq) (* VdqHdqWdqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A38 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A38 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTI128, OD.XmmVvXmImm8, SZ.DqQqq) (* VqqHqqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A39W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTI128, OD.XmRegImm8, SZ.DqQq) (* WdqVqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTI32X8, OD.XmmVvXmImm8, SZ.QqXzRM) (* VZxzHxWqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3AW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VINSERTI64X4, OD.XmmVvXmImm8, SZ.QqXzRM) (* VZxzHxWqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTI32X8, OD.XmRegImm8, SZ.QqXz) (* WqqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3BW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VEXTRACTI64X4, OD.XmRegImm8, SZ.QqXz) (* WqqVZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3EW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPUB, OD.KnVvXmImm8, SZ.VecDef) (* KnHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A3EW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPUW, OD.KnVvXmImm8, SZ.VecDef) (* KnHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A43W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VSHUFI32X4, OD.XmmVvXmImm8, SZ.XzXz) (* VZxzHxWZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A43W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VSHUFI64X2, OD.XmmVvXmImm8, SZ.XzXz) (* VZxzHxWZxzIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A44 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCLMULQDQ, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A44 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCLMULQDQ, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException


  let vex0F3A46W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPERM2I128, OD.XmmVvXmImm8, SZ.Qq) (* VqqHqqWqqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A4AW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBLENDVPS, OD.XmmVvXmXmm, SZ.VecDef) (* VxHxWxLx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A4BW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VBLENDVPD, OD.XmmVvXmXmm, SZ.VecDef) (* VxHxWxLx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A4CW0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPBLENDVB, OD.XmmVvXmXmm, SZ.VecDef) (* VxHxWxLx *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A57W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VREDUCESD, OD.XmmVvXmImm8, SZ.DqqDq) (* VdqHdqWdqqIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A60 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PCMPESTRM, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A60 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPESTRM, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A61 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PCMPESTRI, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A61 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPESTRI, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A62 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PCMPISTRM, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A62 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPISTRM, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3A63 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (PCMPISTRI, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3A63 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VPCMPISTRI, OD.XmmRmImm8, SZ.DqDq) (* VdqWdqIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A70W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDW, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A71W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDD, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A71W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHLDQ, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A72W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDW, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A73W0 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDD, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3A73W1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> struct (VPSHRDQ, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3ACEW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGF2P8AFFINEQB, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3ACEW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> (* FIXME *)
      struct (VGF2P8AFFINEQB, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3ACFW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 ->
      struct (VGF2P8AFFINEINVQB, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let evex0F3ACFW1 = function
    | MPref.MPrxNP -> raise ParsingFailureException
    | MPref.MPrx66 -> (* FIXME*)
      struct (VGF2P8AFFINEINVQB, OD.XmmVvXmImm8, SZ.VecDef) (* VxHxWxIb *)
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let nor0F3AF0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3
    | MPref.MPrxF2
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let vex0F3AF0 = function
    | MPref.MPrxNP
    | MPref.MPrx66
    | MPref.MPrxF3 -> raise ParsingFailureException
    | MPref.MPrxF2 -> struct (RORX, OD.XmmRmImm8, SZ.Def) (* GyEyIb *)
    | _ (* MPrx66F2 *) -> raise ParsingFailureException

  let grp1Op = function
    | 0 -> ADD
    | 1 -> OR
    | 2 -> ADC
    | 3 -> SBB
    | 4 -> AND
    | 5 -> SUB
    | 6 -> XOR
    | 7 -> CMP
    | _ -> raise ParsingFailureException

  let grp2Op = function
    | 0 -> ROL
    | 1 -> ROR
    | 2 -> RCL
    | 3 -> RCR
    | 4 -> SHL
    | 5 -> SHR
    | 6 -> InvalOP
    | 7 -> SAR
    | _ -> raise ParsingFailureException

  let grp4Op = function
    | 0 -> INC
    | 1 -> DEC
    | _ -> raise ParsingFailureException

  let grp5 = function
    | 0 -> struct (INC, OD.Mem, SZ.Def, SzCond.Nor)
    | 1 -> struct (DEC, OD.Mem, SZ.Def, SzCond.Nor)
    | 2 -> struct (CALLNear, OD.Mem, SZ.Def, SzCond.F64)
    | 3 -> struct (CALLFar, OD.Mem, SZ.P, SzCond.Nor)
    | 4 -> struct (JMPNear, OD.Mem, SZ.Def, SzCond.F64)
    | 5 -> struct (JMPFar, OD.Dir, SZ.P, SzCond.Nor)
    | 6 -> struct (PUSH, OD.Mem, SZ.Def, SzCond.D64)
    | _ -> raise ParsingFailureException

  let grp7 = function
    | 0 -> struct (SGDT, OD.Mem, SZ.S, SzCond.Nor)
    | 1 -> struct (SIDT, OD.Mem, SZ.S, SzCond.Nor)
    | 2 -> struct (LGDT, OD.Mem, SZ.S, SzCond.Nor)
    | 3 -> struct (LIDT, OD.Mem, SZ.S, SzCond.Nor)
    | 4 -> struct (SMSW, OD.Mem, SZ.MemW, SzCond.Nor)
    | 5 -> struct (RSTORSSP, OD.Mem, SZ.Q, SzCond.Nor)
    | 6 -> struct (LMSW, OD.Mem, SZ.MemW, SzCond.Nor)
    | 7 -> struct (INVLPG, OD.Mem, SZ.MemW, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let grp8Op = function
    | 0 -> InvalOP
    | 1 -> InvalOP
    | 2 -> InvalOP
    | 3 -> InvalOP
    | 4 -> BT
    | 5 -> BTS
    | 6 -> BTR
    | 7 -> BTC
    | _ -> raise ParsingFailureException

  let grp16Op = function
    | 0 -> PREFETCHNTA
    | 1 -> PREFETCHT0
    | 2 -> PREFETCHT1
    | 3 -> PREFETCHT2
    | _ -> raise ParsingFailureException

  let grp17Op = function
    | 1 -> BLSR
    | 2 -> BLSMSK
    | 3 -> BLSI
    | _ -> raise ParsingFailureException

  let getGrp3OpKind oidx sidx oprGrp regBits =
    match regBits with
    | 0b000 when oprGrp = OpGroup.G3A ->
      struct (TEST, OD.RmImm8, SZ.Byte, SzCond.Nor)
    | 0b000 when oprGrp = OpGroup.G3B ->
      struct (TEST, OD.RmImm, SZ.Def, SzCond.Nor)
    | 0b010 -> struct (NOT, oidx, sidx, SzCond.Nor)
    | 0b011 -> struct (NEG, oidx, sidx, SzCond.Nor)
    | 0b100 -> struct (MUL, oidx, sidx, SzCond.Nor)
    | 0b101 -> struct (IMUL, oidx, sidx, SzCond.Nor)
    | 0b110 -> struct (DIV, oidx, sidx, SzCond.Nor)
    | 0b111 -> struct (IDIV, oidx, sidx, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let getGrp6OpKind b regBits =
    match modIsMemory b, regBits with
    | true, 0b000 -> struct (SLDT, OD.Mem, SZ.MemW, SzCond.Nor)
    | false, 0b000 -> struct (SLDT, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b001 -> struct (STR, OD.Mem, SZ.MemW, SzCond.Nor)
    | false, 0b001 -> struct (STR, OD.Mem, SZ.Def, SzCond.Nor)
    | _, 0b010 -> struct (LLDT, OD.Mem, SZ.MemW, SzCond.Nor)
    | _, 0b011 -> struct (LTR, OD.Mem, SZ.MemW, SzCond.Nor)
    | _, 0b100 -> struct (VERR, OD.Mem, SZ.MemW, SzCond.Nor)
    | _, 0b101 -> struct (VERW, OD.Mem, SZ.MemW, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let parseGrp7OpKind (rhlp: ReadHelper) b regBits =
    if modIsMemory b then grp7 regBits
    else
      match regBits, getRM b with
      | 0b000, 0b001 ->
        rhlp.IncPos (); struct (VMCALL, OD.No, SZ.Def, SzCond.Nor)
      | 0b000, 0b010 ->
        rhlp.IncPos (); struct (VMLAUNCH, OD.No, SZ.Def, SzCond.Nor)
      | 0b000, 0b011 ->
        rhlp.IncPos (); struct (VMRESUME, OD.No, SZ.Def, SzCond.Nor)
      | 0b000, 0b100 ->
        rhlp.IncPos (); struct (VMXOFF, OD.No, SZ.Def, SzCond.Nor)
      | 0b001, 0b000 ->
        rhlp.IncPos (); struct (MONITOR, OD.No, SZ.Def, SzCond.Nor)
      | 0b001, 0b001 ->
        rhlp.IncPos (); struct (MWAIT, OD.No, SZ.Def, SzCond.Nor)
      | 0b001, 0b010 ->
        rhlp.IncPos (); struct (CLAC, OD.No, SZ.Def, SzCond.Nor)
      | 0b001, 0b011 ->
        rhlp.IncPos (); struct (STAC, OD.No, SZ.Def, SzCond.Nor)
      | 0b010, 0b000 ->
        rhlp.IncPos (); struct (XGETBV, OD.No, SZ.Def, SzCond.Nor)
      | 0b010, 0b001 ->
        rhlp.IncPos (); struct (XSETBV, OD.No, SZ.Def, SzCond.Nor)
      | 0b010, 0b100 ->
        rhlp.IncPos (); struct (VMFUNC, OD.No, SZ.Def, SzCond.Nor)
      | 0b010, 0b101 ->
        rhlp.IncPos (); struct (XEND, OD.No, SZ.Def, SzCond.Nor)
      | 0b010, 0b110 ->
        rhlp.IncPos (); struct (XTEST, OD.No, SZ.Def, SzCond.Nor)
      | 0b100, _     -> struct (SMSW, OD.Mem, SZ.Def, SzCond.Nor)
      | 0b101, 0b000 ->
        rhlp.IncPos (); struct (SETSSBSY, OD.No, SZ.Def, SzCond.Nor)
      | 0b101, 0b010 ->
        rhlp.IncPos (); struct (SAVEPREVSSP, OD.No, SZ.Def, SzCond.Nor)
      | 0b101, 0b110 ->
        rhlp.IncPos (); struct (RDPKRU, OD.No, SZ.Def, SzCond.Nor)
      | 0b101, 0b111 ->
        rhlp.IncPos (); struct (WRPKRU, OD.No, SZ.Def, SzCond.Nor)
      | 0b110, _     -> struct (LMSW, OD.Mem, SZ.MemW, SzCond.Nor)
      | 0b111, 0b000 ->
#if !EMULATION
        ensure32 rhlp
#endif
        rhlp.IncPos (); struct (SWAPGS, OD.No, SZ.Def, SzCond.Nor)
      | 0b111, 0b001 ->
        rhlp.IncPos (); struct (RDTSCP, OD.No, SZ.Def, SzCond.Nor)
      | _ -> raise ParsingFailureException

  let getGrp9OpKind (rhlp: ReadHelper) b regBits =
    let hasOprSzPref = hasOprSz rhlp.Prefixes
    let hasREPZPref = hasREPZ rhlp.Prefixes
    let hasREXWPref = hasREXW rhlp.REXPrefix
    match modIsMemory b, regBits, hasOprSzPref, hasREPZPref, hasREXWPref with
    | true,  0b001, false, false, false ->
      struct (CMPXCHG8B, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b001, false, false, true  ->
      struct (CMPXCHG16B, OD.Mem, SZ.Dq, SzCond.Nor)
    | true,  0b011, false, false, false ->
      struct (XRSTORS, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b011, false, false, true  ->
      struct (XRSTORS64, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b100, false, false, false ->
      struct (XSAVEC, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b100, false, false, true  ->
      struct (XSAVEC64, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b101, false, false, false ->
      struct (XSAVES, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b101, false, false, true  ->
      struct (XSAVES64, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b110, false, false, _     ->
      struct (VMPTRLD, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b111, false, false, _     ->
      struct (VMPTRST, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b110, true,  false, _     ->
      struct (VMCLEAR, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b110, false, true,  _     ->
      struct (VMXON, OD.Mem, SZ.Q, SzCond.Nor)
    | true,  0b111, false, true,  _     ->
      struct (VMPTRST, OD.Mem, SZ.Q, SzCond.Nor)
    | false, 0b110, false, false, _     ->
      struct (RDRAND, OD.Mem, SZ.Def, SzCond.Nor)
    | false, 0b111, false, false, _     ->
      struct (RDSEED, OD.Mem, SZ.Def, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let getGrp11OpKind span rhlp op oidx1 sz1 b reg oidx2 sz2 =
    match reg with
    | 0b000 -> struct (MOV, oidx2, sz2, SzCond.Nor)
    | 0b111 when modIsMemory b -> raise ParsingFailureException
    | 0b111 ->
      if (rhlp: ReadHelper).ReadByte span = 0xF8uy then
        struct (op, oidx1, sz1, SzCond.Nor)
      else raise ParsingFailureException
    | _ -> raise ParsingFailureException

  let getGrp12OpKind rhlp b regBits =
    match modIsMemory b, regBits, hasOprSz (selectPrefix rhlp) with
    | false, 0b010, false -> struct (PSRLW, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b010, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRLW, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRLW, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b100, false -> struct (PSRAW, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b100, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRAW, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRAW, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b110, false -> struct (PSLLW, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b110, true  ->
      if rhlp.VEXInfo = None then
        struct (PSLLW, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSLLW, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let getGrp13OpKind rhlp b regBits =
    match modIsMemory b, regBits, hasOprSz (selectPrefix rhlp) with
    | false, 0b010, false -> struct (PSRLD, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b010, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRLD, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRLD, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b100, false -> struct (PSRAD, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b100, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRAD, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRAD, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b110, false -> struct (PSLLD, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b110, true  ->
      if rhlp.VEXInfo = None then
        struct (PSLLD, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSLLD, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let getGrp14OpKind rhlp b regBits =
    match modIsMemory b, regBits, hasOprSz (selectPrefix rhlp) with
    | false, 0b010, false ->
      struct (PSRLQ, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b010, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRLQ, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRLQ, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b011, true  ->
      if rhlp.VEXInfo = None then
        struct (PSRLDQ, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSRLDQ, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b110, false -> struct (PSLLQ, OD.MmxImm8, SZ.Q, SzCond.Nor)
    | false, 0b110, true  ->
      if rhlp.VEXInfo = None then
        struct (PSLLQ, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSLLQ, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | false, 0b111, true  ->
      if rhlp.VEXInfo = None then
        struct (PSLLDQ, OD.RmImm8, SZ.Dq, SzCond.Nor)
      else struct (VPSLLDQ, OD.VvRmImm8, SZ.VecDef, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let parseGrp15OpKind (rhlp: ReadHelper) b regBits =
    match modIsMemory b, regBits, rhlp.Prefixes with
    | true, 0b000, Prefix.PrxNone ->
      let op = if hasREXW rhlp.REXPrefix then FXSAVE64 else FXSAVE
      struct (op, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b001, Prefix.PrxNone ->
      let op =
        if hasREXW rhlp.REXPrefix then FXRSTOR64 else FXRSTOR
      struct (op, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b010, Prefix.PrxNone -> struct (LDMXCSR, OD.Mem, SZ.D, SzCond.Nor)
    | true, 0b011, Prefix.PrxNone -> struct (STMXCSR, OD.Mem, SZ.D, SzCond.Nor)
    | true, 0b100, Prefix.PrxNone -> struct (XSAVE, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b101, Prefix.PrxNone -> struct (XRSTOR, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b110, Prefix.PrxNone ->
      struct (XSAVEOPT, OD.Mem, SZ.Def, SzCond.Nor)
    | true, 0b110, Prefix.PrxOPSIZE ->
      struct (CLWB, OD.Mem, SZ.Byte, SzCond.Nor)
    | true, 0b110, Prefix.PrxREPZ -> struct (CLRSSBSY, OD.Mem, SZ.Q, SzCond.Nor)
    | true, 0b111, Prefix.PrxNone -> struct (CLFLUSH, OD.Mem, SZ.BV, SzCond.Nor)
    | false, 0b101, Prefix.PrxNone ->
      rhlp.IncPos (); struct (LFENCE, OD.No, SZ.Def, SzCond.Nor)
    | false, 0b110, Prefix.PrxNone ->
      rhlp.IncPos (); struct (MFENCE, OD.No, SZ.Def, SzCond.Nor)
    | false, 0b111, Prefix.PrxNone ->
      rhlp.IncPos (); struct (SFENCE, OD.No, SZ.Def, SzCond.Nor)
    | false, 0b000, Prefix.PrxREPZ ->
      struct (RDFSBASE, OD.Gpr, SZ.Def, SzCond.Nor)
    | false, 0b001, Prefix.PrxREPZ ->
      struct (RDGSBASE, OD.Gpr, SZ.Def, SzCond.Nor)
    | false, 0b010, Prefix.PrxREPZ ->
      struct (WRFSBASE, OD.Gpr, SZ.Def, SzCond.Nor)
    | false, 0b011, Prefix.PrxREPZ ->
      struct (WRGSBASE, OD.Gpr, SZ.Def, SzCond.Nor)
    | false, 0b101, Prefix.PrxREPZ ->
      let op = if hasREXW rhlp.REXPrefix then INCSSPQ else INCSSPD
      struct (op, OD.Gpr, SZ.Def, SzCond.Nor)
    | _ -> raise ParsingFailureException

  let parseGrpOpKind span (rhlp: ReadHelper) oidx sidx oprGrp =
    let b = rhlp.PeekByte span
    let r = getReg b
    match oprGrp with
    | OpGroup.G1 -> struct (grp1Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G1Inv64 ->
#if !EMULATION
      ensure32 rhlp
#endif
      struct (grp1Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G1A -> struct (POP, oidx, sidx, SzCond.D64)
    | OpGroup.G2 when r = 0b110 -> raise ParsingFailureException
    | OpGroup.G2 -> struct (grp2Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G3A | OpGroup.G3B -> getGrp3OpKind oidx sidx oprGrp r
    | OpGroup.G4 -> struct (grp4Op r, OD.Mem, SZ.Byte, SzCond.Nor)
    | OpGroup.G5 -> grp5 r
    | OpGroup.G6 -> getGrp6OpKind b r
    | OpGroup.G7 -> parseGrp7OpKind rhlp b r
    | OpGroup.G8 -> struct (grp8Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G9 -> getGrp9OpKind rhlp b r
    | OpGroup.G11A ->
      getGrp11OpKind span rhlp XABORT OD.Imm8 SZ.Def b r oidx sidx
    | OpGroup.G11B ->
      getGrp11OpKind span rhlp XBEGIN OD.Rel SZ.D64 b r oidx sidx
    | OpGroup.G12 -> getGrp12OpKind rhlp b r
    | OpGroup.G13 -> getGrp13OpKind rhlp b r
    | OpGroup.G14 -> getGrp14OpKind rhlp b r
    | OpGroup.G15 -> parseGrp15OpKind rhlp b r
    | OpGroup.G16 -> struct (grp16Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G17 -> struct (grp17Op r, oidx, sidx, SzCond.Nor)
    | OpGroup.G10
    | _ ->
      raise ParsingFailureException (* Not implemented yet *)

  /// Add BND prefix (Intel MPX extension).
  let addBND (rhlp: ReadHelper) =
    if hasREPNZ rhlp.Prefixes then
      rhlp.Prefixes <- Prefix.PrxBND ||| (ClearGrp1PrefMask &&& rhlp.Prefixes)
    else ()

  let inline getMandPrx (prefix: Prefix) =
    match int prefix &&& 0x40a with
    | 0x402 -> MPref.MPrx66F2
    | 0x2 -> MPref.MPrxF2
    | 0x400 -> MPref.MPrx66
    | 0x8 -> MPref.MPrxF3
    | 0x0 -> MPref.MPrxNP
    | _ -> raise ParsingFailureException

  /// Some instructions use 66/F2/F3 prefix as a mandatory prefix. When both
  /// VEX.pp and old-style prefix are used, the VEX.pp is used to select the
  /// opcodes. But if VEX.pp does not exist, then we have to use the old-style
  /// prefix, and we have to filter out the prefixes because they are not going
  /// to be used as a normal prefixes. They will only be used as a mandatory
  /// prefix to decide the opcode.
  let inline filterPrefs (prefix: Prefix) = prefix &&& ClearVEXPrefMask

  let getInstr prefix fnInstr = fnInstr (getMandPrx prefix)

  /// The main instruction rendering function.
  let render span rhlp opcode szCond (oidx: OprDesc) (sidx: SizeKind) =
    (rhlp: ReadHelper).SzComputers[int sidx].Render rhlp szCond
    exceptionalOperationSize opcode rhlp
    let oprs = rhlp.OprParsers[int oidx].Render (span, rhlp)
    newInsInfo rhlp opcode oprs

  /// Parse group Opcodes: Vol.2C A-19 Table A-6. Opcode Extensions for One- and
  /// Two-byte Opcodes by Group Number.
  let parseGrpOp span rhlp grp oidx sidx =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp oidx sidx grp
    if isBranch op then addBND rhlp |> ignore
    elif isCETInstr op then rhlp.Prefixes <- ClearGrp1PrefMask &&& rhlp.Prefixes
    else ()
    render span rhlp op szCond oidx szidx

  /// Normal/VEX
  let parseVEX span (rhlp: ReadHelper) fnNor fnVex =
    match rhlp.VEXInfo with
    | None ->
      let struct (op, oidx, sidx) = fnNor (getMandPrx rhlp.Prefixes)
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      render span rhlp op SzCond.Nor oidx sidx
    | Some v ->
      let struct (op, oidx, sidx) = fnVex (getMandPrx v.VPrefixes)
      render span rhlp op SzCond.Nor oidx sidx

  /// Normal(REX.W), VEX(REX.W)
  let selectVEXW (span: ByteSpan) rhlp fnNorW0 fnNorW1 fnVexW0 fnVexW1 =
    match (rhlp: ReadHelper).VEXInfo with
    | None ->
      let fnNor = if hasREXW rhlp.REXPrefix then fnNorW1 else fnNorW0
      let ins = getInstr rhlp.Prefixes fnNor
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      ins
    | Some v ->
      let fnVex = if hasREXW rhlp.REXPrefix then fnVexW1 else fnVexW0
      getInstr v.VPrefixes fnVex

  /// Normal/VEX (Both REX.W)
  let parseVEXW span rhlp fnNorW0 fnNorW1 fnVexW0 fnVexW1 =
    let struct (op, oidx, sidx) =
      selectVEXW span rhlp fnNorW0 fnNorW1 fnVexW0 fnVexW1
    render span rhlp op SzCond.Nor oidx sidx

  /// Normal(REX.W), VEX(REX.W)
  /// Normal, VEX, EVEX(REX.W)
  let selectEVEX (rhlp: ReadHelper) fnNor fnVex fnEVexW0 fnEVexW1 =
    match rhlp.VEXInfo with
    | None ->
      let ins = getInstr rhlp.Prefixes fnNor
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      ins
    | Some v ->
      if v.VEXType &&& VEXType.EVEX = VEXType.EVEX then
        let fnEVex = if hasREXW rhlp.REXPrefix then fnEVexW1 else fnEVexW0
        getInstr v.VPrefixes fnEVex
      else getInstr v.VPrefixes fnVex

  /// Normal/VEX/EVEX (EVEX REX.W)
  let parseEVEX span rhlp fnNor fnVex fnEVexW0 fnEVexW1 =
    let struct (op, oidx, sidx) =
      selectEVEX rhlp fnNor fnVex fnEVexW0 fnEVexW1
    render span rhlp op SzCond.Nor oidx sidx

  /// VEX(REX.W), EVEX(REX.W)
  let selectEVEXW (rhlp: ReadHelper) fnVexW0 fnVexW1 fnEVexW0 fnEVexW1 =
    match rhlp.VEXInfo with
    | None -> raise ParsingFailureException
    | Some v ->
      if v.VEXType &&& VEXType.EVEX = VEXType.EVEX then
        let fnEVex = if hasREXW rhlp.REXPrefix then fnEVexW1 else fnEVexW0
        getInstr v.VPrefixes fnEVex
      else
        let fnVex = if hasREXW rhlp.REXPrefix then fnVexW1 else fnVexW0
        getInstr v.VPrefixes fnVex

  /// VEX/EVEX (Both REX.W)
  let parseEVEXW span rhlp fnVexW0 fnVexW1 fnEVexW0 fnEVexW1 =
    let struct (op, oidx, sidx) =
      selectEVEXW rhlp fnVexW0 fnVexW1 fnEVexW0 fnEVexW1
    render span rhlp op SzCond.Nor oidx sidx

  /// Parse non-VEX instructions.
  let parseNonVEX span (rhlp: ReadHelper) fnNor =
    let struct (op, oidx, sidx) = getInstr rhlp.Prefixes fnNor
    rhlp.Prefixes <- filterPrefs rhlp.Prefixes
    render span rhlp op SzCond.Nor oidx sidx

  /// Parse non-VEX instructions.
  let pVEXByMem span (rhlp: ReadHelper) fnNorM fnNorR fnVexM fnVexR =
    let struct (fnNor, fnVex) =
      if rhlp.PeekByte span |> modIsMemory then struct (fnNorM, fnVexM)
      else struct (fnNorR, fnVexR)
    parseVEX span rhlp fnNor fnVex

  /// Parse BND-related instructions.
  let parseBND span (rhlp: ReadHelper) szCond fnBND =
    let struct (op, oidx, sidx) = getInstr rhlp.Prefixes fnBND
    rhlp.Prefixes <- filterPrefs rhlp.Prefixes
    render span rhlp op szCond oidx sidx

  let parseCETInstr span (rhlp: ReadHelper) =
    let struct (op, oidx, sidx) =
      match rhlp.PeekByte span with
      | 0xFAuy -> rhlp.IncPos (); struct (ENDBR64, OD.No, SZ.Def)
      | 0xFBuy -> rhlp.IncPos (); struct (ENDBR32, OD.No, SZ.Def)
      | b when getReg b = 0b001 && getMod b = 0b11 ->
        let op = if hasREXW rhlp.REXPrefix then RDSSPQ else RDSSPD
        struct (op, OD.Gpr, SZ.Def)
      | _ -> raise InvalidOpcodeException
    rhlp.Prefixes <- ClearGrp1PrefMask &&& rhlp.Prefixes
    render span rhlp op SzCond.Nor oidx sidx

  let parseESCOp span (rhlp: ReadHelper) escFlag getOpIn getOpOut =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getOpIn modRM
      let effOprSize =
        match escFlag with
        | 0xD9uy -> getReg modRM |> getD9EscEffOprSizeByModRM
        | 0xDBuy -> getReg modRM |> getDBEscEffOprSizeByModRM
        | 0xDDuy -> getReg modRM |> getDDEscEffOprSizeByModRM
        | 0xDFuy -> getReg modRM |> getDFEscEffOprSizeByModRM
        | _ -> escFlag |> getEscEffOprSizeByESCOp
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getOpOut modRM
      newInsInfo rhlp opcode oprs

  /// When the first two bytes are 0F38.
  /// Table A-4 of Volume 2 (Three-byte Opcode Map : First Two Bytes are 0F 38H)
  let parseThreeByteOp1 span (rhlp: ReadHelper) =
    match rhlp.ReadByte span with
    | 0x00uy -> parseVEX span rhlp nor0F3800 vex0F3800
    | 0x01uy -> parseVEX span rhlp nor0F3801 vex0F3801
    | 0x02uy -> parseVEX span rhlp nor0F3802 vex0F3802
    | 0x03uy -> parseVEX span rhlp nor0F3803 vex0F3803
    | 0x05uy -> parseVEX span rhlp nor0F3805 vex0F3805
    | 0x06uy -> parseVEX span rhlp nor0F3806 vex0F3806
    | 0x07uy -> parseVEX span rhlp nor0F3807 vex0F3807
    | 0x08uy -> parseVEX span rhlp nor0F3808 vex0F3808
    | 0x09uy -> parseVEX span rhlp nor0F3809 vex0F3809
    | 0x0auy -> parseVEX span rhlp nor0F380A vex0F380A
    | 0x0buy -> parseVEX span rhlp nor0F380B vex0F380B
    | 0x0cuy -> parseEVEXW span rhlp vex0F380CW0 notEn notEn notEn
    | 0x14uy -> parseEVEXW span rhlp notEn notEn evex0F3814W0 evex0F3814W1
    | 0x15uy -> parseVEX span rhlp nor0F3815 notEn
    | 0x16uy -> parseVEXW span rhlp notEn notEn vex0F3816W0 notEn
    | 0x17uy -> parseVEX span rhlp nor0F3817 vex0F3817
    | 0x18uy -> parseEVEXW span rhlp vex0F3818W0 notEn evex0F3818W0 notEn
    | 0x19uy -> parseEVEXW span rhlp vex0F3819W0 notEn notEn evex0F3819W1
    | 0x1auy -> parseVEXW span rhlp notEn notEn vex0F381AW0 notEn
    | 0x1cuy -> parseVEX span rhlp nor0F381C vex0F381C
    | 0x1duy -> parseVEX span rhlp nor0F381D vex0F381D
    | 0x1euy -> parseVEX span rhlp nor0F381E vex0F381E
    | 0x1fuy -> parseEVEXW span rhlp notEn notEn notEn evex0F381FW1
    | 0x20uy -> parseVEX span rhlp nor0F3820 vex0F3820
    | 0x21uy -> parseVEX span rhlp nor0F3821 vex0F3821
    | 0x22uy -> parseVEX span rhlp nor0F3822 vex0F3822
    | 0x23uy -> parseVEX span rhlp nor0F3823 vex0F3823
    | 0x24uy -> parseVEX span rhlp nor0F3824 vex0F3824
    | 0x25uy -> parseVEX span rhlp nor0F3825 vex0F3825
    | 0x28uy -> parseVEX span rhlp nor0F3828 vex0F3828
    | 0x29uy -> parseVEX span rhlp nor0F3829 vex0F3829
    | 0X2auy -> parseEVEXW span rhlp notEn notEn notEn evex0F382AW1
    | 0x2buy -> parseVEX span rhlp nor0F382B vex0F382B
    | 0x2cuy -> parseEVEXW span rhlp vex0F382CW0 notEn evex0F382CW0 evex0F382CW1
    | 0x2duy -> parseEVEXW span rhlp vex0F382DW0 notEn evex0F382DW0 evex0F382DW1
    | 0x2euy -> parseVEXW span rhlp notEn notEn vex0F382EW0 notEn
    | 0x2fuy -> parseVEXW span rhlp notEn notEn vex0F382FW0 notEn
    | 0x30uy -> parseEVEX span rhlp nor0F3830 vex0F3830 evex0F3830 evex0F3830
    | 0x31uy -> parseVEX span rhlp nor0F3831 vex0F3831
    | 0x32uy -> parseVEX span rhlp nor0F3832 vex0F3832
    | 0x33uy -> parseEVEX span rhlp nor0F3833 vex0F3833 evex0F3833 evex0F3833
    | 0x34uy -> parseVEX span rhlp nor0F3834 vex0F3834
    | 0x35uy -> parseVEX span rhlp nor0F3835 vex0F3835
    | 0x36uy -> parseEVEXW span rhlp vex0F3836W0 notEn notEn notEn
    | 0x37uy -> parseVEX span rhlp nor0F3837 vex0F3837
    | 0x38uy -> parseVEX span rhlp nor0F3838 vex0F3838
    | 0x39uy -> parseEVEX span rhlp nor0F3839 vex0F3839 evex0F3839W0 notEn
    | 0x3auy -> parseEVEX span rhlp nor0F383A vex0F383A evex0F383AW0 notEn
    | 0x3buy -> parseVEX span rhlp nor0F383B vex0F383B
    | 0x3cuy -> parseVEX span rhlp nor0F383C vex0F383C
    | 0x3duy -> parseVEX span rhlp nor0F383D vex0F383D
    | 0x3euy -> parseVEX span rhlp nor0F383E vex0F383E
    | 0x3fuy -> parseVEX span rhlp nor0F383F vex0F383F
    | 0x40uy -> parseVEX span rhlp nor0F3840 vex0F3840
    | 0x41uy -> parseVEX span rhlp nor0F3841 vex0F3841
    | 0x43uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3843W1
    | 0x45uy -> parseEVEXW span rhlp vex0F3845W0 vex0F3845W1 notEn notEn
    | 0x46uy -> parseEVEXW span rhlp vex0F3846W0 notEn notEn notEn
    | 0x47uy -> parseEVEXW span rhlp vex0F3847W0 vex0F3847W1 notEn notEn
    | 0x4Duy -> parseEVEXW span rhlp notEn notEn notEn evex0F384DW1
    | 0x50uy -> parseEVEXW span rhlp vex0F3850W0 notEn evex0F3850W0 notEn
    | 0x51uy -> parseEVEXW span rhlp vex0F3851W0 notEn evex0F3851W0 notEn
    | 0x52uy -> parseEVEXW span rhlp vex0F3852W0 notEn evex0F3852W0 notEn
    | 0x53uy -> parseEVEXW span rhlp vex0F3853W0 notEn evex0F3853W0 notEn
    | 0x54uy -> parseEVEXW span rhlp notEn notEn evex0F3854W0 evex0F3854W1
    | 0x55uy -> parseEVEXW span rhlp notEn notEn evex0F3855W0 evex0F3855W1
    | 0x58uy -> parseEVEXW span rhlp vex0F3858W0 notEn evex0F3858W0 notEn
    | 0x59uy -> parseEVEXW span rhlp vex0F3859W0 notEn evex0F3859W0 evex0F3859W1
    | 0x5Auy -> parseEVEXW span rhlp vex0F385AW0 notEn evex0F385AW0 evex0F385AW1
    | 0x5Buy -> parseEVEXW span rhlp notEn notEn evex0F385BW0 evex0F385BW1
    | 0x62uy -> parseEVEXW span rhlp notEn notEn evex0F3862W0 evex0F3862W1
    | 0x63uy -> parseEVEXW span rhlp notEn notEn evex0F3863W0 evex0F3863W1
    | 0x68uy -> parseEVEXW span rhlp notEn notEn evex0F3868W0 evex0F3868W1
    | 0x70uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3870W1
    | 0x71uy -> parseEVEXW span rhlp notEn notEn evex0F3871W0 evex0F3871W1
    | 0x72uy -> parseEVEXW span rhlp notEn notEn evex0F3872W0 evex0F3872W1
    | 0x73uy -> parseEVEXW span rhlp notEn notEn evex0F3873W0 evex0F3873W1
    | 0x75uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3875W1
    | 0x76uy -> parseEVEXW span rhlp notEn notEn evex0F3876W0 notEn
    | 0x77uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3877W1
    | 0x78uy -> parseVEX span rhlp nor0F3878 vex0F3878
    | 0x79uy -> parseEVEXW span rhlp vex0F3879W0 notEn notEn notEn
    | 0x7Auy -> parseEVEXW span rhlp notEn notEn evex0F387AW0 notEn
    | 0x7Buy -> parseEVEXW span rhlp notEn notEn evex0F387BW0 notEn
    | 0x7Cuy -> parseEVEXW span rhlp notEn notEn evex0F387CW0 evex0F387CW1
    | 0x7Duy -> parseEVEXW span rhlp notEn notEn evex0F387DW0 evex0F387DW1
    | 0x83uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3883W1
    | 0x8Cuy -> parseVEXW span rhlp notEn notEn vex0F388CW0 vex0F388CW1
    | 0x8Duy -> parseEVEXW span rhlp notEn notEn evex0F388DW0 notEn
    | 0x8Euy -> parseVEXW span rhlp notEn notEn vex0F388EW0 vex0F388EW1
    | 0x8Fuy -> parseEVEXW span rhlp notEn notEn evex0F388FW0 notEn
    | 0x90uy -> parseEVEXW span rhlp vex0F3890W0 vex0F3890W1 evex0F3890W0 notEn
    | 0x91uy -> parseEVEXW span rhlp vex0F3891W0 vex0F3891W1 notEn notEn
    | 0x92uy -> parseEVEXW span rhlp vex0F3892W0 vex0F3892W1 evex0F3892W0 notEn
    | 0x93uy -> parseEVEXW span rhlp vex0F3893W0 vex0F3893W1 notEn notEn
    | 0x96uy ->
      parseEVEXW span rhlp vex0F3896W0 vex0F3896W1 evex0F3896W0 evex0F3896W1
    | 0x97uy ->
      parseEVEXW span rhlp vex0F3897W0 vex0F3897W1 evex0F3897W0 evex0F3897W1
    | 0x98uy -> parseEVEXW span rhlp vex0F3898W0 vex0F3898W1 notEn evex0F3898W1
    | 0x99uy -> parseVEXW span rhlp notEn notEn vex0F3899W0 vex0F3899W1
    | 0x9Auy -> parseEVEXW span rhlp vex0F389AW0 vex0F389AW1 evex0F389AW0 notEn
    | 0x9Buy -> parseEVEXW span rhlp vex0F389BW0 vex0F389BW1 evex0F389BW0 notEn
    | 0x9Cuy -> parseEVEXW span rhlp vex0F389CW0 vex0F389CW1 notEn evex0F389CW1
    | 0x9Duy -> parseEVEXW span rhlp vex0F389DW0 vex0F389DW1 notEn evex0F389DW1
    | 0x9Euy -> parseEVEXW span rhlp vex0F389EW0 vex0F389EW1 notEn notEn
    | 0x9Fuy -> parseEVEXW span rhlp vex0F389FW0 vex0F389FW1 notEn notEn
    | 0xA2uy -> parseEVEXW span rhlp notEn notEn evex0F38A2W0 evex0F38A2W1
    | 0xA3uy -> parseEVEXW span rhlp notEn notEn evex0F38A3W0 evex0F38A3W1
    | 0xA6uy -> parseEVEXW span rhlp vex0F38A6W0 vex0F38A6W1 notEn notEn
    | 0xA7uy -> parseEVEXW span rhlp vex0F38A7W0 vex0F38A7W1 notEn notEn
    | 0xA8uy -> parseEVEXW span rhlp vex0F38A8W0 vex0F38A8W1 evex0F38A8W0 notEn
    | 0xA9uy -> parseVEXW span rhlp notEn notEn vex0F38A9W0 vex0F38A9W1
    | 0xAAuy -> parseEVEXW span rhlp vex0F38AAW0 vex0F38AAW1 evex0F38AAW0 notEn
    | 0xABuy -> parseEVEXW span rhlp vex0F38ABW0 vex0F38ABW1 evex0F38ABW0 notEn
    | 0xACuy -> parseEVEXW span rhlp vex0F38ACW0 vex0F38ACW1 notEn notEn
    | 0xADuy -> parseEVEXW span rhlp vex0F38ADW0 vex0F38ADW1 notEn evex0F38ADW1
    | 0xAEuy -> parseEVEXW span rhlp vex0F38AEW0 vex0F38AEW1 notEn notEn
    | 0xAFuy -> parseEVEXW span rhlp vex0F38AFW0 vex0F38AFW1 notEn notEn
    | 0xB4uy -> parseEVEXW span rhlp notEn notEn notEn evex0F38B4W1
    | 0xB5uy -> parseEVEXW span rhlp notEn notEn notEn evex0F38B5W1
    | 0xB6uy -> parseEVEXW span rhlp vex0F38B6W0 vex0F38B6W1 notEn evex0F38B8W1
    | 0xB7uy -> parseEVEXW span rhlp vex0F38B7W0 vex0F38B7W1 notEn evex0F38B8W1
    | 0xB8uy -> parseEVEXW span rhlp vex0F38B8W0 vex0F38B8W1 notEn evex0F38B8W1
    | 0xB9uy -> parseVEXW span rhlp notEn notEn vex0F38B9W0 vex0F38B9W1
    | 0xBAuy -> parseEVEXW span rhlp vex0F38BAW0 vex0F38BAW1 notEn notEn
    | 0xBBuy -> parseEVEXW span rhlp vex0F38BBW0 vex0F38BBW1 notEn evex0F38BBW1
    | 0xBCuy -> parseEVEXW span rhlp vex0F38BCW0 vex0F38BCW1 notEn evex0F38BCW1
    | 0xBDuy -> parseEVEXW span rhlp vex0F38BDW0 vex0F38BDW1 notEn evex0F38BDW1
    | 0xBEuy -> parseEVEXW span rhlp vex0F38BEW0 vex0F38BEW1 notEn notEn
    | 0xBFuy -> parseEVEXW span rhlp vex0F38BFW0 vex0F38BFW1 notEn notEn
    | 0xC6uy when isReg001 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C61W0 evex0F38C61W1
    | 0xC6uy when isReg010 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C62W0 evex0F38C62W1
    | 0xC6uy when isReg101 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C65W0 evex0F38C65W1
    | 0xC6uy when isReg110 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C66W0 evex0F38C66W1
    | 0xC7uy when isReg001 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C71W0 evex0F38C71W1
    | 0xC7uy when isReg010 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C72W0 evex0F38C72W1
    | 0xC7uy when isReg101 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C75W0 evex0F38C75W1
    | 0xC7uy when isReg110 span rhlp ->
      parseEVEXW span rhlp notEn notEn evex0F38C76W0 evex0F38C76W1
    | 0xCBuy -> parseEVEXW span rhlp notEn notEn notEn evex0F38CBW1
    | 0xCDuy -> parseEVEXW span rhlp notEn notEn notEn evex0F38CDW1
    | 0xCFuy -> parseEVEXW span rhlp evex0F38CFW0 notEn evex0F38CFW0 notEn
    | 0xDCuy -> parseEVEX span rhlp notEn vex0F38DC evex0F38DC evex0F38DC
    | 0xDDuy -> parseEVEX span rhlp notEn vex0F38DD evex0F38DD evex0F38DD
    | 0xDEuy -> parseEVEX span rhlp notEn vex0F38DE evex0F38DE evex0F38DE
    | 0xDFuy -> parseEVEX span rhlp notEn vex0F38DF evex0F38DF evex0F38DF
    | 0xF0uy -> parseNonVEX span rhlp nor0F38F0
    | 0xF1uy -> parseNonVEX span rhlp nor0F38F1
    | 0xF2uy -> parseVEX span rhlp notEn vex0F38F2
    | 0xF3uy ->
      if Option.isNone rhlp.VEXInfo then raise ParsingFailureException
      else parseGrpOp span rhlp OpGroup.G17 OD.VvRm SZ.Def
    | 0xF5uy ->
      parseVEXW span rhlp nor0F38F5W0 nor0F38F5W1 vex0F38F5W0 vex0F38F5W1
    | 0xF6uy ->
      parseVEXW span rhlp nor0F38F6W0 nor0F38F6W1 vex0F38F6W0 vex0F38F6W1
    | 0xF7uy -> parseVEX span rhlp nor0F38F7 vex0F38F7
    | _ -> raise ParsingFailureException

  /// When the first two bytes are 0F3A.
  /// Table A-5 of Volume 2 (Three-byte Opcode Map : First Two Bytes are 0F 3AH)
  let parseThreeByteOp2 span (rhlp: ReadHelper) =
    match rhlp.ReadByte span with
    | 0x00uy -> parseEVEXW span rhlp notEn vex0F3A00W1 notEn notEn
    | 0x01uy -> parseEVEXW span rhlp notEn vex0F3A01W1 notEn notEn
    | 0x02uy -> parseEVEXW span rhlp vex0F3A02W0 notEn notEn notEn
    | 0x04uy -> parseEVEXW span rhlp vex0F3A04W0 notEn notEn notEn
    | 0x05uy -> parseEVEXW span rhlp vex0F3A05W0 notEn notEn notEn
    | 0x06uy -> parseVEXW span rhlp notEn notEn vex0F3A06W0 notEn
    | 0x08uy -> parseVEX span rhlp nor0F3A08 vex0F3A08
    | 0x09uy -> parseVEX span rhlp nor0F3A09 vex0F3A09
    | 0x0Auy -> parseVEX span rhlp notEn vex0F3A0A
    | 0x0Buy -> parseEVEX span rhlp nor0F3A0B vex0F3A0B notEn evex0F3A0BW1
    | 0x0Cuy -> parseVEX span rhlp nor0F3A0C vex0F3A0C
    | 0x0Duy -> parseVEX span rhlp notEn vex0F3A0D
    | 0x0Euy -> parseVEX span rhlp notEn vex0F3A0E
    | 0x0Fuy -> parseVEX span rhlp nor0F3A0F vex0F3A0F
    | 0x14uy -> parseVEXW span rhlp notEn notEn vex0F3A14W0 notEn
    | 0x15uy -> parseVEX span rhlp nor0F3A15 vex0F3A15
    | 0x16uy -> parseVEX span rhlp nor0F3A16 vex0F3A16
    | 0x17uy -> parseEVEX span rhlp nor0F3A17 vex0F3A17 notEn notEn
    | 0x18uy -> parseEVEXW span rhlp vex0F3A18W0 notEn notEn notEn
    | 0x19uy -> parseEVEXW span rhlp vex0F3A19W0 notEn evex0F3A19W0 evex0F3A19W1
    | 0x1Auy -> parseEVEXW span rhlp notEn notEn notEn evex0F3A1AW1
    | 0x1Buy -> parseEVEXW span rhlp notEn notEn evex0F3A1BW0 evex0F3A1BW1
    | 0x1Euy -> parseEVEXW span rhlp notEn notEn evex0F3A1EW0 evex0F3A1EW1
    | 0x20uy -> parseVEX span rhlp nor0F3A20 vex0F3A20
    | 0x21uy -> parseVEX span rhlp notEn vex0F3A21
    | 0x22uy ->
      parseEVEXW span rhlp vex0F3A22W0 vex0F3A22W1 evex0F3A22W0 evex0F3A22W1
    | 0x25uy -> parseEVEXW span rhlp notEn notEn evex0F3A25W0 evex0F3A25W1
    | 0x27uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3A27W1
    | 0x38uy -> parseVEX span rhlp nor0F3A38 vex0F3A38
    | 0x39uy -> parseEVEXW span rhlp vex0F3A39W0 notEn notEn notEn
    | 0x3Auy -> parseEVEXW span rhlp notEn notEn evex0F3A3AW0 evex0F3A3AW1
    | 0x3Buy -> parseEVEXW span rhlp notEn notEn evex0F3A3BW0 evex0F3A3BW1
    | 0x3Euy -> parseEVEXW span rhlp notEn notEn evex0F3A3EW0 evex0F3A3EW1
    | 0x43uy -> parseEVEXW span rhlp notEn notEn evex0F3A43W0 evex0F3A43W1
    | 0x44uy -> parseEVEX span rhlp notEn vex0F3A44 evex0F3A44 evex0F3A44
    | 0x46uy -> parseEVEXW span rhlp vex0F3A46W0 notEn notEn notEn
    | 0x4Auy -> parseVEXW span rhlp notEn notEn vex0F3A4AW0 notEn
    | 0x4Buy -> parseVEXW span rhlp notEn notEn vex0F3A4BW0 notEn
    | 0x4Cuy -> parseVEXW span rhlp notEn notEn vex0F3A4CW0 notEn
    | 0x57uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3A57W1
    | 0x60uy -> parseVEX span rhlp nor0F3A60 vex0F3A60
    | 0x61uy -> parseVEX span rhlp nor0F3A61 vex0F3A61
    | 0x62uy -> parseVEX span rhlp nor0F3A62 vex0F3A62
    | 0x63uy -> parseVEX span rhlp nor0F3A63 vex0F3A63
    | 0x70uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3A70W1
    | 0x71uy -> parseEVEXW span rhlp notEn notEn evex0F3A71W0 evex0F3A71W1
    | 0x72uy -> parseEVEXW span rhlp notEn notEn notEn evex0F3A72W1
    | 0x73uy -> parseEVEXW span rhlp notEn notEn evex0F3A73W0 evex0F3A73W1
    | 0xCEuy -> parseEVEXW span rhlp notEn vex0F3ACEW1 notEn evex0F3ACEW1
    | 0xCFuy -> parseEVEXW span rhlp notEn vex0F3ACFW1 notEn evex0F3ACFW1
    | 0xF0uy -> parseVEX span rhlp nor0F3AF0 vex0F3AF0
    | _ -> raise ParsingFailureException

  let getOpCode0F0D span (rhlp: ReadHelper) =
    let b = rhlp.PeekByte span
    match modIsMemory b, getReg b with
    | true, 0b001 -> PREFETCHW
    | true, 0b010 -> PREFETCHWT1
    | _ -> raise ParsingFailureException

  let ignOpSz (rhlp: ReadHelper) =
    rhlp.Prefixes <- rhlp.Prefixes &&& EnumOfValue 0xFDFF
    rhlp

  let pTwoByteOp span (rhlp: ReadHelper) byte =
    match byte with
    | 0x02uy -> render span rhlp LAR SzCond.Nor OD.GprRm SZ.WV
    | 0x03uy -> render span rhlp LSL SzCond.Nor OD.GprRm SZ.WV
    | 0x05uy ->
#if !EMULATION
      ensure64 rhlp
#endif
      render span rhlp SYSCALL SzCond.Nor OD.No SZ.Def
    | 0x06uy -> render span rhlp CLTS SzCond.Nor OD.No SZ.Def
    | 0x07uy ->
#if !EMULATION
      ensure64 rhlp
#endif
      render span rhlp SYSRET SzCond.Nor OD.No SZ.Def
    | 0x08uy -> render span rhlp INVD SzCond.Nor OD.No SZ.Def
    | 0x09uy -> render span rhlp WBINVD SzCond.Nor OD.No SZ.Def
    | 0x0Buy -> render span rhlp UD2 SzCond.Nor OD.No SZ.Def
    | 0x0Duy ->
      render span rhlp (getOpCode0F0D span rhlp) SzCond.Nor OD.Mem SZ.Def
    | 0x10uy -> pVEXByMem span rhlp nor0F10 nor0F10 vex0F10Mem vex0F10Reg
    | 0x11uy -> pVEXByMem span rhlp nor0F11 nor0F11 vex0F11Mem vex0F11Reg
    | 0x12uy -> pVEXByMem span rhlp nor0F12Mem nor0F12Reg vex0F12Mem vex0F12Reg
    | 0x13uy -> parseVEX span rhlp nor0F13 vex0F13
    | 0x14uy -> parseVEX span rhlp nor0F14 vex0F14
    | 0x15uy -> parseVEX span rhlp nor0F15 vex0F15
    | 0x16uy -> pVEXByMem span rhlp nor0F16Mem nor0F16Reg vex0F16Mem vex0F16Reg
    | 0x17uy -> parseVEX span rhlp nor0F17 vex0F17
    | 0x1Auy -> parseBND span rhlp SzCond.Nor nor0F1A
    | 0x1Buy -> parseBND span rhlp SzCond.Nor nor0F1B
    | 0x1Euy ->
      if hasREPZ rhlp.Prefixes then parseCETInstr span rhlp
      else raise InvalidOpcodeException
    | 0x1Fuy -> render span rhlp NOP SzCond.Nor OD.Mem SZ.Def (* NOP /0 Ev *)
    | 0x20uy -> render span rhlp MOV SzCond.F64 OD.GprCtrl SZ.DY
    | 0x21uy -> render span rhlp MOV SzCond.Nor OD.GprDbg SZ.DY
    | 0x22uy -> render span rhlp MOV SzCond.Nor OD.CtrlGpr SZ.DY
    | 0x23uy -> render span rhlp MOV SzCond.Nor OD.DbgGpr SZ.DY
    | 0x28uy -> parseVEX span rhlp nor0F28 vex0F28
    | 0x29uy -> parseVEX span rhlp nor0F29 vex0F29
    | 0x2Auy -> parseVEX span rhlp nor0F2A vex0F2A
    | 0x2Buy -> parseVEX span rhlp nor0F2B vex0F2B
    | 0x2Cuy -> parseVEX span rhlp nor0F2C vex0F2C
    | 0x2Duy -> parseVEX span rhlp nor0F2D vex0F2D
    | 0x2Euy -> parseVEX span rhlp nor0F2E vex0F2E
    | 0x2Fuy -> parseVEX span rhlp nor0F2F vex0F2F
    | 0x30uy -> render span rhlp WRMSR SzCond.Nor OD.No SZ.Def
    | 0x31uy -> render span rhlp RDTSC SzCond.Nor OD.No SZ.Def
    | 0x32uy -> render span rhlp RDMSR SzCond.Nor OD.No SZ.Def
    | 0x33uy -> render span rhlp RDPMC SzCond.Nor OD.No SZ.Def
    | 0x34uy -> render span rhlp SYSENTER SzCond.Nor OD.No SZ.Def
    | 0x35uy -> render span rhlp SYSEXIT SzCond.Nor OD.No SZ.Def
    | 0x37uy -> render span rhlp GETSEC SzCond.Nor OD.No SZ.Def
    | 0x40uy -> render span rhlp CMOVO SzCond.Nor OD.GprRm SZ.Def
    | 0x41uy -> render span rhlp CMOVNO SzCond.Nor OD.GprRm SZ.Def
    | 0x42uy -> render span rhlp CMOVB SzCond.Nor OD.GprRm SZ.Def
    | 0x43uy -> render span rhlp CMOVAE SzCond.Nor OD.GprRm SZ.Def
    | 0x44uy -> render span rhlp CMOVZ SzCond.Nor OD.GprRm SZ.Def
    | 0x45uy -> render span rhlp CMOVNZ SzCond.Nor OD.GprRm SZ.Def
    | 0x46uy -> render span rhlp CMOVBE SzCond.Nor OD.GprRm SZ.Def
    | 0x47uy -> render span rhlp CMOVA SzCond.Nor OD.GprRm SZ.Def
    | 0x48uy -> render span rhlp CMOVS SzCond.Nor OD.GprRm SZ.Def
    | 0x49uy -> render span rhlp CMOVNS SzCond.Nor OD.GprRm SZ.Def
    | 0x4Auy -> render span rhlp CMOVP SzCond.Nor OD.GprRm SZ.Def
    | 0x4Buy -> render span rhlp CMOVNP SzCond.Nor OD.GprRm SZ.Def
    | 0x4Cuy -> render span rhlp CMOVL SzCond.Nor OD.GprRm SZ.Def
    | 0x4Duy -> render span rhlp CMOVGE SzCond.Nor OD.GprRm SZ.Def
    | 0x4Euy -> render span rhlp CMOVLE SzCond.Nor OD.GprRm SZ.Def
    | 0x4Fuy -> render span rhlp CMOVG SzCond.Nor OD.GprRm SZ.Def
    | 0x50uy -> parseVEX span rhlp nor0F50 vex0F50
    | 0x51uy -> parseVEX span rhlp nor0F51 vex0F51
    | 0x52uy -> parseVEX span rhlp nor0F52 vex0F52
    | 0x53uy -> parseVEX span rhlp nor0F53 vex0F53
    | 0x54uy -> parseVEX span rhlp nor0F54 vex0F54
    | 0x55uy -> parseVEX span rhlp nor0F55 vex0F55
    | 0x56uy -> parseVEX span rhlp nor0F56 vex0F56
    | 0x57uy -> parseVEX span rhlp nor0F57 vex0F57
    | 0x58uy -> parseVEX span rhlp nor0F58 vex0F58
    | 0x59uy -> parseVEX span rhlp nor0F59 vex0F59
    | 0x5Auy -> parseEVEX span rhlp nor0F5A vex0F5A evex0F5AW0 evex0F5AW1
    | 0x5Buy -> parseVEX span rhlp nor0F5B vex0F5B
    | 0x5Cuy -> parseVEX span rhlp nor0F5C vex0F5C
    | 0x5Duy -> parseEVEX span rhlp nor0F5D vex0F5D evex0F5DW0 notEn
    | 0x5Euy -> parseVEX span rhlp nor0F5E vex0F5E
    | 0x5Fuy -> parseEVEX span rhlp nor0F5F vex0F5F evex0F5FW0 evex0F5FW1
    | 0x60uy -> parseVEX span rhlp nor0F60 vex0F60
    | 0x61uy -> parseVEX span rhlp nor0F61 vex0F61
    | 0x62uy -> parseVEX span rhlp nor0F62 vex0F62
    | 0x63uy -> parseVEX span rhlp nor0F63 vex0F63
    | 0x64uy -> parseVEX span rhlp nor0F64 vex0F64
    | 0x65uy -> parseVEX span rhlp nor0F65 vex0F65
    | 0x66uy -> parseVEX span rhlp nor0F66 vex0F66
    | 0x67uy -> parseVEX span rhlp nor0F67 vex0F67
    | 0x68uy -> parseVEX span rhlp nor0F68 vex0F68
    | 0x69uy -> parseVEX span rhlp nor0F69 vex0F69
    | 0x6Auy -> parseVEX span rhlp nor0F6A vex0F6A
    | 0x6Buy -> parseVEX span rhlp nor0F6B vex0F6B
    | 0x6Cuy -> parseVEX span rhlp nor0F6C vex0F6C
    | 0x6Duy -> parseVEX span rhlp nor0F6D vex0F6D
    | 0x6Euy -> parseVEXW span rhlp nor0F6EW0 nor0F6EW1 vex0F6EW0 vex0F6EW1
    | 0x6Fuy -> parseEVEX span rhlp nor0F6F vex0F6F evex0F6FW0 evex0F6FW1
    | 0x70uy -> parseVEX span rhlp nor0F70 vex0F70
    | 0x74uy -> parseVEX span rhlp nor0F74 vex0F74
    | 0x75uy -> parseVEX span rhlp nor0F75 vex0F75
    | 0x76uy -> parseVEX span rhlp nor0F76 vex0F76
    | 0x77uy -> parseVEX span rhlp nor0F77 vex0F77
    | 0x78uy -> parseEVEX span rhlp nor0F78 notEn evex0F78W0 evex0F78W1
    | 0x7Auy -> parseEVEX span rhlp notEn notEn evex0F7AW0 evex0F7AW1
    | 0x7Buy -> parseEVEXW span rhlp notEn notEn evex0F7BW0 evex0F7BW1
    | 0x7Cuy -> parseVEX span rhlp notEn vex0F7C
    | 0x7Duy -> parseVEX span rhlp notEn vex0F7D
    | 0x7Euy -> parseVEXW span rhlp nor0F7EW0 nor0F7EW1 vex0F7EW0 vex0F7EW1
    | 0x7Fuy -> parseEVEX span rhlp nor0F7F vex0F7F evex0F7FW0 evex0F7FW1
    | 0x80uy -> addBND rhlp; render span rhlp JO SzCond.F64 OD.Rel SZ.D64
    | 0x81uy -> addBND rhlp; render span rhlp JNO SzCond.F64 OD.Rel SZ.D64
    | 0x82uy -> addBND rhlp; render span rhlp JB SzCond.F64 OD.Rel SZ.D64
    | 0x83uy -> addBND rhlp; render span rhlp JNB SzCond.F64 OD.Rel SZ.D64
    | 0x84uy -> addBND rhlp; render span rhlp JZ SzCond.F64 OD.Rel SZ.D64
    | 0x85uy -> addBND rhlp; render span rhlp JNZ SzCond.F64 OD.Rel SZ.D64
    | 0x86uy -> addBND rhlp; render span rhlp JBE SzCond.F64 OD.Rel SZ.D64
    | 0x87uy -> addBND rhlp; render span rhlp JA SzCond.F64 OD.Rel SZ.D64
    | 0x88uy -> addBND rhlp; render span rhlp JS SzCond.F64 OD.Rel SZ.D64
    | 0x89uy -> addBND rhlp; render span rhlp JNS SzCond.F64 OD.Rel SZ.D64
    | 0x8Auy -> addBND rhlp; render span rhlp JP SzCond.F64 OD.Rel SZ.D64
    | 0x8Buy -> addBND rhlp; render span rhlp JNP SzCond.F64 OD.Rel SZ.D64
    | 0x8Cuy -> addBND rhlp; render span rhlp JL SzCond.F64 OD.Rel SZ.D64
    | 0x8Duy -> addBND rhlp; render span rhlp JNL SzCond.F64 OD.Rel SZ.D64
    | 0x8Euy -> addBND rhlp; render span rhlp JLE SzCond.F64 OD.Rel SZ.D64
    | 0x8Fuy -> addBND rhlp; render span rhlp JG SzCond.F64 OD.Rel SZ.D64
    | 0x90uy -> render span rhlp SETO SzCond.Nor OD.Mem SZ.Byte
    | 0x91uy -> render span rhlp SETNO SzCond.Nor OD.Mem SZ.Byte
    | 0x92uy -> render span rhlp SETB SzCond.Nor OD.Mem SZ.Byte
    | 0x93uy -> render span rhlp SETNB SzCond.Nor OD.Mem SZ.Byte
    | 0x94uy -> render span rhlp SETZ SzCond.Nor OD.Mem SZ.Byte
    | 0x95uy -> render span rhlp SETNZ SzCond.Nor OD.Mem SZ.Byte
    | 0x96uy -> render span rhlp SETBE SzCond.Nor OD.Mem SZ.Byte
    | 0x97uy -> render span rhlp SETA SzCond.Nor OD.Mem SZ.Byte
    | 0x98uy -> render span rhlp SETS SzCond.Nor OD.Mem SZ.Byte
    | 0x99uy -> render span rhlp SETNS SzCond.Nor OD.Mem SZ.Byte
    | 0x9Auy -> render span rhlp SETP SzCond.Nor OD.Mem SZ.Byte
    | 0x9Buy -> render span rhlp SETNP SzCond.Nor OD.Mem SZ.Byte
    | 0x9Cuy -> render span rhlp SETL SzCond.Nor OD.Mem SZ.Byte
    | 0x9Duy -> render span rhlp SETNL SzCond.Nor OD.Mem SZ.Byte
    | 0x9Euy -> render span rhlp SETLE SzCond.Nor OD.Mem SZ.Byte
    | 0x9Fuy -> render span rhlp SETG SzCond.Nor OD.Mem SZ.Byte
    | 0xA0uy -> render span rhlp PUSH SzCond.D64 OD.Fs SZ.RegW
    | 0xA1uy -> render span rhlp POP SzCond.D64 OD.Fs SZ.RegW
    | 0xA2uy -> render span rhlp CPUID SzCond.Nor OD.No SZ.Def
    | 0xA3uy -> render span rhlp BT SzCond.Nor OD.RmGpr SZ.Def
    | 0xA4uy -> render span rhlp SHLD SzCond.Nor OD.XmRegImm8 SZ.Def
    | 0xA5uy -> render span rhlp SHLD SzCond.Nor OD.RmGprCL SZ.Def
    | 0xA8uy -> render span rhlp PUSH SzCond.D64 OD.Gs SZ.RegW
    | 0xA9uy -> render span rhlp POP SzCond.D64 OD.Gs SZ.RegW
    | 0xAAuy -> render span rhlp RSM SzCond.Nor OD.No SZ.Def
    | 0xABuy -> render span rhlp BTS SzCond.Nor OD.RmGpr SZ.Def
    | 0xACuy -> render span rhlp SHRD SzCond.Nor OD.XmRegImm8 SZ.Def
    | 0xADuy -> render span rhlp SHRD SzCond.Nor OD.RmGprCL SZ.Def
    | 0xAFuy -> render span rhlp IMUL SzCond.Nor OD.GprRm SZ.Def
    | 0xB0uy -> render span rhlp CMPXCHG SzCond.Nor OD.RmGpr SZ.Byte
    | 0xB1uy -> render span rhlp CMPXCHG SzCond.Nor OD.RmGpr SZ.Def
    | 0xB2uy -> render span rhlp LSS SzCond.Nor OD.GprM SZ.PRM
    | 0xB3uy -> render span rhlp BTR SzCond.Nor OD.RmGpr SZ.Def
    | 0xB4uy -> render span rhlp LFS SzCond.Nor OD.GprM SZ.PRM
    | 0xB5uy -> render span rhlp LGS SzCond.Nor OD.GprM SZ.PRM
    | 0xB6uy -> render span rhlp MOVZX SzCond.Nor OD.GprRm SZ.BV
    | 0xB7uy -> render span rhlp MOVZX SzCond.Nor OD.GprRm SZ.WV
    | 0xB8uy when not <| hasREPZ rhlp.Prefixes -> raise ParsingFailureException
    | 0xB8uy ->
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      render span rhlp POPCNT SzCond.Nor OD.GprRm SZ.Def
    | 0xBBuy when hasREPZ rhlp.Prefixes -> raise ParsingFailureException
    | 0xBBuy -> render span rhlp BTC SzCond.Nor OD.RmGpr SZ.Def
    | 0xBCuy when hasREPZ rhlp.Prefixes ->
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      render span rhlp TZCNT SzCond.Nor OD.GprRm SZ.Def
    | 0xBCuy -> render span rhlp BSF SzCond.Nor OD.GprRm SZ.Def
    | 0xBDuy when hasREPZ rhlp.Prefixes ->
      rhlp.Prefixes <- filterPrefs rhlp.Prefixes
      render span rhlp LZCNT SzCond.Nor OD.GprRm SZ.Def
    | 0xBDuy -> render span rhlp BSR SzCond.Nor OD.GprRm SZ.Def
    | 0xBEuy -> render span rhlp MOVSX SzCond.Nor OD.GprRm SZ.BV
    | 0xBFuy -> render span rhlp MOVSX SzCond.Nor OD.GprRm SZ.WV
    | 0xC0uy -> render span rhlp XADD SzCond.Nor OD.RmGpr SZ.Byte
    | 0xC1uy -> render span rhlp XADD SzCond.Nor OD.RmGpr SZ.Def
    | 0xC2uy -> parseEVEX span rhlp nor0FC2 vex0FC2 evex0FC2W0 evex0FC2W1
    | 0xC3uy -> render span rhlp MOVNTI SzCond.Nor OD.RmGpr SZ.Def
    | 0xC4uy -> parseVEX span rhlp nor0FC4 vex0FC4
    | 0xC5uy -> parseVEX span rhlp nor0FC5 vex0FC5
    | 0xC6uy -> parseVEX span rhlp nor0FC6 vex0FC6
    | 0xC8uy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rax SZ.Def
    | 0xC9uy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rcx SZ.Def
    | 0xCAuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rdx SZ.Def
    | 0xCBuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rbx SZ.Def
    | 0xCCuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rsp SZ.Def
    | 0xCDuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rbp SZ.Def
    | 0xCEuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rsi SZ.Def
    | 0xCFuy -> render span (ignOpSz rhlp) BSWAP SzCond.Nor OD.Rdi SZ.Def
    | 0xD0uy -> parseVEX span rhlp notEn vex0FD0
    | 0xD1uy -> parseVEX span rhlp nor0FD1 vex0FD1
    | 0xD2uy -> parseVEX span rhlp nor0FD2 vex0FD2
    | 0xD3uy -> parseVEX span rhlp nor0FD3 vex0FD3
    | 0xD4uy -> parseVEX span rhlp nor0FD4 vex0FD4
    | 0xD5uy -> parseVEX span rhlp nor0FD5 vex0FD5
    | 0xD6uy ->
#if !EMULATION
      ensureVEX128 rhlp
#endif
      parseVEX span rhlp nor0FD6 vex0FD6
    | 0xD7uy -> parseVEX span rhlp nor0FD7 vex0FD7
    | 0xD8uy -> parseVEX span rhlp nor0FD8 vex0FD8
    | 0xD9uy -> parseVEX span rhlp nor0FD9 vex0FD9
    | 0xDAuy -> parseVEX span rhlp nor0FDA vex0FDA
    | 0xDBuy -> parseVEX span rhlp nor0FDB vex0FDB
    | 0xDCuy -> parseVEX span rhlp nor0FDC vex0FDC
    | 0xDDuy -> parseVEX span rhlp nor0FDD vex0FDD
    | 0xDEuy -> parseVEX span rhlp nor0FDE vex0FDE
    | 0xDFuy -> parseVEX span rhlp nor0FDF vex0FDF
    | 0xE0uy -> parseVEX span rhlp nor0FE0 vex0FE0
    | 0xE1uy -> parseVEX span rhlp nor0FE1 vex0FE1
    | 0xE2uy -> parseVEX span rhlp nor0FE2 vex0FE2
    | 0xE3uy -> parseVEX span rhlp nor0FE3 vex0FE3
    | 0xE4uy -> parseVEX span rhlp nor0FE4 vex0FE4
    | 0xE5uy -> parseVEX span rhlp nor0FE5 vex0FE5
    | 0xE6uy -> parseEVEX span rhlp nor0FE6 vex0FE6 evex0FE6W0 evex0FE6W1
    | 0xE7uy -> parseEVEX span rhlp nor0FE7 vex0FE7 evex0FE7W0 evex0FE7W1
    | 0xE8uy -> parseVEX span rhlp nor0FE8 vex0FE8
    | 0xE9uy -> parseVEX span rhlp nor0FE9 vex0FE9
    | 0xEAuy -> parseVEX span rhlp nor0FEA vex0FEA
    | 0xEBuy -> parseVEX span rhlp nor0FEB vex0FEB
    | 0xECuy -> parseVEX span rhlp nor0FEC vex0FEC
    | 0xEDuy -> parseVEX span rhlp nor0FED vex0FED
    | 0xEEuy -> parseVEX span rhlp nor0FEE vex0FEE
    | 0xEFuy -> parseEVEX span rhlp nor0FEF vex0FEF evex0FEFW0 evex0FEFW1
    | 0xF0uy -> parseVEX span rhlp nor0FF0 vex0FF0
    | 0xF1uy -> parseVEX span rhlp nor0FF1 vex0FF1
    | 0xF2uy -> parseVEX span rhlp nor0FF2 vex0FF2
    | 0xF3uy -> parseVEX span rhlp nor0FF3 vex0FF3
    | 0xF4uy -> parseVEX span rhlp nor0FF4 vex0FF4
    | 0xF5uy -> parseVEX span rhlp nor0FF5 vex0FF5
    | 0xF6uy -> parseVEX span rhlp nor0FF6 vex0FF6
    | 0xF8uy -> parseVEX span rhlp nor0FF8 vex0FF8
    | 0xF9uy -> parseVEX span rhlp nor0FF9 vex0FF9
    | 0xFAuy -> parseVEX span rhlp nor0FFA vex0FFA
    | 0xFBuy -> parseVEX span rhlp nor0FFB vex0FFB
    | 0xFCuy -> parseVEX span rhlp nor0FFC vex0FFC
    | 0xFDuy -> parseVEX span rhlp nor0FFD vex0FFD
    | 0xFEuy -> parseVEX span rhlp nor0FFE vex0FFE
    | 0x00uy -> parseGrpOp span rhlp OpGroup.G6 OD.No SZ.Def
    | 0x01uy -> parseGrpOp span rhlp OpGroup.G7 OD.No SZ.Def
    | 0xBAuy -> parseGrpOp span rhlp OpGroup.G8 OD.RmImm8 SZ.Def
    | 0xC7uy -> parseGrpOp span rhlp OpGroup.G9 OD.No SZ.Def
    | 0x71uy -> parseGrpOp span rhlp OpGroup.G12 OD.No SZ.Def
    | 0x72uy -> parseGrpOp span rhlp OpGroup.G13 OD.No SZ.Def
    | 0x73uy -> parseGrpOp span rhlp OpGroup.G14 OD.No SZ.Def
    | 0xAEuy -> parseGrpOp span rhlp OpGroup.G15 OD.No SZ.Def
    | 0x18uy -> parseGrpOp span rhlp OpGroup.G16 OD.Mem SZ.Def
    | 0x38uy -> parseThreeByteOp1 span rhlp
    | 0x3Auy -> parseThreeByteOp2 span rhlp
    | _ -> raise ParsingFailureException

  (* Table A-3 of Volume 2 (Two-byte Opcode Map) *)
  let parseTwoByteOpcode span (rhlp: ReadHelper) =
    pTwoByteOp span rhlp (rhlp.ReadByte span)

end

IntelParsingJob.fs
//这段代码实现了x86指令集的解析。
//主要功能点:
//1. 定义了一个ParsingJob抽象类,用于表示解析一个操作码的工作单元。
//2. 定义了从0x00到0xFF的256个具体的ParsingJob子类,每个子类负责解析对应操作码。
//3. ParsingJob子类通过调用不同的解析函数,识别操作码、操作数类型和数量,最终生成一个insn对象。
//4. 提供了解析组指令、前缀修饰、操作数大小等不同类指令的公共函数。
//5. 支持解析一字节、两字节、三字节复杂指令集,识别VEX/EVEX等扩展。
//6. 考虑了32/64位模式、地址长度前缀等切换引起的差异。
//7. 解析流程为:识别操作码→选择对应的ParsingJob→解析操作数→生成insn对象。
//8. 每个具体的ParsingJob负责对应操作码的解析工作,统一了接口。
//所以它实现了基于操作码TABLE的x86指令集结构化解析方式,充分利用了面向对象设计的思想。
//对外提供统一的指令解析接口,内部根据操作码进行分配执行具体工作。

namespace B2R2.FrontEnd.BinLifter.Intel

open System
open B2R2
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.Helper
open B2R2.FrontEnd.BinLifter.Intel.ParsingHelper
open LanguagePrimitives

[<AbstractClass>]
type internal ParsingJob () =
  abstract Run: ByteSpan * ReadHelper -> IntelInstruction

type internal OneOp00 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp01 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp02 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp03 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp04 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp05 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADD oprs

type internal OneOp06 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Es].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp07 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Es].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp08 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp09 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp0A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp0B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp0C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp0D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.OR oprs

type internal OneOp0E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Cs].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp0F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    pTwoByteOp span rhlp (rhlp.ReadByte span)

type internal OneOp10 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp11 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp12 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp13 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp14 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp15 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ADC oprs

type internal OneOp16 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Ss].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp17 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Ss].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp18 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp19 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp1A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp1B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp1C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp1D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SBB oprs

type internal OneOp1E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Ds].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp1F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.RegW].Render rhlp SzCond.Nor
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Ds].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp20 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp21 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp22 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp23 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp24 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp25 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.AND oprs

type internal OneOp26 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp27 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.DAA oprs

type internal OneOp28 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp29 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp2A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp2B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp2C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp2D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.SUB oprs

type internal OneOp2E () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp2F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.DAS oprs

type internal OneOp30 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp31 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp32 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp33 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp34 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp35 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.XOR oprs

type internal OneOp36 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp37 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.AAA oprs

type internal OneOp38 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp39 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp3A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp3B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp3C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp3D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMP oprs

type internal OneOp3E () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp3F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.AAS oprs

type internal OneOp40 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Eax].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp41 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ecx].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp42 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Edx].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp43 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ebx].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp44 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Esp].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp45 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ebp].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp46 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Esi].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp47 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Edi].Render (span, rhlp)
    newInsInfo rhlp Opcode.INC oprs

type internal OneOp48 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Eax].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp49 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ecx].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Edx].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ebx].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Esp].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Ebp].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Esi].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp4F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Edi].Render (span, rhlp)
    newInsInfo rhlp Opcode.DEC oprs

type internal OneOp50 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rax].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp51 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rcx].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp52 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rdx].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp53 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rbx].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp54 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rsp].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp55 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rbp].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp56 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rsi].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp57 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rdi].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp58 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rax].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp59 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rcx].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rdx].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rbx].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rsp].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rbp].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rsi].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp5F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Rdi].Render (span, rhlp)
    newInsInfo rhlp Opcode.POP oprs

type internal OneOp60 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.PUSHA SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.PUSHAD SzCond.Nor OD.No SZ.Def

type internal OneOp61 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.POPA SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.POPAD SzCond.Nor OD.No SZ.Def

type internal OneOp62 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if (rhlp.WordSize = WordSize.Bit64) || (rhlp.PeekByte span >= 0xC0uy) then
      let mutable rex = rhlp.REXPrefix
      let vInfo = getEVEXInfo span &rex rhlp.CurrPos
      rhlp.VEXInfo <- Some vInfo
      rhlp.REXPrefix <- rex
      rhlp.CurrPos <- rhlp.CurrPos + 3
      match vInfo.VEXType &&& EnumOfValue<int, VEXType> 7 with
      | VEXType.VEXTwoByteOp -> parseTwoByteOpcode span rhlp
      | VEXType.VEXThreeByteOpOne -> parseThreeByteOp1 span rhlp
      | VEXType.VEXThreeByteOpTwo -> parseThreeByteOp2 span rhlp
      | _ -> raise ParsingFailureException
    else
      rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
      let oprs = rhlp.OprParsers[int OD.GprM].Render (span, rhlp)
      newInsInfo rhlp Opcode.BOUND oprs

type internal OneOp63 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if is64bit rhlp then
      if not (hasREXW rhlp.REXPrefix) then raise ParsingFailureException
      else render span rhlp Opcode.MOVSXD SzCond.Nor OD.GprRm SZ.DV
    else render span rhlp Opcode.ARPL SzCond.Nor OD.RmGpr SZ.Word

type internal OneOp64 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp65 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp66 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp67 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOp68 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.Imm].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp69 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRmImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.IMUL oprs

type internal OneOp6A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.D64
    rhlp.OperationSize <- rhlp.MemEffOprSize
    let oprs = rhlp.OprParsers[int OD.SImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.PUSH oprs

type internal OneOp6B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRmImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.IMUL oprs

type internal OneOp6C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.INSB oprs

type internal OneOp6D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.INSW SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.INSD SzCond.Nor OD.No SZ.Def

type internal OneOp6E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.OUTSB oprs

type internal OneOp6F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.OUTSW SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.OUTSD SzCond.Nor OD.No SZ.Def

type internal OneOp70 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JO oprs

type internal OneOp71 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNO oprs

type internal OneOp72 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JB oprs

type internal OneOp73 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNB oprs

type internal OneOp74 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JZ oprs

type internal OneOp75 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNZ oprs

type internal OneOp76 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JBE oprs

type internal OneOp77 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JA oprs

type internal OneOp78 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JS oprs

type internal OneOp79 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNS oprs

type internal OneOp7A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JP oprs

type internal OneOp7B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNP oprs

type internal OneOp7C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JL oprs

type internal OneOp7D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JNL oprs

type internal OneOp7E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JLE oprs

type internal OneOp7F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JG oprs

type internal OneOp80 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Byte OpGroup.G1
    render span rhlp op szCond oidx szidx

type internal OneOp81 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm SZ.Def OpGroup.G1
    render span rhlp op szCond oidx szidx

type internal OneOp82 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Byte OpGroup.G1Inv64
    render span rhlp op szCond oidx szidx

type internal OneOp83 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Def OpGroup.G1
    render span rhlp op szCond oidx szidx

type internal OneOp84 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.TEST oprs

type internal OneOp85 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.TEST oprs

type internal OneOp86 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp87 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp88 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp89 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmGpr].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp8A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp8B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp8C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Word].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RmSeg].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp8D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.GprM].Render (span, rhlp)
    newInsInfo rhlp Opcode.LEA oprs

type internal OneOp8E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Word].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.SegRm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOp8F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.Mem SZ.Def OpGroup.G1A
    render span rhlp op szCond oidx szidx

type internal OneOp90 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasNoPref rhlp && hasNoREX rhlp then
      render span rhlp Opcode.NOP SzCond.Nor OD.No SZ.Def
    elif hasREPZ rhlp.Prefixes then
      render span rhlp Opcode.PAUSE SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.XCHG SzCond.Nor OD.RaxRax SZ.Def

type internal OneOp91 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRcx].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp92 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRdx].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp93 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRbx].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp94 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRsp].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp95 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRbp].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp96 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRsi].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp97 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxRdi].Render (span, rhlp)
    newInsInfo rhlp Opcode.XCHG oprs

type internal OneOp98 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.CBW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.CDQE SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.CWDE SzCond.Nor OD.No SZ.Def

type internal OneOp99 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.CWD SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.CQO SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.CDQ SzCond.Nor OD.No SZ.Def

type internal OneOp9A () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    addBND rhlp
    rhlp.SzComputers[int SZ.P].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Dir].Render (span, rhlp)
    newInsInfo rhlp Opcode.CALLFar oprs

type internal OneOp9B () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.WAIT oprs

type internal OneOp9C () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      let szcond = if is64bit rhlp then SzCond.D64 else SzCond.Nor
      render span rhlp Opcode.PUSHF szcond OD.No SZ.Def
    elif is64bit rhlp then
      render span rhlp Opcode.PUSHFQ SzCond.D64 OD.No SZ.Def
    else render span rhlp Opcode.PUSHFD SzCond.Nor OD.No SZ.Def

type internal OneOp9D () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      let szcond = if is64bit rhlp then SzCond.D64 else SzCond.Nor
      render span rhlp Opcode.POPF szcond OD.No SZ.Def
    elif is64bit rhlp then
      render span rhlp Opcode.POPFQ SzCond.D64 OD.No SZ.Def
    else render span rhlp Opcode.POPFD SzCond.Nor OD.No SZ.Def

type internal OneOp9E () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.SAHF oprs

type internal OneOp9F () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.LAHF oprs

type internal OneOpA0 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxFar].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpA1 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxFar].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpA2 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.FarRax].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpA3 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.FarRax].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpA4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOVSB oprs

type internal OneOpA5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.MOVSW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.MOVSQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.MOVSD SzCond.Nor OD.No SZ.Def

type internal OneOpA6 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMPSB oprs

type internal OneOpA7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.CMPSW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.CMPSQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.CMPSD SzCond.Nor OD.No SZ.Def

type internal OneOpA8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.TEST oprs

type internal OneOpA9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.TEST oprs

type internal OneOpAA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.STOSB oprs

type internal OneOpAB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.STOSW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.STOSQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.STOSD SzCond.Nor OD.No SZ.Def

type internal OneOpAC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.LODSB oprs

type internal OneOpAD () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.LODSW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.LODSQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.LODSD SzCond.Nor OD.No SZ.Def

type internal OneOpAE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    rhlp.OperationSize <- 8<rt>
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.SCASB oprs

type internal OneOpAF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.SCASW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.SCASQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.SCASD SzCond.Nor OD.No SZ.Def

type internal OneOpB0 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.ALImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB1 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.CLImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB2 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.DLImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB3 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.BLImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.AhImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.ChImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB6 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.DhImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.BhImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RaxImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpB9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RcxImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RdxImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RbxImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RspImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBD () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RbpImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RsiImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpBF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RdiImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.MOV oprs

type internal OneOpC0 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Byte OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpC1 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Def OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpC2 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Imm16].Render (span, rhlp)
    newInsInfo rhlp Opcode.RETNearImm oprs

type internal OneOpC3 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.RETNear oprs

type internal OneOpC4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if (rhlp.WordSize = WordSize.Bit64) || (rhlp.PeekByte span >= 0xC0uy) then
      let mutable rex = rhlp.REXPrefix
      let vInfo = getThreeVEXInfo span &rex rhlp.CurrPos
      rhlp.VEXInfo <- Some vInfo
      rhlp.REXPrefix <- rex
      rhlp.CurrPos <- rhlp.CurrPos + 2
      match vInfo.VEXType with
      | VEXType.VEXTwoByteOp -> parseTwoByteOpcode span rhlp
      | VEXType.VEXThreeByteOpOne -> parseThreeByteOp1 span rhlp
      | VEXType.VEXThreeByteOpTwo -> parseThreeByteOp2 span rhlp
      | _ -> raise ParsingFailureException
    else
      rhlp.SzComputers[int SZ.PZ].Render rhlp SzCond.Nor
      let oprs = rhlp.OprParsers[int OD.GprM].Render (span, rhlp)
      newInsInfo rhlp Opcode.LES oprs

type internal OneOpC5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if (rhlp.WordSize = WordSize.Bit64) || (rhlp.PeekByte span >= 0xC0uy) then
      let mutable rex = rhlp.REXPrefix
      rhlp.VEXInfo <- Some (getTwoVEXInfo span &rex rhlp.CurrPos)
      rhlp.REXPrefix <- rex
      rhlp.CurrPos <- rhlp.CurrPos + 1
      parseTwoByteOpcode span rhlp
    else
      rhlp.SzComputers[int SZ.PZ].Render rhlp SzCond.Nor
      let oprs = rhlp.OprParsers[int OD.GprM].Render (span, rhlp)
      newInsInfo rhlp Opcode.LDS oprs

type internal OneOpC6 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm8 SZ.Byte OpGroup.G11A
    render span rhlp op szCond oidx szidx

type internal OneOpC7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmImm SZ.Def OpGroup.G11B
    render span rhlp op szCond oidx szidx

type internal OneOpC8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.ImmImm].Render (span, rhlp)
    newInsInfo rhlp Opcode.ENTER oprs

type internal OneOpC9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.D64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.LEAVE oprs

type internal OneOpCA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm16].Render (span, rhlp)
    newInsInfo rhlp Opcode.RETFarImm oprs

type internal OneOpCB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.RETFar oprs

type internal OneOpCC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.INT3 oprs

type internal OneOpCD () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.INT oprs

type internal OneOpCE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.INTO oprs

type internal OneOpCF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasOprSz rhlp.Prefixes then
      render span rhlp Opcode.IRETW SzCond.Nor OD.No SZ.Def
    elif hasREXW rhlp.REXPrefix then
      render span rhlp Opcode.IRETQ SzCond.Nor OD.No SZ.Def
    else render span rhlp Opcode.IRETD SzCond.Nor OD.No SZ.Def

type internal OneOpD0 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.M1 SZ.Byte OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpD1 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.M1 SZ.Def OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpD2 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmCL SZ.Byte OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpD3 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.RmCL SZ.Def OpGroup.G2
    render span rhlp op szCond oidx szidx

type internal OneOpD4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.AAM oprs

type internal OneOpD5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.AAD oprs

type internal OneOpD6 () =
  inherit ParsingJob ()
  override __.Run (_, _)= raise ParsingFailureException

type internal OneOpD7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.XLATB oprs

type internal OneOpD8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getD8OpWithin00toBF modRM
      let effOprSize = getEscEffOprSizeByESCOp 0xD8uy
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getD8OverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpD9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getD9OpWithin00toBF modRM
      let effOprSize = getReg modRM |> getD9EscEffOprSizeByModRM
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getD9OverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDAOpWithin00toBF modRM
      let effOprSize = getEscEffOprSizeByESCOp 0xDAuy
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDAOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDBOpWithin00toBF modRM
      let effOprSize = getReg modRM |> getDBEscEffOprSizeByModRM
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDBOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDCOpWithin00toBF modRM
      let effOprSize = getEscEffOprSizeByESCOp 0xDCuy
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDCOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDD () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDDOpWithin00toBF modRM
      let effOprSize = getReg modRM |> getDDEscEffOprSizeByModRM
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDDOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDEOpWithin00toBF modRM
      let effOprSize = getEscEffOprSizeByESCOp 0xDEuy
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDEOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpDF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let modRM = rhlp.ReadByte span
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    if modRM <= 0xBFuy then
      let op = getDFOpWithin00toBF modRM
      let effOprSize = getReg modRM |> getDFEscEffOprSizeByModRM
      rhlp.MemEffOprSize <- effOprSize
      rhlp.MemEffRegSize <- effOprSize
      let o = OperandParsingHelper.parseMemory modRM span rhlp
      newInsInfo rhlp op (OneOperand o)
    else
      let opcode, oprs = getDFOverBF modRM
      newInsInfo rhlp opcode oprs

type internal OneOpE0 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.LOOPNE oprs

type internal OneOpE1 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.LOOPE oprs

type internal OneOpE2 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.LOOP oprs

type internal OneOpE3 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    if hasAddrSz rhlp.Prefixes then
      let opcode = if is64bit rhlp then Opcode.JECXZ else Opcode.JCXZ
      render span rhlp opcode SzCond.F64 OD.Rel8 SZ.Byte
    elif is64bit rhlp then
      render span rhlp Opcode.JRCXZ SzCond.F64 OD.Rel8 SZ.Byte
    else render span rhlp Opcode.JECXZ SzCond.F64 OD.Rel8 SZ.Byte

type internal OneOpE4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.IN oprs

type internal OneOpE5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.RegImm8].Render (span, rhlp)
    newInsInfo rhlp Opcode.IN oprs

type internal OneOpE6 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm8Reg].Render (span, rhlp)
    newInsInfo rhlp Opcode.OUT oprs

type internal OneOpE7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Imm8Reg].Render (span, rhlp)
    newInsInfo rhlp Opcode.OUT oprs

type internal OneOpE8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel].Render (span, rhlp)
    newInsInfo rhlp Opcode.CALLNear oprs

type internal OneOpE9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.D64].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel].Render (span, rhlp)
    newInsInfo rhlp Opcode.JMPNear oprs

type internal OneOpEA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
#if !EMULATION
    ensure32 rhlp
#endif
    addBND rhlp
    rhlp.SzComputers[int SZ.P].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.Dir].Render (span, rhlp)
    newInsInfo rhlp Opcode.JMPFar oprs

type internal OneOpEB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    addBND rhlp
    rhlp.SzComputers[int SZ.Byte].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.Rel8].Render (span, rhlp)
    newInsInfo rhlp Opcode.JMPNear oprs

type internal OneOpEC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.ALDx].Render (span, rhlp)
    newInsInfo rhlp Opcode.IN oprs

type internal OneOpED () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.EaxDx].Render (span, rhlp)
    newInsInfo rhlp Opcode.IN oprs

type internal OneOpEE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.DxAL].Render (span, rhlp)
    newInsInfo rhlp Opcode.OUT oprs

type internal OneOpEF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.Nor
    let oprs = rhlp.OprParsers[int OD.DxEax].Render (span, rhlp)
    newInsInfo rhlp Opcode.OUT oprs

type internal OneOpF0 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOpF1 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOpF2 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOpF3 () =
  inherit ParsingJob ()
  override __.Run (_, _) = raise ParsingFailureException

type internal OneOpF4 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.HLT oprs

type internal OneOpF5 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.CMC oprs

type internal OneOpF6 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.Mem SZ.Byte OpGroup.G3A
    render span rhlp op szCond oidx szidx

type internal OneOpF7 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.Mem SZ.Def OpGroup.G3B
    render span rhlp op szCond oidx szidx

type internal OneOpF8 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.CLC oprs

type internal OneOpF9 () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.STC oprs

type internal OneOpFA () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.CLI oprs

type internal OneOpFB () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.STI oprs

type internal OneOpFC () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.CLD oprs

type internal OneOpFD () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    rhlp.SzComputers[int SZ.Def].Render rhlp SzCond.F64
    let oprs = rhlp.OprParsers[int OD.No].Render (span, rhlp)
    newInsInfo rhlp Opcode.STD oprs

type internal OneOpFE () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.No SZ.Def OpGroup.G4
    render span rhlp op szCond oidx szidx

type internal OneOpFF () =
  inherit ParsingJob ()
  override __.Run (span, rhlp) =
    let struct (op, oidx, szidx, szCond) =
      parseGrpOpKind span rhlp OD.No SZ.Def OpGroup.G5
    if isBranch op then addBND rhlp else ()
    render span rhlp op szCond oidx szidx

IntelRegExprs.fs
//这段代码定义了一个RegisterExprs类,用于生成Intel体系结构下各种寄存器和程序计数器的抽象语法树(AST)节点。
//主要功能点如下:
//1. 根据字长(WordSize)生成不同宽度(64位或32位)的寄存器节点。
//2. 定义常用通用寄存器(RAX、RBX等)、标志寄存器(OF、DF等)、段寄存器(CS、DS等)和控制寄存器(CR0、CR3等)的获取方法。
//3. 定义MMX、SSE/AVX相关寄存器(MMx、ZMMx等)的获取方法。 
//4. 定义伪指令相关寄存器(STx、XMMx等)的获取方法。
//5. 提供根据名称获取对应寄存器节点的GetRegVar方法。
//6. 提供根据名称和索引获取伪指令相关寄存器节点的GetPseudoRegVar方法。
//7. 通过条件编译#if DEBUG定义了字长检查逻辑,防止非法访问不匹配字长的寄存器。
//总的来说,这个RegisterExprs类根据不同的字长和寄存器类型,为Intel体系结构定义和生成了所有相关的寄存器表达,
//用于后续的低级抽象中间语言(LowUIR)解析和生成。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter.LiftingUtils

/// This is a fatal error that happens when B2R2 tries to access non-existing
/// register symbol. This exception should not happen in general.
exception internal InvalidRegAccessException

type internal RegExprs (wordSize) =
  let var sz t name = AST.var sz t name (IntelRegisterSet.singleton t)

  let reg64 wordSize t name =
    if wordSize = WordSize.Bit32 then AST.undef 64<rt> name
    else var 64<rt> t name

  let reg32 wordSize t name r64 =
    if wordSize = WordSize.Bit32 then var 32<rt> t name
    else AST.xtlo 32<rt> r64

  let reg32ext wordSize name r64 =
    if wordSize = WordSize.Bit32 then AST.undef 32<rt> name
    else AST.xtlo 32<rt> r64

  let reg16 wordSize r32 r64 =
    AST.xtlo 16<rt> (if wordSize = WordSize.Bit32 then r32 else r64)

  let reg16ext wordSize name r64 =
    if wordSize = WordSize.Bit32 then AST.undef 16<rt> name
    else AST.xtlo 16<rt> r64

  let regL8 wordSize r32 r64 =
    AST.xtlo 8<rt> (if wordSize = WordSize.Bit32 then r32 else r64)

  let regH8 wordSize r32 r64 =
    AST.extract (if wordSize = WordSize.Bit32 then r32 else r64) 8<rt> 8

  let regL8ext wordSize name r64 =
    if wordSize = WordSize.Bit32 then AST.undef 16<rt> name
    else AST.xtlo 8<rt> r64

#if DEBUG
  let assert64Bit wordSize =
    if wordSize = WordSize.Bit64 then () else raise InvalidRegAccessException

  let assert32Bit wordSize =
    if wordSize = WordSize.Bit32 then () else raise InvalidRegAccessException
#endif

  (* Registers *)
  let rax  = reg64 wordSize (Register.toRegID Register.RAX) "RAX"
  let rbx  = reg64 wordSize (Register.toRegID Register.RBX) "RBX"
  let rcx  = reg64 wordSize (Register.toRegID Register.RCX) "RCX"
  let rdx  = reg64 wordSize (Register.toRegID Register.RDX) "RDX"
  let rsi  = reg64 wordSize (Register.toRegID Register.RSI) "RSI"
  let rdi  = reg64 wordSize (Register.toRegID Register.RDI) "RDI"
  let rsp  = reg64 wordSize (Register.toRegID Register.RSP) "RSP"
  let rbp  = reg64 wordSize (Register.toRegID Register.RBP) "RBP"
  let r8   = reg64 wordSize (Register.toRegID Register.R8) "R8"
  let r9   = reg64 wordSize (Register.toRegID Register.R9) "R9"
  let r10  = reg64 wordSize (Register.toRegID Register.R10) "R10"
  let r11  = reg64 wordSize (Register.toRegID Register.R11) "R11"
  let r12  = reg64 wordSize (Register.toRegID Register.R12) "R12"
  let r13  = reg64 wordSize (Register.toRegID Register.R13) "R13"
  let r14  = reg64 wordSize (Register.toRegID Register.R14) "R14"
  let r15  = reg64 wordSize (Register.toRegID Register.R15) "R15"
  let eax  = reg32 wordSize (Register.toRegID Register.EAX) "EAX" rax
  let ebx  = reg32 wordSize (Register.toRegID Register.EBX) "EBX" rbx
  let ecx  = reg32 wordSize (Register.toRegID Register.ECX) "ECX" rcx
  let edx  = reg32 wordSize (Register.toRegID Register.EDX) "EDX" rdx
  let esi  = reg32 wordSize (Register.toRegID Register.ESI) "ESI" rsi
  let edi  = reg32 wordSize (Register.toRegID Register.EDI) "EDI" rdi
  let esp  = reg32 wordSize (Register.toRegID Register.ESP) "ESP" rsp
  let ebp  = reg32 wordSize (Register.toRegID Register.EBP) "EBP" rbp
  let ax   = reg16 wordSize eax rax
  let bx   = reg16 wordSize ebx rbx
  let cx   = reg16 wordSize ecx rcx
  let dx   = reg16 wordSize edx rdx
  let fcw = var 16<rt> (Register.toRegID Register.FCW) "FCW"
  let fsw = var 16<rt> (Register.toRegID Register.FSW) "FSW"
  let ftw = var 16<rt> (Register.toRegID Register.FTW) "FTW"
  let fop = var 16<rt> (Register.toRegID Register.FOP) "FOP"
  let fip = var 64<rt> (Register.toRegID Register.FIP) "FIP"
  let fcs = var 16<rt> (Register.toRegID Register.FCS) "FCS"
  let fdp = var 64<rt> (Register.toRegID Register.FDP) "FDP"
  let fds = var 16<rt> (Register.toRegID Register.FDS) "FDS"
  let st0a = var 64<rt> (Register.toRegID Register.ST0A) "ST0A"
  let st0b = var 16<rt> (Register.toRegID Register.ST0B) "ST0B"
  let st1a = var 64<rt> (Register.toRegID Register.ST1A) "ST1A"
  let st1b = var 16<rt> (Register.toRegID Register.ST1B) "ST1B"
  let st2a = var 64<rt> (Register.toRegID Register.ST2A) "ST2A"
  let st2b = var 16<rt> (Register.toRegID Register.ST2B) "ST2B"
  let st3a = var 64<rt> (Register.toRegID Register.ST3A) "ST3A"
  let st3b = var 16<rt> (Register.toRegID Register.ST3B) "ST3B"
  let st4a = var 64<rt> (Register.toRegID Register.ST4A) "ST4A"
  let st4b = var 16<rt> (Register.toRegID Register.ST4B) "ST4B"
  let st5a = var 64<rt> (Register.toRegID Register.ST5A) "ST5A"
  let st5b = var 16<rt> (Register.toRegID Register.ST5B) "ST5B"
  let st6a = var 64<rt> (Register.toRegID Register.ST6A) "ST6A"
  let st6b = var 16<rt> (Register.toRegID Register.ST6B) "ST6B"
  let st7a = var 64<rt> (Register.toRegID Register.ST7A) "ST7A"
  let st7b = var 16<rt> (Register.toRegID Register.ST7B) "ST7B"
  let mxcsr = var 32<rt> (Register.toRegID Register.MXCSR) "MXCSR"
  let mxcsrmask = var 32<rt> (Register.toRegID Register.MXCSRMASK) "MXCSR_MASK"
  let pkru = var 32<rt> (Register.toRegID Register.PKRU) "PKRU"
  let k0 = var 64<rt> (Register.toRegID Register.K0) "K0"
  let k1 = var 64<rt> (Register.toRegID Register.K1) "K1"
  let k2 = var 64<rt> (Register.toRegID Register.K2) "K2"
  let k3 = var 64<rt> (Register.toRegID Register.K3) "K3"
  let k4 = var 64<rt> (Register.toRegID Register.K4) "K4"
  let k5 = var 64<rt> (Register.toRegID Register.K5) "K5"
  let k6 = var 64<rt> (Register.toRegID Register.K6) "K6"
  let k7 = var 64<rt> (Register.toRegID Register.K7) "K7"
  let dr0 = var 32<rt> (Register.toRegID Register.DR0) "DR0"
  let dr1 = var 32<rt> (Register.toRegID Register.DR1) "DR1"
  let dr2 = var 32<rt> (Register.toRegID Register.DR2) "DR2"
  let dr3 = var 32<rt> (Register.toRegID Register.DR3) "DR3"
  let dr6 = var 32<rt> (Register.toRegID Register.DR6) "DR6"
  let dr7 = var 32<rt> (Register.toRegID Register.DR7) "DR7"

  (* QWORD regs *)
  member val RAX = rax with get
  member val RBX = rbx with get
  member val RCX = rcx with get
  member val RDX = rdx with get
  member val RSI = rsi with get
  member val RDI = rdi with get
  member val RSP = rsp with get
  member val RBP = rbp with get
  member val R8  = r8  with get
  member val R9  = r9  with get
  member val R10 = r10 with get
  member val R11 = r11 with get
  member val R12 = r12 with get
  member val R13 = r13 with get
  member val R14 = r14 with get
  member val R15 = r15 with get
  (* DWORD regs *)
  member val EAX = eax with get
  member val EBX = ebx with get
  member val ECX = ecx with get
  member val EDX = edx with get
  member val ESI = esi with get
  member val EDI = edi with get
  member val ESP = esp with get
  member val EBP = ebp with get
  member val R8D = reg32ext wordSize "R8D" r8 with get
  member val R9D = reg32ext wordSize "R9D" r9 with get
  member val R10D = reg32ext wordSize "R10D" r10 with get
  member val R11D = reg32ext wordSize "R11D" r11 with get
  member val R12D = reg32ext wordSize "R12D" r12 with get
  member val R13D = reg32ext wordSize "R13D" r13 with get
  member val R14D = reg32ext wordSize "R14D" r14 with get
  member val R15D = reg32ext wordSize "R15D" r15 with get
  (* WORD regs *)
  member val AX  = ax with get
  member val BX  = bx with get
  member val CX  = cx with get
  member val DX  = dx with get
  member val SI  = reg16 wordSize esi rsi with get
  member val DI  = reg16 wordSize edi rdi with get
  member val SP  = reg16 wordSize esp rsp with get
  member val BP  = reg16 wordSize ebp rbp with get
  member val R8W = reg16ext wordSize "R8W" r8 with get
  member val R9W = reg16ext wordSize "R9W" r9 with get
  member val R10W = reg16ext wordSize "R10W" r10 with get
  member val R11W = reg16ext wordSize "R11W" r11 with get
  member val R12W = reg16ext wordSize "R12W" r12 with get
  member val R13W = reg16ext wordSize "R13W" r13 with get
  member val R14W = reg16ext wordSize "R14W" r14 with get
  member val R15W = reg16ext wordSize "R15W" r15 with get
  (* BYTE regs *)
  member val AL = regL8 wordSize eax rax with get
  member val AH = regH8 wordSize eax rax with get
  member val BL = regL8 wordSize ebx rbx with get
  member val BH = regH8 wordSize ebx rbx with get
  member val CL = regL8 wordSize ecx rcx with get
  member val CH = regH8 wordSize ecx rcx with get
  member val DL = regL8 wordSize edx rdx with get
  member val DH = regH8 wordSize edx rdx with get
  member val R8L = regL8ext wordSize "R8L" r8 with get
  member val R9L = regL8ext wordSize "R9L" r9 with get
  member val R10L = regL8ext wordSize "R10L" r10 with get
  member val R11L = regL8ext wordSize "R11L" r11 with get
  member val R12L = regL8ext wordSize "R12L" r12 with get
  member val R13L = regL8ext wordSize "R13L" r13 with get
  member val R14L = regL8ext wordSize "R14L" r14 with get
  member val R15L = regL8ext wordSize "R15L" r15 with get
  member val SPL = regL8ext wordSize "SPL" rsp with get
  member val BPL = regL8ext wordSize "BPL" rbp with get
  member val SIL = regL8ext wordSize "SIL" rsi with get
  member val DIL = regL8ext wordSize "DIL" rdi with get
  (* Program counters *)
  member val EIP = AST.pcvar 32<rt> "EIP"
  member val RIP = AST.pcvar 64<rt> "RIP"
  (* Segment selector *)
  member val CS = var 16<rt> (Register.toRegID Register.CS) "CS"
  member val DS = var 16<rt> (Register.toRegID Register.DS) "DS"
  member val ES = var 16<rt> (Register.toRegID Register.ES) "ES"
  member val FS = var 16<rt> (Register.toRegID Register.FS) "FS"
  member val GS = var 16<rt> (Register.toRegID Register.GS) "GS"
  member val SS = var 16<rt> (Register.toRegID Register.SS) "SS"
  (* Segment base regs *)
  member val CSBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CSBase) "CSBase"
  member val DSBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.DSBase) "DSBase"
  member val ESBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.ESBase) "ESBase"
  member val FSBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.FSBase) "FSBase"
  member val GSBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.GSBase) "GSBase"
  member val SSBase =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.SSBase) "SSBase"
  (* Control regs *)
  member val CR0 =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CR0) "CR0"
  member val CR2 =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CR2) "CR2"
  member val CR3 =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CR3) "CR3"
  member val CR4 =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CR4) "CR4"
  member val CR8 =
    var (WordSize.toRegType wordSize) (Register.toRegID Register.CR8) "CR8"
  (* EFLAGS *)
  member val OF = var 1<rt> (Register.toRegID Register.OF) "OF" with get
  member val DF = var 1<rt> (Register.toRegID Register.DF) "DF" with get
  member val IF = var 1<rt> (Register.toRegID Register.IF) "IF" with get
  member val TF = var 1<rt> (Register.toRegID Register.TF) "TF" with get
  member val SF = var 1<rt> (Register.toRegID Register.SF) "SF" with get
  member val ZF = var 1<rt> (Register.toRegID Register.ZF) "ZF" with get
  member val AF = var 1<rt> (Register.toRegID Register.AF) "AF" with get
  member val PF = var 1<rt> (Register.toRegID Register.PF) "PF" with get
  member val CF = var 1<rt> (Register.toRegID Register.CF) "CF" with get
  (* MMX Registers *)
  member val MM0 = st0a
  member val MM1 = st1a
  member val MM2 = st2a
  member val MM3 = st3a
  member val MM4 = st4a
  member val MM5 = st5a
  member val MM6 = st6a
  member val MM7 = st7a
  (* SSE Registers *)
  member val ZMM0A =
    var 64<rt> (Register.toRegID Register.ZMM0A) "ZMM0A" with get
  member val ZMM0B =
    var 64<rt> (Register.toRegID Register.ZMM0B) "ZMM0B" with get
  member val ZMM0C =
    var 64<rt> (Register.toRegID Register.ZMM0C) "ZMM0C" with get
  member val ZMM0D =
    var 64<rt> (Register.toRegID Register.ZMM0D) "ZMM0D" with get
  member val ZMM0E =
    var 64<rt> (Register.toRegID Register.ZMM0E) "ZMM0E" with get
  member val ZMM0F =
    var 64<rt> (Register.toRegID Register.ZMM0F) "ZMM0F" with get
  member val ZMM0G =
    var 64<rt> (Register.toRegID Register.ZMM0G) "ZMM0G" with get
  member val ZMM0H =
    var 64<rt> (Register.toRegID Register.ZMM0H) "ZMM0H" with get
  member val ZMM1A =
    var 64<rt> (Register.toRegID Register.ZMM1A) "ZMM1A" with get
  member val ZMM1B =
    var 64<rt> (Register.toRegID Register.ZMM1B) "ZMM1B" with get
  member val ZMM1C =
    var 64<rt> (Register.toRegID Register.ZMM1C) "ZMM1C" with get
  member val ZMM1D =
    var 64<rt> (Register.toRegID Register.ZMM1D) "ZMM1D" with get
  member val ZMM1E =
    var 64<rt> (Register.toRegID Register.ZMM1E) "ZMM1E" with get
  member val ZMM1F =
    var 64<rt> (Register.toRegID Register.ZMM1F) "ZMM1F" with get
  member val ZMM1G =
    var 64<rt> (Register.toRegID Register.ZMM1G) "ZMM1G" with get
  member val ZMM1H =
    var 64<rt> (Register.toRegID Register.ZMM1H) "ZMM1H" with get
  member val ZMM2A =
    var 64<rt> (Register.toRegID Register.ZMM2A) "ZMM2A" with get
  member val ZMM2B =
    var 64<rt> (Register.toRegID Register.ZMM2B) "ZMM2B" with get
  member val ZMM2C =
    var 64<rt> (Register.toRegID Register.ZMM2C) "ZMM2C" with get
  member val ZMM2D =
    var 64<rt> (Register.toRegID Register.ZMM2D) "ZMM2D" with get
  member val ZMM2E =
    var 64<rt> (Register.toRegID Register.ZMM2E) "ZMM2E" with get
  member val ZMM2F =
    var 64<rt> (Register.toRegID Register.ZMM2F) "ZMM2F" with get
  member val ZMM2G =
    var 64<rt> (Register.toRegID Register.ZMM2G) "ZMM2G" with get
  member val ZMM2H =
    var 64<rt> (Register.toRegID Register.ZMM2H) "ZMM2H" with get
  member val ZMM3A =
    var 64<rt> (Register.toRegID Register.ZMM3A) "ZMM3A" with get
  member val ZMM3B =
    var 64<rt> (Register.toRegID Register.ZMM3B) "ZMM3B" with get
  member val ZMM3C =
    var 64<rt> (Register.toRegID Register.ZMM3C) "ZMM3C" with get
  member val ZMM3D =
    var 64<rt> (Register.toRegID Register.ZMM3D) "ZMM3D" with get
  member val ZMM3E =
    var 64<rt> (Register.toRegID Register.ZMM3E) "ZMM3E" with get
  member val ZMM3F =
    var 64<rt> (Register.toRegID Register.ZMM3F) "ZMM3F" with get
  member val ZMM3G =
    var 64<rt> (Register.toRegID Register.ZMM3G) "ZMM3G" with get
  member val ZMM3H =
    var 64<rt> (Register.toRegID Register.ZMM3H) "ZMM3H" with get
  member val ZMM4A =
    var 64<rt> (Register.toRegID Register.ZMM4A) "ZMM4A" with get
  member val ZMM4B =
    var 64<rt> (Register.toRegID Register.ZMM4B) "ZMM4B" with get
  member val ZMM4C =
    var 64<rt> (Register.toRegID Register.ZMM4C) "ZMM4C" with get
  member val ZMM4D =
    var 64<rt> (Register.toRegID Register.ZMM4D) "ZMM4D" with get
  member val ZMM4E =
    var 64<rt> (Register.toRegID Register.ZMM4E) "ZMM4E" with get
  member val ZMM4F =
    var 64<rt> (Register.toRegID Register.ZMM4F) "ZMM4F" with get
  member val ZMM4G =
    var 64<rt> (Register.toRegID Register.ZMM4G) "ZMM4G" with get
  member val ZMM4H =
    var 64<rt> (Register.toRegID Register.ZMM4H) "ZMM4H" with get
  member val ZMM5A =
    var 64<rt> (Register.toRegID Register.ZMM5A) "ZMM5A" with get
  member val ZMM5B =
    var 64<rt> (Register.toRegID Register.ZMM5B) "ZMM5B" with get
  member val ZMM5C =
    var 64<rt> (Register.toRegID Register.ZMM5C) "ZMM5C" with get
  member val ZMM5D =
    var 64<rt> (Register.toRegID Register.ZMM5D) "ZMM5D" with get
  member val ZMM5E =
    var 64<rt> (Register.toRegID Register.ZMM5E) "ZMM5E" with get
  member val ZMM5F =
    var 64<rt> (Register.toRegID Register.ZMM5F) "ZMM5F" with get
  member val ZMM5G =
    var 64<rt> (Register.toRegID Register.ZMM5G) "ZMM5G" with get
  member val ZMM5H =
    var 64<rt> (Register.toRegID Register.ZMM5H) "ZMM5H" with get
  member val ZMM6A =
    var 64<rt> (Register.toRegID Register.ZMM6A) "ZMM6A" with get
  member val ZMM6B =
    var 64<rt> (Register.toRegID Register.ZMM6B) "ZMM6B" with get
  member val ZMM6C =
    var 64<rt> (Register.toRegID Register.ZMM6C) "ZMM6C" with get
  member val ZMM6D =
    var 64<rt> (Register.toRegID Register.ZMM6D) "ZMM6D" with get
  member val ZMM6E =
    var 64<rt> (Register.toRegID Register.ZMM6E) "ZMM6E" with get
  member val ZMM6F =
    var 64<rt> (Register.toRegID Register.ZMM6F) "ZMM6F" with get
  member val ZMM6G =
    var 64<rt> (Register.toRegID Register.ZMM6G) "ZMM6G" with get
  member val ZMM6H =
    var 64<rt> (Register.toRegID Register.ZMM6H) "ZMM6H" with get
  member val ZMM7A =
    var 64<rt> (Register.toRegID Register.ZMM7A) "ZMM7A" with get
  member val ZMM7B =
    var 64<rt> (Register.toRegID Register.ZMM7B) "ZMM7B" with get
  member val ZMM7C =
    var 64<rt> (Register.toRegID Register.ZMM7C) "ZMM7C" with get
  member val ZMM7D =
    var 64<rt> (Register.toRegID Register.ZMM7D) "ZMM7D" with get
  member val ZMM7E =
    var 64<rt> (Register.toRegID Register.ZMM7E) "ZMM7E" with get
  member val ZMM7F =
    var 64<rt> (Register.toRegID Register.ZMM7F) "ZMM7F" with get
  member val ZMM7G =
    var 64<rt> (Register.toRegID Register.ZMM7G) "ZMM7G" with get
  member val ZMM7H =
    var 64<rt> (Register.toRegID Register.ZMM7H) "ZMM7H" with get
  member val ZMM8A =
    var 64<rt> (Register.toRegID Register.ZMM8A) "ZMM8A" with get
  member val ZMM8B =
    var 64<rt> (Register.toRegID Register.ZMM8B) "ZMM8B" with get
  member val ZMM8C =
    var 64<rt> (Register.toRegID Register.ZMM8C) "ZMM8C" with get
  member val ZMM8D =
    var 64<rt> (Register.toRegID Register.ZMM8D) "ZMM8D" with get
  member val ZMM8E =
    var 64<rt> (Register.toRegID Register.ZMM8E) "ZMM8E" with get
  member val ZMM8F =
    var 64<rt> (Register.toRegID Register.ZMM8F) "ZMM8F" with get
  member val ZMM8G =
    var 64<rt> (Register.toRegID Register.ZMM8G) "ZMM8G" with get
  member val ZMM8H =
    var 64<rt> (Register.toRegID Register.ZMM8H) "ZMM8H" with get
  member val ZMM9A =
    var 64<rt> (Register.toRegID Register.ZMM9A) "ZMM9A" with get
  member val ZMM9B =
    var 64<rt> (Register.toRegID Register.ZMM9B) "ZMM9B" with get
  member val ZMM9C =
    var 64<rt> (Register.toRegID Register.ZMM9C) "ZMM9C" with get
  member val ZMM9D =
    var 64<rt> (Register.toRegID Register.ZMM9D) "ZMM9D" with get
  member val ZMM9E =
    var 64<rt> (Register.toRegID Register.ZMM9E) "ZMM9E" with get
  member val ZMM9F =
    var 64<rt> (Register.toRegID Register.ZMM9F) "ZMM9F" with get
  member val ZMM9G =
    var 64<rt> (Register.toRegID Register.ZMM9G) "ZMM9G" with get
  member val ZMM9H =
    var 64<rt> (Register.toRegID Register.ZMM9H) "ZMM9H" with get
  member val ZMM10A =
    var 64<rt> (Register.toRegID Register.ZMM10A) "ZMM10A" with get
  member val ZMM10B =
    var 64<rt> (Register.toRegID Register.ZMM10B) "ZMM10B" with get
  member val ZMM10C =
    var 64<rt> (Register.toRegID Register.ZMM10C) "ZMM10C" with get
  member val ZMM10D =
    var 64<rt> (Register.toRegID Register.ZMM10D) "ZMM10D" with get
  member val ZMM10E =
    var 64<rt> (Register.toRegID Register.ZMM10E) "ZMM10E" with get
  member val ZMM10F =
    var 64<rt> (Register.toRegID Register.ZMM10F) "ZMM10F" with get
  member val ZMM10G =
    var 64<rt> (Register.toRegID Register.ZMM10G) "ZMM10G" with get
  member val ZMM10H =
    var 64<rt> (Register.toRegID Register.ZMM10H) "ZMM10H" with get
  member val ZMM11A =
    var 64<rt> (Register.toRegID Register.ZMM11A) "ZMM11A" with get
  member val ZMM11B =
    var 64<rt> (Register.toRegID Register.ZMM11B) "ZMM11B" with get
  member val ZMM11C =
    var 64<rt> (Register.toRegID Register.ZMM11C) "ZMM11C" with get
  member val ZMM11D =
    var 64<rt> (Register.toRegID Register.ZMM11D) "ZMM11D" with get
  member val ZMM11E =
    var 64<rt> (Register.toRegID Register.ZMM11E) "ZMM11E" with get
  member val ZMM11F =
    var 64<rt> (Register.toRegID Register.ZMM11F) "ZMM11F" with get
  member val ZMM11G =
    var 64<rt> (Register.toRegID Register.ZMM11G) "ZMM11G" with get
  member val ZMM11H =
    var 64<rt> (Register.toRegID Register.ZMM11H) "ZMM11H" with get
  member val ZMM12A =
    var 64<rt> (Register.toRegID Register.ZMM12A) "ZMM12A" with get
  member val ZMM12B =
    var 64<rt> (Register.toRegID Register.ZMM12B) "ZMM12B" with get
  member val ZMM12C =
    var 64<rt> (Register.toRegID Register.ZMM12C) "ZMM12C" with get
  member val ZMM12D =
    var 64<rt> (Register.toRegID Register.ZMM12D) "ZMM12D" with get
  member val ZMM12E =
    var 64<rt> (Register.toRegID Register.ZMM12E) "ZMM12E" with get
  member val ZMM12F =
    var 64<rt> (Register.toRegID Register.ZMM12F) "ZMM12F" with get
  member val ZMM12G =
    var 64<rt> (Register.toRegID Register.ZMM12G) "ZMM12G" with get
  member val ZMM12H =
    var 64<rt> (Register.toRegID Register.ZMM12H) "ZMM12H" with get
  member val ZMM13A =
    var 64<rt> (Register.toRegID Register.ZMM13A) "ZMM13A" with get
  member val ZMM13B =
    var 64<rt> (Register.toRegID Register.ZMM13B) "ZMM13B" with get
  member val ZMM13C =
    var 64<rt> (Register.toRegID Register.ZMM13C) "ZMM13C" with get
  member val ZMM13D =
    var 64<rt> (Register.toRegID Register.ZMM13D) "ZMM13D" with get
  member val ZMM13E =
    var 64<rt> (Register.toRegID Register.ZMM13E) "ZMM13E" with get
  member val ZMM13F =
    var 64<rt> (Register.toRegID Register.ZMM13F) "ZMM13F" with get
  member val ZMM13G =
    var 64<rt> (Register.toRegID Register.ZMM13G) "ZMM13G" with get
  member val ZMM13H =
    var 64<rt> (Register.toRegID Register.ZMM13H) "ZMM13H" with get
  member val ZMM14A =
    var 64<rt> (Register.toRegID Register.ZMM14A) "ZMM14A" with get
  member val ZMM14B =
    var 64<rt> (Register.toRegID Register.ZMM14B) "ZMM14B" with get
  member val ZMM14C =
    var 64<rt> (Register.toRegID Register.ZMM14C) "ZMM14C" with get
  member val ZMM14D =
    var 64<rt> (Register.toRegID Register.ZMM14D) "ZMM14D" with get
  member val ZMM14E =
    var 64<rt> (Register.toRegID Register.ZMM14E) "ZMM14E" with get
  member val ZMM14F =
    var 64<rt> (Register.toRegID Register.ZMM14F) "ZMM14F" with get
  member val ZMM14G =
    var 64<rt> (Register.toRegID Register.ZMM14G) "ZMM14G" with get
  member val ZMM14H =
    var 64<rt> (Register.toRegID Register.ZMM14H) "ZMM14H" with get
  member val ZMM15A =
    var 64<rt> (Register.toRegID Register.ZMM15A) "ZMM15A" with get
  member val ZMM15B =
    var 64<rt> (Register.toRegID Register.ZMM15B) "ZMM15B" with get
  member val ZMM15C =
    var 64<rt> (Register.toRegID Register.ZMM15C) "ZMM15C" with get
  member val ZMM15D =
    var 64<rt> (Register.toRegID Register.ZMM15D) "ZMM15D" with get
  member val ZMM15E =
    var 64<rt> (Register.toRegID Register.ZMM15E) "ZMM15E" with get
  member val ZMM15F =
    var 64<rt> (Register.toRegID Register.ZMM15F) "ZMM15F" with get
  member val ZMM15G =
    var 64<rt> (Register.toRegID Register.ZMM15G) "ZMM15G" with get
  member val ZMM15H =
    var 64<rt> (Register.toRegID Register.ZMM15H) "ZMM15H" with get

  (* MPX Registers *)
  member val BND0A =
    var 64<rt> (Register.toRegID Register.BND0A) "BND0A" with get
  member val BND0B =
    var 64<rt> (Register.toRegID Register.BND0B) "BND0B" with get
  member val BND1A =
    var 64<rt> (Register.toRegID Register.BND1A) "BND1A" with get
  member val BND1B =
    var 64<rt> (Register.toRegID Register.BND1B) "BND1B" with get
  member val BND2A =
    var 64<rt> (Register.toRegID Register.BND2A) "BND2A" with get
  member val BND2B =
    var 64<rt> (Register.toRegID Register.BND2B) "BND2B" with get
  member val BND3A =
    var 64<rt> (Register.toRegID Register.BND3A) "BND3A" with get
  member val BND3B =
    var 64<rt> (Register.toRegID Register.BND3B) "BND3B" with get
  (* x87 FPU registers *)
  member val FCW = fcw with get
  member val FSW = fsw with get
  member val FTW = ftw with get
  member val FOP = fop with get
  member val FIP = fip with get
  member val FCS = fcs with get
  member val FDP = fdp with get
  member val FDS = fds with get
  member val MXCSR = mxcsr with get
  member val MXCSRMASK = mxcsrmask with get
  member val PKRU = pkru with get
  (* x87 FPU Stack component registers *)
  member val ST0A = st0a
  member val ST0B = st0b
  member val ST1A = st1a
  member val ST1B = st1b
  member val ST2A = st2a
  member val ST2B = st2b
  member val ST3A = st3a
  member val ST3B = st3b
  member val ST4A = st4a
  member val ST4B = st4b
  member val ST5A = st5a
  member val ST5B = st5b
  member val ST6A = st6a
  member val ST6B = st6b
  member val ST7A = st7a
  member val ST7B = st7b
  (* x87 FPU Top register *)
  member val FTOP =
    (fsw .& numI32 0x3800 16<rt>) >> numI32 11 16<rt> |> AST.xtlo 8<rt>
  (* x87 FPU Tag word sections *)
  member val FTW0 =
    (ftw .& numI32 0x3 16<rt>) >> numI32 0 16<rt> |> AST.xtlo 8<rt>
  member val FTW1 =
    (ftw .& numI32 0xC 16<rt>) >> numI32 2 16<rt> |> AST.xtlo 8<rt>
  member val FTW2 =
    (ftw .& numI32 0x30 16<rt>) >> numI32 4 16<rt> |> AST.xtlo 8<rt>
  member val FTW3 =
    (ftw .& numI32 0xC0 16<rt>) >> numI32 6 16<rt> |> AST.xtlo 8<rt>
  member val FTW4 =
    (ftw .& numI32 0x300 16<rt>) >> numI32 8 16<rt> |> AST.xtlo 8<rt>
  member val FTW5 =
    (ftw .& numI32 0xC00 16<rt>) >> numI32 10 16<rt> |> AST.xtlo 8<rt>
  member val FTW6 =
    (ftw .& numI32 0x3000 16<rt>) >> numI32 12 16<rt> |> AST.xtlo 8<rt>
  member val FTW7 =
    (ftw .& numI32 0xC000 16<rt>) >> numI32 14 16<rt> |> AST.xtlo 8<rt>
  (* x87 Status Word Flags *)
  member val FSWC0 = AST.extract fsw 1<rt> 8
  member val FSWC1 = AST.extract fsw 1<rt> 9
  member val FSWC2 = AST.extract fsw 1<rt> 10
  member val FSWC3 = AST.extract fsw 1<rt> 14
  (* Opmask registers *)
  member val K0 = k0 with get
  member val K1 = k1 with get
  member val K2 = k2 with get
  member val K3 = k3 with get
  member val K4 = k4 with get
  member val K5 = k5 with get
  member val K6 = k6 with get
  member val K7 = k7 with get
  (* Debug registers *)
  member val DR0 = dr0 with get
  member val DR1 = dr1 with get
  member val DR2 = dr2 with get
  member val DR3 = dr3 with get
  member val DR6 = dr6 with get
  member val DR7 = dr7 with get

  member __.GetRegVar (name) =
    match name with
    | R.RAX ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RAX
    | R.RBX ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RBX
    | R.RCX ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RCX
    | R.RDX ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RDX
    | R.RSP ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RSP
    | R.RBP ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RBP
    | R.RSI ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RSI
    | R.RDI ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RDI
    | R.EAX -> __.EAX
    | R.EBX -> __.EBX
    | R.ECX -> __.ECX
    | R.EDX -> __.EDX
    | R.ESP -> __.ESP
    | R.EBP -> __.EBP
    | R.ESI -> __.ESI
    | R.EDI -> __.EDI
    | R.AX -> __.AX
    | R.BX -> __.BX
    | R.CX -> __.CX
    | R.DX -> __.DX
    | R.SP -> __.SP
    | R.BP -> __.BP
    | R.SI -> __.SI
    | R.DI -> __.DI
    | R.AL -> __.AL
    | R.BL -> __.BL
    | R.CL -> __.CL
    | R.DL -> __.DL
    | R.AH -> __.AH
    | R.BH -> __.BH
    | R.CH -> __.CH
    | R.DH -> __.DH
    | R.R8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R8
    | R.R9 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R9
    | R.R10 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R10
    | R.R11 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R11
    | R.R12 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R12
    | R.R13 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R13
    | R.R14 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R14
    | R.R15 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R15
    | R.R8D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R8D
    | R.R9D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R9D
    | R.R10D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R10D
    | R.R11D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R11D
    | R.R12D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R12D
    | R.R13D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R13D
    | R.R14D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R14D
    | R.R15D ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R15D
    | R.R8W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R8W
    | R.R9W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R9W
    | R.R10W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R10W
    | R.R11W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R11W
    | R.R12W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R12W
    | R.R13W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R13W
    | R.R14W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R14W
    | R.R15W ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R15W
    | R.R8L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R8L
    | R.R9L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R9L
    | R.R10L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R10L
    | R.R11L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R11L
    | R.R12L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R12L
    | R.R13L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R13L
    | R.R14L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R14L
    | R.R15L ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.R15L
    | R.SPL ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.SPL
    | R.BPL ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.BPL
    | R.SIL ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.SIL
    | R.DIL ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.DIL
    | R.EIP ->
#if DEBUG
      assert32Bit wordSize
#endif
      __.EIP
    | R.RIP ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.RIP
    | R.CS -> __.CS
    | R.DS -> __.DS
    | R.ES -> __.ES
    | R.FS -> __.FS
    | R.GS -> __.GS
    | R.SS -> __.SS
    | R.CSBase -> __.CSBase
    | R.DSBase -> __.DSBase
    | R.ESBase -> __.ESBase
    | R.FSBase -> __.FSBase
    | R.GSBase -> __.GSBase
    | R.SSBase -> __.SSBase
    | R.CR0 -> __.CR0
    | R.CR2 -> __.CR2
    | R.CR3 -> __.CR3
    | R.CR4 -> __.CR4
    | R.CR8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.CR8
    | R.OF -> __.OF
    | R.DF -> __.DF
    | R.IF -> __.IF
    | R.TF -> __.TF
    | R.SF -> __.SF
    | R.ZF -> __.ZF
    | R.AF -> __.AF
    | R.PF -> __.PF
    | R.CF -> __.CF
    | R.MM0 -> __.MM0
    | R.MM1 -> __.MM1
    | R.MM2 -> __.MM2
    | R.MM3 -> __.MM3
    | R.MM4 -> __.MM4
    | R.MM5 -> __.MM5
    | R.MM6 -> __.MM6
    | R.MM7 -> __.MM7
    | R.FCW -> __.FCW
    | R.FSW -> __.FSW
    | R.FTW -> __.FTW
    | R.FOP -> __.FOP
    | R.FIP -> __.FIP
    | R.FCS -> __.FCS
    | R.FDP -> __.FDP
    | R.FDS -> __.FDS
    | R.FTOP -> __.FTOP
    | R.FTW0 -> __.FTW0
    | R.FTW1 -> __.FTW1
    | R.FTW2 -> __.FTW2
    | R.FTW3 -> __.FTW3
    | R.FTW4 -> __.FTW4
    | R.FTW5 -> __.FTW5
    | R.FTW6 -> __.FTW6
    | R.FTW7 -> __.FTW7
    | R.FSWC0 -> __.FSWC0
    | R.FSWC1 -> __.FSWC1
    | R.FSWC2 -> __.FSWC2
    | R.FSWC3 -> __.FSWC3
    | R.MXCSR -> __.MXCSR
    | R.MXCSRMASK -> __.MXCSRMASK
    | R.PKRU -> __.PKRU
    | R.ST0 -> AST.concat __.ST0B __.ST0A
    | R.ST1 -> AST.concat __.ST1B __.ST1A
    | R.ST2 -> AST.concat __.ST2B __.ST2A
    | R.ST3 -> AST.concat __.ST3B __.ST3A
    | R.ST4 -> AST.concat __.ST4B __.ST4A
    | R.ST5 -> AST.concat __.ST5B __.ST5A
    | R.ST6 -> AST.concat __.ST6B __.ST6A
    | R.ST7 -> AST.concat __.ST7B __.ST7A
    | R.K0 -> __.K0
    | R.K1 -> __.K1
    | R.K2 -> __.K2
    | R.K3 -> __.K3
    | R.K4 -> __.K4
    | R.K5 -> __.K5
    | R.K6 -> __.K6
    | R.K7 -> __.K7
    | R.DR0 -> __.DR0
    | R.DR1 -> __.DR1
    | R.DR2 -> __.DR2
    | R.DR3 -> __.DR3
    | R.DR6 -> __.DR6
    | R.DR7 -> __.DR7
    | _ -> failwith "Unhandled register."

  member __.GetPseudoRegVar name pos =
    match name, pos with
    | R.XMM0, 1 -> __.ZMM0A
    | R.XMM0, 2 -> __.ZMM0B
    | R.XMM1, 1 -> __.ZMM1A
    | R.XMM1, 2 -> __.ZMM1B
    | R.XMM2, 1 -> __.ZMM2A
    | R.XMM2, 2 -> __.ZMM2B
    | R.XMM3, 1 -> __.ZMM3A
    | R.XMM3, 2 -> __.ZMM3B
    | R.XMM4, 1 -> __.ZMM4A
    | R.XMM4, 2 -> __.ZMM4B
    | R.XMM5, 1 -> __.ZMM5A
    | R.XMM5, 2 -> __.ZMM5B
    | R.XMM6, 1 -> __.ZMM6A
    | R.XMM6, 2 -> __.ZMM6B
    | R.XMM7, 1 -> __.ZMM7A
    | R.XMM7, 2 -> __.ZMM7B
    | R.XMM8, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8A
    | R.XMM8, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8B
    | R.XMM9, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9A
    | R.XMM9, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9B
    | R.XMM10, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10A
    | R.XMM10, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10B
    | R.XMM11, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11A
    | R.XMM11, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11B
    | R.XMM12, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12A
    | R.XMM12, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12B
    | R.XMM13, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13A
    | R.XMM13, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13B
    | R.XMM14, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14A
    | R.XMM14, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14B
    | R.XMM15, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15A
    | R.XMM15, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15B
    | R.YMM0, 1 -> __.ZMM0A
    | R.YMM0, 2 -> __.ZMM0B
    | R.YMM0, 3 -> __.ZMM0C
    | R.YMM0, 4 -> __.ZMM0D
    | R.YMM1, 1 -> __.ZMM1A
    | R.YMM1, 2 -> __.ZMM1B
    | R.YMM1, 3 -> __.ZMM1C
    | R.YMM1, 4 -> __.ZMM1D
    | R.YMM2, 1 -> __.ZMM2A
    | R.YMM2, 2 -> __.ZMM2B
    | R.YMM2, 3 -> __.ZMM2C
    | R.YMM2, 4 -> __.ZMM2D
    | R.YMM3, 1 -> __.ZMM3A
    | R.YMM3, 2 -> __.ZMM3B
    | R.YMM3, 3 -> __.ZMM3C
    | R.YMM3, 4 -> __.ZMM3D
    | R.YMM4, 1 -> __.ZMM4A
    | R.YMM4, 2 -> __.ZMM4B
    | R.YMM4, 3 -> __.ZMM4C
    | R.YMM4, 4 -> __.ZMM4D
    | R.YMM5, 1 -> __.ZMM5A
    | R.YMM5, 2 -> __.ZMM5B
    | R.YMM5, 3 -> __.ZMM5C
    | R.YMM5, 4 -> __.ZMM5D
    | R.YMM6, 1 -> __.ZMM6A
    | R.YMM6, 2 -> __.ZMM6B
    | R.YMM6, 3 -> __.ZMM6C
    | R.YMM6, 4 -> __.ZMM6D
    | R.YMM7, 1 -> __.ZMM7A
    | R.YMM7, 2 -> __.ZMM7B
    | R.YMM7, 3 -> __.ZMM7C
    | R.YMM7, 4 -> __.ZMM7D
    | R.YMM8, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8A
    | R.YMM8, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8B
    | R.YMM8, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8C
    | R.YMM8, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8D
    | R.YMM9, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9A
    | R.YMM9, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9B
    | R.YMM9, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9C
    | R.YMM9, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9D
    | R.YMM10, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10A
    | R.YMM10, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10B
    | R.YMM10, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10C
    | R.YMM10, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10D
    | R.YMM11, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11A
    | R.YMM11, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11B
    | R.YMM11, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11C
    | R.YMM11, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11D
    | R.YMM12, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12A
    | R.YMM12, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12B
    | R.YMM12, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12C
    | R.YMM12, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12D
    | R.YMM13, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13A
    | R.YMM13, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13B
    | R.YMM13, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13C
    | R.YMM13, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13D
    | R.YMM14, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14A
    | R.YMM14, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14B
    | R.YMM14, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14C
    | R.YMM14, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14D
    | R.YMM15, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15A
    | R.YMM15, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15B
    | R.YMM15, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15C
    | R.YMM15, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15D
    | R.ZMM0, 1 -> __.ZMM0A
    | R.ZMM0, 2 -> __.ZMM0B
    | R.ZMM0, 3 -> __.ZMM0C
    | R.ZMM0, 4 -> __.ZMM0D
    | R.ZMM0, 5 -> __.ZMM0E
    | R.ZMM0, 6 -> __.ZMM0F
    | R.ZMM0, 7 -> __.ZMM0G
    | R.ZMM0, 8 -> __.ZMM0H
    | R.ZMM1, 1 -> __.ZMM1A
    | R.ZMM1, 2 -> __.ZMM1B
    | R.ZMM1, 3 -> __.ZMM1C
    | R.ZMM1, 4 -> __.ZMM1D
    | R.ZMM1, 5 -> __.ZMM1E
    | R.ZMM1, 6 -> __.ZMM1F
    | R.ZMM1, 7 -> __.ZMM1G
    | R.ZMM1, 8 -> __.ZMM1H
    | R.ZMM2, 1 -> __.ZMM2A
    | R.ZMM2, 2 -> __.ZMM2B
    | R.ZMM2, 3 -> __.ZMM2C
    | R.ZMM2, 4 -> __.ZMM2D
    | R.ZMM2, 5 -> __.ZMM2E
    | R.ZMM2, 6 -> __.ZMM2F
    | R.ZMM2, 7 -> __.ZMM2G
    | R.ZMM2, 8 -> __.ZMM2H
    | R.ZMM3, 1 -> __.ZMM3A
    | R.ZMM3, 2 -> __.ZMM3B
    | R.ZMM3, 3 -> __.ZMM3C
    | R.ZMM3, 4 -> __.ZMM3D
    | R.ZMM3, 5 -> __.ZMM3E
    | R.ZMM3, 6 -> __.ZMM3F
    | R.ZMM3, 7 -> __.ZMM3G
    | R.ZMM3, 8 -> __.ZMM3H
    | R.ZMM4, 1 -> __.ZMM4A
    | R.ZMM4, 2 -> __.ZMM4B
    | R.ZMM4, 3 -> __.ZMM4C
    | R.ZMM4, 4 -> __.ZMM4D
    | R.ZMM4, 5 -> __.ZMM4E
    | R.ZMM4, 6 -> __.ZMM4F
    | R.ZMM4, 7 -> __.ZMM4G
    | R.ZMM4, 8 -> __.ZMM4H
    | R.ZMM5, 1 -> __.ZMM5A
    | R.ZMM5, 2 -> __.ZMM5B
    | R.ZMM5, 3 -> __.ZMM5C
    | R.ZMM5, 4 -> __.ZMM5D
    | R.ZMM5, 5 -> __.ZMM5E
    | R.ZMM5, 6 -> __.ZMM5F
    | R.ZMM5, 7 -> __.ZMM5G
    | R.ZMM5, 8 -> __.ZMM5H
    | R.ZMM6, 1 -> __.ZMM6A
    | R.ZMM6, 2 -> __.ZMM6B
    | R.ZMM6, 3 -> __.ZMM6C
    | R.ZMM6, 4 -> __.ZMM6D
    | R.ZMM6, 5 -> __.ZMM6E
    | R.ZMM6, 6 -> __.ZMM6F
    | R.ZMM6, 7 -> __.ZMM6G
    | R.ZMM6, 8 -> __.ZMM6H
    | R.ZMM7, 1 -> __.ZMM7A
    | R.ZMM7, 2 -> __.ZMM7B
    | R.ZMM7, 3 -> __.ZMM7C
    | R.ZMM7, 4 -> __.ZMM7D
    | R.ZMM7, 5 -> __.ZMM7E
    | R.ZMM7, 6 -> __.ZMM7F
    | R.ZMM7, 7 -> __.ZMM7G
    | R.ZMM7, 8 -> __.ZMM7H
    | R.ZMM8, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8A
    | R.ZMM8, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8B
    | R.ZMM8, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8C
    | R.ZMM8, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8D
    | R.ZMM8, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8E
    | R.ZMM8, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8F
    | R.ZMM8, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8G
    | R.ZMM8, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM8F
    | R.ZMM9, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9A
    | R.ZMM9, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9B
    | R.ZMM9, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9C
    | R.ZMM9, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9D
    | R.ZMM9, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9E
    | R.ZMM9, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9F
    | R.ZMM9, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9G
    | R.ZMM9, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM9F
    | R.ZMM10, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10A
    | R.ZMM10, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10B
    | R.ZMM10, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10C
    | R.ZMM10, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10D
    | R.ZMM10, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10E
    | R.ZMM10, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10F
    | R.ZMM10, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10G
    | R.ZMM10, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM10F
    | R.ZMM11, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11A
    | R.ZMM11, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11B
    | R.ZMM11, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11C
    | R.ZMM11, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11D
    | R.ZMM11, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11E
    | R.ZMM11, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11F
    | R.ZMM11, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11G
    | R.ZMM11, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM11F
    | R.ZMM12, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12A
    | R.ZMM12, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12B
    | R.ZMM12, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12C
    | R.ZMM12, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12D
    | R.ZMM12, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12E
    | R.ZMM12, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12F
    | R.ZMM12, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12G
    | R.ZMM12, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM12F
    | R.ZMM13, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13A
    | R.ZMM13, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13B
    | R.ZMM13, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13C
    | R.ZMM13, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13D
    | R.ZMM13, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13E
    | R.ZMM13, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13F
    | R.ZMM13, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13G
    | R.ZMM13, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM13F
    | R.ZMM14, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14A
    | R.ZMM14, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14B
    | R.ZMM14, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14C
    | R.ZMM14, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14D
    | R.ZMM14, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14E
    | R.ZMM14, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14F
    | R.ZMM14, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14G
    | R.ZMM14, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM14F
    | R.ZMM15, 1 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15A
    | R.ZMM15, 2 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15B
    | R.ZMM15, 3 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15C
    | R.ZMM15, 4 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15D
    | R.ZMM15, 5 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15E
    | R.ZMM15, 6 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15F
    | R.ZMM15, 7 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15G
    | R.ZMM15, 8 ->
#if DEBUG
      assert64Bit wordSize
#endif
      __.ZMM15F
    | R.BND0, 1 -> __.BND0A
    | R.BND0, 2 -> __.BND0B
    | R.BND1, 1 -> __.BND1A
    | R.BND1, 2 -> __.BND1B
    | R.BND2, 1 -> __.BND2A
    | R.BND2, 2 -> __.BND2B
    | R.BND3, 1 -> __.BND3A
    | R.BND3, 2 -> __.BND3B
    | R.ST0, 1 -> __.ST0A
    | R.ST0, 2 -> __.ST0B
    | R.ST1, 1 -> __.ST1A
    | R.ST1, 2 -> __.ST1B
    | R.ST2, 1 -> __.ST2A
    | R.ST2, 2 -> __.ST2B
    | R.ST3, 1 -> __.ST3A
    | R.ST3, 2 -> __.ST3B
    | R.ST4, 1 -> __.ST4A
    | R.ST4, 2 -> __.ST4B
    | R.ST5, 1 -> __.ST5A
    | R.ST5, 2 -> __.ST5B
    | R.ST6, 1 -> __.ST6A
    | R.ST6, 2 -> __.ST6B
    | R.ST7, 1 -> __.ST7A
    | R.ST7, 2 -> __.ST7B
    | _ -> raise B2R2.FrontEnd.BinLifter.UnhandledRegExprException

// vim: set tw=80 sts=2 sw=2:

IntelRegister.fs
//这段代码定义了x86中寄存器的类型和相关函数:
//1. 定义了Register类型,包含所有x86寄存器。
//2. Register模块提供获取寄存器种类、ID、名称等工具函数。
//3. 定义了一些常用寄存器组,如EAX组包含RAX/EAX等不同长度的EAX寄存器。
//主要功能和意义有:
//- 定义完整的x86寄存器集,方便后续操作和引用寄存器
//- 提供方便的工具函数获取寄存器信息,如名称转换,扩展长度等
//- 定义常用寄存器组概念,对应不同长度下的同组寄存器,方便集中操作
//- 数据结构清晰完整,后续处理x86指令和寄存器时可以直接使用定义
//- Register模块实现了大部分常见操作,提高使用寄存器相关功能的便利性
//总体来说,这个模块很好的定义和封装了x86的寄存器信息,为后续处理x86二进制代码数据提供了统一且便利的寄存器管理功能。
//它建立了寄存器在后续流程中的基础数据结构和操作接口。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open System.Runtime.CompilerServices

[<assembly: InternalsVisibleTo("B2R2.FrontEnd.BinLifter.Tests")>]
do ()

/// This exception occurs when an UnknownReg is explicitly used. This exception
/// should not happen in general.
exception UnknownRegException

/// <summary>
/// Registers for x86 (and x86-64).<para/>
/// </summary>
type Register =
  /// Accumulator for operands and results data (64bit).
  | RAX = 0x0
  /// TCounter for string and loop operations (64bit).
  | RCX = 0x1
  /// I/O pointer (64bit).
  | RDX = 0x2
  /// Pointer to data in the DS segment (64bit).
  | RBX = 0x3
  /// Stack pointer (in the SS segment) (64bit).
  | RSP = 0x4
  /// Pointer to data on the stack (in the SS segment) (64bit).
  | RBP = 0x5
  /// Pointer to data in the segment pointed to by the DS register (64bit).
  | RSI = 0x6
  /// Pointer to data in the segment pointed to by the ES register (64bit).
  | RDI = 0x7
  /// General-Purpose Registers for 64bit Mode.
  | R8 = 0x8
  /// General-Purpose Registers for 64bit Mode.
  | R9 = 0x9
  /// General-Purpose Registers for 64bit Mode.
  | R10 = 0xA
  /// General-Purpose Registers for 64bit Mode.
  | R11 = 0xB
  /// General-Purpose Registers for 64bit Mode.
  | R12 = 0xC
  /// General-Purpose Registers for 64bit Mode.
  | R13 = 0xD
  /// General-Purpose Registers for 64bit Mode.
  | R14 = 0xE
  /// General-Purpose Registers for 64bit Mode.
  | R15 = 0xF
  /// Accumulator for operands and results data (32bit).
  | EAX = 0x10
  /// TCounter for string and loop operations (32bit).
  | ECX = 0x11
  /// I/O pointer (32bit).
  | EDX = 0x12
  /// Pointer to data in the DS segment (32bit).
  | EBX = 0x13
  /// Stack pointer (in the SS segment) (32bit).
  | ESP = 0x14
  /// Pointer to data on the stack (in the SS segment) (32bit).
  | EBP = 0x15
  /// Pointer to data in the segment pointed to by the DS register (32bit).
  | ESI = 0x16
  /// Pointer to data in the segment pointed to by the ES register (32bit).
  | EDI = 0x17
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R8D = 0x18
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R9D = 0x19
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R10D = 0x1A
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R11D = 0x1B
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R12D = 0x1C
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R13D = 0x1D
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R14D = 0x1E
  /// General-Purpose Registers for 64bit Mode (Doubleword Register).
  | R15D = 0x1F
  /// General-Purpose Registers (lower 16bits EAX).
  | AX = 0x20
  /// General-Purpose Registers (lower 16bits ECX).
  | CX = 0x21
  /// General-Purpose Registers (lower 16bits EDX).
  | DX = 0x22
  /// General-Purpose Registers (lower 16bits EBX).
  | BX = 0x23
  /// General-Purpose Registers (lower 16bits ESP).
  | SP = 0x24
  /// General-Purpose Registers (lower 16bits EBP).
  | BP = 0x25
  /// General-Purpose Registers (lower 16bits ESI).
  | SI = 0x26
  /// General-Purpose Registers (lower 16bits EDI).
  | DI = 0x27
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R8W = 0x28
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R9W = 0x29
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R10W = 0x2A
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R11W = 0x2B
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R12W = 0x2C
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R13W = 0x2D
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R14W = 0x2E
  /// General-Purpose Registers for 64bit Mode (Word Register).
  | R15W = 0x2F
  /// General-Purpose Registers (lower 8bits AX).
  | AL = 0x30
  /// General-Purpose Registers (lower 8bits CX).
  | CL = 0x31
  /// General-Purpose Registers (lower 8bits DX).
  | DL = 0x32
  /// General-Purpose Registers (lower 8bits BX).
  | BL = 0x33
  /// General-Purpose Registers (Higher 8bits AX).
  | AH = 0x34
  /// General-Purpose Registers (Higher 8bits CX).
  | CH = 0x35
  /// General-Purpose Registers (Higher 8bits DX).
  | DH = 0x36
  /// General-Purpose Registers (Higher 8bits BX).
  | BH = 0x37
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R8L = 0x38
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R9L = 0x39
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R10L = 0x3A
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R11L = 0x3B
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R12L = 0x3C
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R13L = 0x3D
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R14L = 0x3E
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | R15L = 0x3F
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | SPL = 0x40
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | BPL = 0x41
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | SIL = 0x42
  /// General-Purpose Registers for 64bit Mode (Byte Register).
  | DIL = 0x43
  /// Instruction Pointer (32Bit).
  | EIP = 0x44
  /// Instruction Pointer (64Bit).
  | RIP = 0x45
  /// x87 FPU registers.
  | ST0 = 0x46
  /// x87 FPU registers.
  | ST1 = 0x47
  /// x87 FPU registers.
  | ST2 = 0x48
  /// x87 FPU registers.
  | ST3 = 0x49
  /// x87 FPU registers.
  | ST4 = 0x4A
  /// x87 FPU registers.
  | ST5 = 0x4B
  /// x87 FPU registers.
  | ST6 = 0x4C
  /// x87 FPU registers.
  | ST7 = 0x4D
  /// C87 FPU Control Word.
  | FCW = 0x4E
  /// x87 FPU Status Word.
  | FSW = 0x4F
  /// x87 FPU Tag Word.
  | FTW = 0x50
  /// x87 FPU Opcode.
  | FOP = 0x51
  /// x87 FPU Instruction Pointer Offset.
  | FIP = 0x52
  /// x87 FPU Instruction Pointer Selector.
  | FCS = 0x53
  /// x87 FPU Data Pointer Offset.
  | FDP = 0x54
  /// x87 FPU Data Pointer Selector.
  | FDS = 0x55
  /// x87 FPU Top indicator bits of Status Word.
  | FTOP = 0x56
  /// x87 FPU Tag word section.
  | FTW0 = 0x57
  /// x87 FPU Tag word section.
  | FTW1 = 0x58
  /// x87 FPU Tag word section.
  | FTW2 = 0x59
  /// x87 FPU Tag word section.
  | FTW3 = 0x5A
  /// x87 FPU Tag word section.
  | FTW4 = 0x5B
  /// x87 FPU Tag word section.
  | FTW5 = 0x5C
  /// x87 FPU Tag word section.
  | FTW6 = 0x5D
  /// x87 FPU Tag word section.
  | FTW7 = 0x5E
  /// x87 FPU Status Word C flag.
  | FSWC0 = 0x5F
  /// x87 FPU Status Word C flag.
  | FSWC1 = 0x60
  /// x87 FPU Status Word C flag.
  | FSWC2 = 0x61
  /// x87 FPU Status Word C flag.
  | FSWC3 = 0x62
  /// MXCSR Control and Status Register.
  | MXCSR = 0x63
  /// MXCSR_MASK.
  | MXCSRMASK = 0x64
  /// MMX registers.
  | MM0 = 0x65
  /// MMX registers.
  | MM1 = 0x66
  /// MMX registers.
  | MM2 = 0x67
  /// MMX registers.
  | MM3 = 0x68
  /// MMX registers.
  | MM4 = 0x69
  /// MMX registers.
  | MM5 = 0x6A
  /// MMX registers.
  | MM6 = 0x6B
  /// MMX registers.
  | MM7 = 0x6C
  /// XMM registers.
  | XMM0 = 0x6D
  /// XMM registers.
  | XMM1 = 0x6E
  /// XMM registers.
  | XMM2 = 0x6F
  /// XMM registers.
  | XMM3 = 0x70
  /// XMM registers.
  | XMM4 = 0x71
  /// XMM registers.
  | XMM5 = 0x72
  /// XMM registers.
  | XMM6 = 0x73
  /// XMM registers.
  | XMM7 = 0x74
  /// XMM registers.
  | XMM8 = 0x75
  /// XMM registers.
  | XMM9 = 0x76
  /// XMM registers.
  | XMM10 = 0x77
  /// XMM registers.
  | XMM11 = 0x78
  /// XMM registers.
  | XMM12 = 0x79
  /// XMM registers.
  | XMM13 = 0x7A
  /// XMM registers.
  | XMM14 = 0x7B
  /// XMM registers.
  | XMM15 = 0x7C
  /// 256-bit vector registers.
  | YMM0 = 0x7D
  /// 256-bit vector registers.
  | YMM1 = 0x7E
  /// 256-bit vector registers.
  | YMM2 = 0x7F
  /// 256-bit vector registers.
  | YMM3 = 0x80
  /// 256-bit vector registers.
  | YMM4 = 0x81
  /// 256-bit vector registers.
  | YMM5 = 0x82
  /// 256-bit vector registers.
  | YMM6 = 0x83
  /// 256-bit vector registers.
  | YMM7 = 0x84
  /// 256-bit vector registers.
  | YMM8 = 0x85
  /// 256-bit vector registers.
  | YMM9 = 0x86
  /// 256-bit vector registers.
  | YMM10 = 0x87
  /// 256-bit vector registers.
  | YMM11 = 0x88
  /// 256-bit vector registers.
  | YMM12 = 0x89
  /// 256-bit vector registers.
  | YMM13 = 0x8A
  /// 256-bit vector registers.
  | YMM14 = 0x8B
  /// 256-bit vector registers.
  | YMM15 = 0x8C
  /// 512-bit vector registers.
  | ZMM0 = 0x8D
  /// 512-bit vector registers.
  | ZMM1 = 0x8E
  /// 512-bit vector registers.
  | ZMM2 = 0x8F
  /// 512-bit vector registers.
  | ZMM3 = 0x90
  /// 512-bit vector registers.
  | ZMM4 = 0x91
  /// 512-bit vector registers.
  | ZMM5 = 0x92
  /// 512-bit vector registers.
  | ZMM6 = 0x93
  /// 512-bit vector registers.
  | ZMM7 = 0x94
  /// 512-bit vector registers.
  | ZMM8 = 0x95
  /// 512-bit vector registers.
  | ZMM9 = 0x96
  /// 512-bit vector registers.
  | ZMM10 = 0x97
  /// 512-bit vector registers.
  | ZMM11 = 0x98
  /// 512-bit vector registers.
  | ZMM12 = 0x99
  /// 512-bit vector registers.
  | ZMM13 = 0x9A
  /// 512-bit vector registers.
  | ZMM14 = 0x9B
  /// 512-bit vector registers.
  | ZMM15 = 0x9C
  /// Segment registers.
  | ES = 0x9D
  /// Segment registers.
  | CS = 0x9E
  /// Segment registers.
  | SS = 0x9F
  /// Segment registers.
  | DS = 0xA0
  /// Segment registers.
  | FS = 0xA1
  /// Segment registers.
  | GS = 0xA2
  /// ES.base.
  | ESBase = 0xA3
  /// CS.base.
  | CSBase = 0xA4
  /// SS.base.
  | SSBase = 0xA5
  /// DS.base.
  | DSBase = 0xA6
  /// FS.base.
  | FSBase = 0xA7
  /// GS.base.
  | GSBase = 0xA8
  /// Control registers.
  | CR0 = 0xA9
  /// Control registers.
  | CR2 = 0xAA
  /// Control registers.
  | CR3 = 0xAB
  /// Control registers.
  | CR4 = 0xAC
  /// Control registers.
  | CR8 = 0xAD
  /// Debug registers.
  | DR0 = 0xAE
  /// Debug registers.
  | DR1 = 0xAF
  /// Debug registers.
  | DR2 = 0xB0
  /// Debug registers.
  | DR3 = 0xB1
  /// Debug registers.
  | DR6 = 0xB2
  /// Debug registers.
  | DR7 = 0xB3
  /// BND registers.
  | BND0 = 0xB4
  /// BND registers.
  | BND1 = 0xB5
  /// BND registers.
  | BND2 = 0xB6
  /// BND registers.
  | BND3 = 0xB7
  /// Overflow Flag in EFLAGS Register
  | OF = 0xB8
  /// Direction Flag in EFLAGS Register
  | DF = 0xB9
  /// Interrupt Enable Flag in EFLAGS Register
  | IF = 0xBA
  /// Trap Flag in EFLAGS Register
  | TF = 0xBB
  /// Sign Flag in EFLAGS Register
  | SF = 0xBC
  /// Zero Flag in EFLAGS Register
  | ZF = 0xBD
  /// Auxiliary Carry Flag in EFLAGS Register
  | AF = 0xBE
  /// Parity Flag in EFLAGS Register
  | PF = 0xBF
  /// Carry Flag in EFLAGS Register
  | CF = 0xC0
  /// Protection-key features register.
  | PKRU = 0xC1
  /// BND Register (lower 64bits BND0).
  | BND0A = 0xC2
  /// BND Register (Higher 64bits BND0).
  | BND0B = 0xC3
  /// BND Register (lower 64bits BND1).
  | BND1A = 0xC4
  /// BND Register (Higher 64bits BND1).
  | BND1B = 0xC5
  /// BND Register (lower 64bits BND2).
  | BND2A = 0xC6
  /// BND Register (Higher 64bits BND2).
  | BND2B = 0xC7
  /// BND Register (lower 64bits BND3).
  | BND3A = 0xC8
  /// BND Register (Higher 64bits BND3).
  | BND3B = 0xC9
  /// ST Register (lower 64bits ST0).
  | ST0A = 0xCA
  /// ST Register (Higher 16bits ST0).
  | ST0B = 0xCB
  /// ST Register (lower 64bits ST1).
  | ST1A = 0xCC
  /// ST Register (Higher 16bits ST1).
  | ST1B = 0xCD
  /// ST Register (lower 64bits ST2).
  | ST2A = 0xCE
  /// ST Register (Higher 16bits ST2).
  | ST2B = 0xCF
  /// ST Register (lower 64bits ST3).
  | ST3A = 0xD0
  /// ST Register (Higher 16bits ST3).
  | ST3B = 0xD1
  /// ST Register (lower 64bits ST4).
  | ST4A = 0xD2
  /// ST Register (Higher 16bits ST4).
  | ST4B = 0xD3
  /// ST Register (lower 64bits ST5).
  | ST5A = 0xD4
  /// ST Register (Higher 16bits ST5).
  | ST5B = 0xD5
  /// ST Register (lower 64bits ST6).
  | ST6A = 0xD6
  /// ST Register (Higher 16bits ST6).
  | ST6B = 0xD7
  /// ST Register (lower 64bits ST7).
  | ST7A = 0xD8
  /// ST Register (Higher 16bits ST7).
  | ST7B = 0xD9
  /// ZMM0A is the 1st 64-bit chunk of ZMM0.
  | ZMM0A = 0xDA
  /// ZMM0B is the 2nd 64-bit chunk of ZMM0.
  | ZMM0B = 0xDB
  /// ZMM0C is the 3rd 64-bit chunk of ZMM0.
  | ZMM0C = 0xDC
  /// ZMM0D is the 4th 64-bit chunk of ZMM0.
  | ZMM0D = 0xDD
  /// ZMM0E is the 5th 64-bit chunk of ZMM0.
  | ZMM0E = 0xDE
  /// ZMM0F is the 6th 64-bit chunk of ZMM0.
  | ZMM0F = 0xDF
  /// ZMM0G is the 7th 64-bit chunk of ZMM0.
  | ZMM0G = 0xE0
  /// ZMM0H is the 8th 64-bit chunk of ZMM0.
  | ZMM0H = 0xE1
  /// ZMM1A is the 1st 64-bit chunk of ZMM1.
  | ZMM1A = 0xE2
  /// ZMM1B is the 2nd 64-bit chunk of ZMM1.
  | ZMM1B = 0xE3
  /// ZMM1C is the 3rd 64-bit chunk of ZMM1.
  | ZMM1C = 0xE4
  /// ZMM1D is the 4th 64-bit chunk of ZMM1.
  | ZMM1D = 0xE5
  /// ZMM1E is the 5th 64-bit chunk of ZMM1.
  | ZMM1E = 0xE6
  /// ZMM1F is the 6th 64-bit chunk of ZMM1.
  | ZMM1F = 0xE7
  /// ZMM1G is the 7th 64-bit chunk of ZMM1.
  | ZMM1G = 0xE8
  /// ZMM1H is the 8th 64-bit chunk of ZMM1.
  | ZMM1H = 0xE9
  /// ZMM2A is the 1st 64-bit chunk of ZMM2.
  | ZMM2A = 0xEA
  /// ZMM2B is the 2nd 64-bit chunk of ZMM2.
  | ZMM2B = 0xEB
  /// ZMM2C is the 3rd 64-bit chunk of ZMM2.
  | ZMM2C = 0xEC
  /// ZMM2D is the 4th 64-bit chunk of ZMM2.
  | ZMM2D = 0xED
  /// ZMM2E is the 5th 64-bit chunk of ZMM2.
  | ZMM2E = 0xEE
  /// ZMM2F is the 6th 64-bit chunk of ZMM2.
  | ZMM2F = 0xEF
  /// ZMM2G is the 7th 64-bit chunk of ZMM2.
  | ZMM2G = 0xF0
  /// ZMM2H is the 8th 64-bit chunk of ZMM2.
  | ZMM2H = 0xF1
  /// ZMM3A is the 1st 64-bit chunk of ZMM3.
  | ZMM3A = 0xF2
  /// ZMM3B is the 2nd 64-bit chunk of ZMM3.
  | ZMM3B = 0xF3
  /// ZMM3C is the 3rd 64-bit chunk of ZMM3.
  | ZMM3C = 0xF4
  /// ZMM3D is the 4th 64-bit chunk of ZMM3.
  | ZMM3D = 0xF5
  /// ZMM3E is the 5th 64-bit chunk of ZMM3.
  | ZMM3E = 0xF6
  /// ZMM3F is the 6th 64-bit chunk of ZMM3.
  | ZMM3F = 0xF7
  /// ZMM3G is the 7th 64-bit chunk of ZMM3.
  | ZMM3G = 0xF8
  /// ZMM3H is the 8th 64-bit chunk of ZMM3.
  | ZMM3H = 0xF9
  /// ZMM4A is the 1st 64-bit chunk of ZMM4.
  | ZMM4A = 0xFA
  /// ZMM4B is the 2nd 64-bit chunk of ZMM4.
  | ZMM4B = 0xFB
  /// ZMM4C is the 3rd 64-bit chunk of ZMM4.
  | ZMM4C = 0xFC
  /// ZMM4D is the 4th 64-bit chunk of ZMM4.
  | ZMM4D = 0xFD
  /// ZMM4E is the 5th 64-bit chunk of ZMM4.
  | ZMM4E = 0xFE
  /// ZMM4F is the 6th 64-bit chunk of ZMM4.
  | ZMM4F = 0xFF
  /// ZMM4G is the 7th 64-bit chunk of ZMM4.
  | ZMM4G = 0x100
  /// ZMM4H is the 8th 64-bit chunk of ZMM4.
  | ZMM4H = 0x101
  /// ZMM5A is the 1st 64-bit chunk of ZMM5.
  | ZMM5A = 0x102
  /// ZMM5B is the 2nd 64-bit chunk of ZMM5.
  | ZMM5B = 0x103
  /// ZMM5C is the 3rd 64-bit chunk of ZMM5.
  | ZMM5C = 0x104
  /// ZMM5D is the 4th 64-bit chunk of ZMM5.
  | ZMM5D = 0x105
  /// ZMM5E is the 5th 64-bit chunk of ZMM5.
  | ZMM5E = 0x106
  /// ZMM5F is the 6th 64-bit chunk of ZMM5.
  | ZMM5F = 0x107
  /// ZMM5G is the 7th 64-bit chunk of ZMM5.
  | ZMM5G = 0x108
  /// ZMM5H is the 8th 64-bit chunk of ZMM5.
  | ZMM5H = 0x109
  /// ZMM6A is the 1st 64-bit chunk of ZMM6.
  | ZMM6A = 0x10A
  /// ZMM6B is the 2nd 64-bit chunk of ZMM6.
  | ZMM6B = 0x10B
  /// ZMM6C is the 3rd 64-bit chunk of ZMM6.
  | ZMM6C = 0x10C
  /// ZMM6D is the 4th 64-bit chunk of ZMM6.
  | ZMM6D = 0x10D
  /// ZMM6E is the 5th 64-bit chunk of ZMM6.
  | ZMM6E = 0x10E
  /// ZMM6F is the 6th 64-bit chunk of ZMM6.
  | ZMM6F = 0x10F
  /// ZMM6G is the 7th 64-bit chunk of ZMM6.
  | ZMM6G = 0x110
  /// ZMM6H is the 8th 64-bit chunk of ZMM6.
  | ZMM6H = 0x111
  /// ZMM7A is the 1st 64-bit chunk of ZMM7.
  | ZMM7A = 0x112
  /// ZMM7B is the 2nd 64-bit chunk of ZMM7.
  | ZMM7B = 0x113
  /// ZMM7C is the 3rd 64-bit chunk of ZMM7.
  | ZMM7C = 0x114
  /// ZMM7D is the 4th 64-bit chunk of ZMM7.
  | ZMM7D = 0x115
  /// ZMM7E is the 5th 64-bit chunk of ZMM7.
  | ZMM7E = 0x116
  /// ZMM7F is the 6th 64-bit chunk of ZMM7.
  | ZMM7F = 0x117
  /// ZMM7G is the 7th 64-bit chunk of ZMM7.
  | ZMM7G = 0x118
  /// ZMM7H is the 8th 64-bit chunk of ZMM7.
  | ZMM7H = 0x119
  /// ZMM8A is the 1st 64-bit chunk of ZMM8.
  | ZMM8A = 0x11A
  /// ZMM8B is the 2nd 64-bit chunk of ZMM8.
  | ZMM8B = 0x11B
  /// ZMM8C is the 3rd 64-bit chunk of ZMM8.
  | ZMM8C = 0x11C
  /// ZMM8D is the 4th 64-bit chunk of ZMM8.
  | ZMM8D = 0x11D
  /// ZMM8E is the 5th 64-bit chunk of ZMM8.
  | ZMM8E = 0x11E
  /// ZMM8F is the 6th 64-bit chunk of ZMM8.
  | ZMM8F = 0x11F
  /// ZMM8G is the 7th 64-bit chunk of ZMM8.
  | ZMM8G = 0x120
  /// ZMM8H is the 8th 64-bit chunk of ZMM8.
  | ZMM8H = 0x121
  /// ZMM9A is the 1st 64-bit chunk of ZMM9.
  | ZMM9A = 0x122
  /// ZMM9B is the 2nd 64-bit chunk of ZMM9.
  | ZMM9B = 0x123
  /// ZMM9C is the 3rd 64-bit chunk of ZMM9.
  | ZMM9C = 0x124
  /// ZMM9D is the 4th 64-bit chunk of ZMM9.
  | ZMM9D = 0x125
  /// ZMM9E is the 5th 64-bit chunk of ZMM9.
  | ZMM9E = 0x126
  /// ZMM9F is the 6th 64-bit chunk of ZMM9.
  | ZMM9F = 0x127
  /// ZMM9G is the 7th 64-bit chunk of ZMM9.
  | ZMM9G = 0x128
  /// ZMM9H is the 8th 64-bit chunk of ZMM9.
  | ZMM9H = 0x129
  /// ZMM10A is the 1st 64-bit chunk of ZMM10.
  | ZMM10A = 0x12A
  /// ZMM10B is the 2nd 64-bit chunk of ZMM10.
  | ZMM10B = 0x12B
  /// ZMM10C is the 3rd 64-bit chunk of ZMM10.
  | ZMM10C = 0x12C
  /// ZMM10D is the 4th 64-bit chunk of ZMM10.
  | ZMM10D = 0x12D
  /// ZMM10E is the 5th 64-bit chunk of ZMM10.
  | ZMM10E = 0x12E
  /// ZMM10F is the 6th 64-bit chunk of ZMM10.
  | ZMM10F = 0x12F
  /// ZMM10G is the 7th 64-bit chunk of ZMM10.
  | ZMM10G = 0x130
  /// ZMM10H is the 8th 64-bit chunk of ZMM10.
  | ZMM10H = 0x131
  /// ZMM11A is the 1st 64-bit chunk of ZMM11.
  | ZMM11A = 0x132
  /// ZMM11B is the 2nd 64-bit chunk of ZMM11.
  | ZMM11B = 0x133
  /// ZMM11C is the 3rd 64-bit chunk of ZMM11.
  | ZMM11C = 0x134
  /// ZMM11D is the 4th 64-bit chunk of ZMM11.
  | ZMM11D = 0x135
  /// ZMM11E is the 5th 64-bit chunk of ZMM11.
  | ZMM11E = 0x136
  /// ZMM11F is the 6th 64-bit chunk of ZMM11.
  | ZMM11F = 0x137
  /// ZMM11G is the 7th 64-bit chunk of ZMM11.
  | ZMM11G = 0x138
  /// ZMM11H is the 8th 64-bit chunk of ZMM11.
  | ZMM11H = 0x139
  /// ZMM12A is the 1st 64-bit chunk of ZMM12.
  | ZMM12A = 0x13A
  /// ZMM12B is the 2nd 64-bit chunk of ZMM12.
  | ZMM12B = 0x13B
  /// ZMM12C is the 3rd 64-bit chunk of ZMM12.
  | ZMM12C = 0x13C
  /// ZMM12D is the 4th 64-bit chunk of ZMM12.
  | ZMM12D = 0x13D
  /// ZMM12E is the 5th 64-bit chunk of ZMM12.
  | ZMM12E = 0x13E
  /// ZMM12F is the 6th 64-bit chunk of ZMM12.
  | ZMM12F = 0x13F
  /// ZMM12G is the 7th 64-bit chunk of ZMM12.
  | ZMM12G = 0x140
  /// ZMM12H is the 8th 64-bit chunk of ZMM12.
  | ZMM12H = 0x141
  /// ZMM13A is the 1st 64-bit chunk of ZMM13.
  | ZMM13A = 0x142
  /// ZMM13B is the 2nd 64-bit chunk of ZMM13.
  | ZMM13B = 0x143
  /// ZMM13C is the 3rd 64-bit chunk of ZMM13.
  | ZMM13C = 0x144
  /// ZMM13D is the 4th 64-bit chunk of ZMM13.
  | ZMM13D = 0x145
  /// ZMM13E is the 5th 64-bit chunk of ZMM13.
  | ZMM13E = 0x146
  /// ZMM13F is the 6th 64-bit chunk of ZMM13.
  | ZMM13F = 0x147
  /// ZMM13G is the 7th 64-bit chunk of ZMM13.
  | ZMM13G = 0x148
  /// ZMM13H is the 8th 64-bit chunk of ZMM13.
  | ZMM13H = 0x149
  /// ZMM14A is the 1st 64-bit chunk of ZMM14.
  | ZMM14A = 0x14A
  /// ZMM14B is the 2nd 64-bit chunk of ZMM14.
  | ZMM14B = 0x14B
  /// ZMM14C is the 3rd 64-bit chunk of ZMM14.
  | ZMM14C = 0x14C
  /// ZMM14D is the 4th 64-bit chunk of ZMM14.
  | ZMM14D = 0x14D
  /// ZMM14E is the 5th 64-bit chunk of ZMM14.
  | ZMM14E = 0x14E
  /// ZMM14F is the 6th 64-bit chunk of ZMM14.
  | ZMM14F = 0x14F
  /// ZMM14G is the 7th 64-bit chunk of ZMM14.
  | ZMM14G = 0x150
  /// ZMM14H is the 8th 64-bit chunk of ZMM14.
  | ZMM14H = 0x151
  /// ZMM15A is the 1st 64-bit chunk of ZMM15.
  | ZMM15A = 0x152
  /// ZMM15B is the 2nd 64-bit chunk of ZMM15.
  | ZMM15B = 0x153
  /// ZMM15C is the 3rd 64-bit chunk of ZMM15.
  | ZMM15C = 0x154
  /// ZMM15D is the 4th 64-bit chunk of ZMM15.
  | ZMM15D = 0x155
  /// ZMM15E is the 5th 64-bit chunk of ZMM15.
  | ZMM15E = 0x156
  /// ZMM15F is the 6th 64-bit chunk of ZMM15.
  | ZMM15F = 0x157
  /// ZMM15G is the 7th 64-bit chunk of ZMM15.
  | ZMM15G = 0x158
  /// ZMM15H is the 8th 64-bit chunk of ZMM15.
  | ZMM15H = 0x159
  /// Opmask registers. For EVEX.
  | K0 = 0x15A
  /// Opmask registers. For EVEX.
  | K1 = 0x15B
  /// Opmask registers. For EVEX.
  | K2 = 0x15C
  /// Opmask registers. For EVEX.
  | K3 = 0x15D
  /// Opmask registers. For EVEX.
  | K4 = 0x15E
  /// Opmask registers. For EVEX.
  | K5 = 0x15F
  /// Opmask registers. For EVEX.
  | K6 = 0x160
  /// Opmask registers. For EVEX.
  | K7 = 0x161
  /// Unknown Register.
  | UnknownReg = 0x162

/// Shortcut for Register type.
type internal R = Register

/// This module exposes several useful functions to handle Intel registers.
[<RequireQualifiedAccess>]
module Register = begin
  /// Intel register kind, which is based on their usage.
  type Kind =
    /// General purpose registers.
    | GP = 0x0
    /// Floating-point registers.
    | FPU = 0x1
    /// MMX registers.
    | MMX = 0x2
    /// XMM registers.
    | XMM = 0x3
    /// YMM registers.
    | YMM = 0x4
    /// ZMM registers.
    | ZMM = 0x5
    /// Segment registers.
    | Segment = 0x6
    /// Registers represeting a segment base.
    | SegBase = 0x7
    /// Control registers.
    | Control = 0x8
    /// Debug registers.
    | Debug = 0x9
    /// Bound registers.
    | Bound = 0xA
    /// Flags registers.
    | Flags = 0xB
    /// Unclassified registers.
    | Unclassified = 0xC
    /// PseudoRegisters are the ones that we create to ease handling AVX
    /// registers and operations. Each AVX register is divided into a series of
    /// 64-bit pseudoregisters, and we name each pseudoregister using a suffix
    /// character from 'A' to 'H'. For example, XMM0A refers to the first 64-bit
    /// chunk of XMM0.
    | PseudoRegister = 0xD
    /// OpMask registers of EVEX.
    | OpMaskRegister = 0xE

  let getKind (reg: Register): Kind =
    let regNum = int reg
    if regNum <= 0x45 then Kind.GP
    elif regNum <= 0x64 then Kind.FPU
    elif regNum <= 0x6c then Kind.MMX
    elif regNum <= 0x7c then Kind.XMM
    elif regNum <= 0x8c then Kind.YMM
    elif regNum <= 0x9c then Kind.ZMM
    elif regNum <= 0xa2 then Kind.Segment
    elif regNum <= 0xa8 then Kind.SegBase
    elif regNum <= 0xad then Kind.Control
    elif regNum <= 0xb3 then Kind.Debug
    elif regNum <= 0xb7 then Kind.Bound
    elif regNum <= 0xc0 then Kind.Flags
    elif regNum <= 0xc1 then Kind.Unclassified
    elif regNum <= 0x159 then Kind.PseudoRegister
    elif regNum <= 0x161 then Kind.OpMaskRegister
    else Kind.Unclassified

  /// Get the ST(n) register from the given index.
  let streg n =
    0x46 + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the MM(n) register from the given index.
  let mm n =
    0x65 + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the XMM(n) register from the given index.
  let xmm n =
    0x6d + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the YMM(n) register from the given index.
  let ymm n =
    0x7d + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the ZMM(n) register from the given index.
  let zmm n =
    0x8d + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the segment register of the given index.
  let seg n =
    0x9d + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the bound register of the given index.
  let bound n =
    0xb4 + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the control register of the given index.
  let control n =
    0xa9 + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the debug register of the given index.
  let debug n =
    0xae + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  /// Get the OpMask register of the given index.
  let opmask n =
    0x15A + n
    |> LanguagePrimitives.EnumOfValue<int, Register>

  let inline ofRegID (n: RegisterID): Register =
    int n |> LanguagePrimitives.EnumOfValue

  let inline toRegID (reg: Register) =
    LanguagePrimitives.EnumToValue (reg) |> RegisterID.create

  let ofString (str: string) =
    match str.ToLower () with
    | "rax" -> R.RAX
    | "rbx" -> R.RBX
    | "rcx" -> R.RCX
    | "rdx" -> R.RDX
    | "rsp" -> R.RSP
    | "rbp" -> R.RBP
    | "rsi" -> R.RSI
    | "rdi" -> R.RDI
    | "eax" -> R.EAX
    | "ebx" -> R.EBX
    | "ecx" -> R.ECX
    | "edx" -> R.EDX
    | "esp" -> R.ESP
    | "ebp" -> R.EBP
    | "esi" -> R.ESI
    | "edi" -> R.EDI
    | "ax" -> R.AX
    | "bx" -> R.BX
    | "cx" -> R.CX
    | "dx" -> R.DX
    | "sp" -> R.SP
    | "bp" -> R.BP
    | "si" -> R.SI
    | "di" -> R.DI
    | "al" -> R.AL
    | "bl" -> R.BL
    | "cl" -> R.CL
    | "dl" -> R.DL
    | "ah" -> R.AH
    | "bh" -> R.BH
    | "ch" -> R.CH
    | "dh" -> R.DH
    | "r8" -> R.R8
    | "r9" -> R.R9
    | "r10" -> R.R10
    | "r11" -> R.R11
    | "r12" -> R.R12
    | "r13" -> R.R13
    | "r14" -> R.R14
    | "r15" -> R.R15
    | "r8d" -> R.R8D
    | "r9d" -> R.R9D
    | "r10d" -> R.R10D
    | "r11d" -> R.R11D
    | "r12d" -> R.R12D
    | "r13d" -> R.R13D
    | "r14d" -> R.R14D
    | "r15d" -> R.R15D
    | "r8w" -> R.R8W
    | "r9w" -> R.R9W
    | "r10w" -> R.R10W
    | "r11w" -> R.R11W
    | "r12w" -> R.R12W
    | "r13w" -> R.R13W
    | "r14w" -> R.R14W
    | "r15w" -> R.R15W
    | "r8l" -> R.R8L
    | "r9l" -> R.R9L
    | "r10l" -> R.R10L
    | "r11l" -> R.R11L
    | "r12l" -> R.R12L
    | "r13l" -> R.R13L
    | "r14l" -> R.R14L
    | "r15l" -> R.R15L
    | "spl" -> R.SPL
    | "bpl" -> R.BPL
    | "sil" -> R.SIL
    | "dil" -> R.DIL
    | "eip" -> R.EIP
    | "rip" -> R.RIP
    | "st0" -> R.ST0
    | "st1" -> R.ST1
    | "st2" -> R.ST2
    | "st3" -> R.ST3
    | "st4" -> R.ST4
    | "st5" -> R.ST5
    | "st6" -> R.ST6
    | "st7" -> R.ST7
    | "mm0" -> R.MM0
    | "mm1" -> R.MM1
    | "mm2" -> R.MM2
    | "mm3" -> R.MM3
    | "mm4" -> R.MM4
    | "mm5" -> R.MM5
    | "mm6" -> R.MM6
    | "mm7" -> R.MM7
    | "xmm0" -> R.XMM0
    | "xmm1" -> R.XMM1
    | "xmm2" -> R.XMM2
    | "xmm3" -> R.XMM3
    | "xmm4" -> R.XMM4
    | "xmm5" -> R.XMM5
    | "xmm6" -> R.XMM6
    | "xmm7" -> R.XMM7
    | "xmm8" -> R.XMM8
    | "xmm9" -> R.XMM9
    | "xmm10" -> R.XMM10
    | "xmm11" -> R.XMM11
    | "xmm12" -> R.XMM12
    | "xmm13" -> R.XMM13
    | "xmm14" -> R.XMM14
    | "xmm15" -> R.XMM15
    | "ymm0" -> R.YMM0
    | "ymm1" -> R.YMM1
    | "ymm2" -> R.YMM2
    | "ymm3" -> R.YMM3
    | "ymm4" -> R.YMM4
    | "ymm5" -> R.YMM5
    | "ymm6" -> R.YMM6
    | "ymm7" -> R.YMM7
    | "ymm8" -> R.YMM8
    | "ymm9" -> R.YMM9
    | "ymm10" -> R.YMM10
    | "ymm11" -> R.YMM11
    | "ymm12" -> R.YMM12
    | "ymm13" -> R.YMM13
    | "ymm14" -> R.YMM14
    | "ymm15" -> R.YMM15
    | "zmm0" -> R.ZMM0
    | "zmm1" -> R.ZMM1
    | "zmm2" -> R.ZMM2
    | "zmm3" -> R.ZMM3
    | "zmm4" -> R.ZMM4
    | "zmm5" -> R.ZMM5
    | "zmm6" -> R.ZMM6
    | "zmm7" -> R.ZMM7
    | "zmm8" -> R.ZMM8
    | "zmm9" -> R.ZMM9
    | "zmm10" -> R.ZMM10
    | "zmm11" -> R.ZMM11
    | "zmm12" -> R.ZMM12
    | "zmm13" -> R.ZMM13
    | "zmm14" -> R.ZMM14
    | "zmm15" -> R.ZMM15
    | "es" -> R.ES
    | "cs" -> R.CS
    | "ss" -> R.SS
    | "ds" -> R.DS
    | "fs" -> R.FS
    | "gs" -> R.GS
    | "esbASE" -> R.ESBase
    | "csbASE" -> R.CSBase
    | "ssbASE" -> R.SSBase
    | "dsbASE" -> R.DSBase
    | "fsbASE" -> R.FSBase
    | "gsbASE" -> R.GSBase
    | "cr0" -> R.CR0
    | "cr2" -> R.CR2
    | "cr3" -> R.CR3
    | "cr4" -> R.CR4
    | "cr8" -> R.CR8
    | "dr0" -> R.DR0
    | "dr1" -> R.DR1
    | "dr2" -> R.DR2
    | "dr3" -> R.DR3
    | "dr6" -> R.DR6
    | "dr7" -> R.DR7
    | "bnd0" -> R.BND0
    | "bnd1" -> R.BND1
    | "bnd2" -> R.BND2
    | "bnd3" -> R.BND3
    | "of" -> R.OF
    | "df" -> R.DF
    | "if" -> R.IF
    | "tf" -> R.TF
    | "sf" -> R.SF
    | "zf" -> R.ZF
    | "af" -> R.AF
    | "pf" -> R.PF
    | "cf" -> R.CF
    | "fcw" -> R.FCW
    | "fsw" -> R.FSW
    | "ftw" -> R.FTW
    | "fop" -> R.FOP
    | "fip" -> R.FIP
    | "fcs" -> R.FCS
    | "fdp" -> R.FDP
    | "fds" -> R.FDS
    | "ftop" -> R.FTOP
    | "ftw0" -> R.FTW0
    | "ftw1" -> R.FTW1
    | "ftw2" -> R.FTW2
    | "ftw3" -> R.FTW3
    | "ftw4" -> R.FTW4
    | "ftw5" -> R.FTW5
    | "ftw6" -> R.FTW6
    | "ftw7" -> R.FTW7
    | "fswc0" -> R.FSWC0
    | "fswc1" -> R.FSWC1
    | "fswc2" -> R.FSWC2
    | "fswc3" -> R.FSWC3
    | "mxcsr" -> R.MXCSR
    | "mxcsrmask" -> R.MXCSRMASK
    | "pkru" -> R.PKRU
    | "bnd0a" -> R.BND0A
    | "bnd0b" -> R.BND0B
    | "bnd1a" -> R.BND1A
    | "bnd1b" -> R.BND1B
    | "bnd2a" -> R.BND2A
    | "bnd2b" -> R.BND2B
    | "bnd3a" -> R.BND3A
    | "bnd3b" -> R.BND3B
    | "st0a" -> R.ST0A
    | "st0b" -> R.ST0B
    | "st1a" -> R.ST1A
    | "st1b" -> R.ST1B
    | "st2a" -> R.ST2A
    | "st2b" -> R.ST2B
    | "st3a" -> R.ST3A
    | "st3b" -> R.ST3B
    | "st4a" -> R.ST4A
    | "st4b" -> R.ST4B
    | "st5a" -> R.ST5A
    | "st5b" -> R.ST5B
    | "st6a" -> R.ST6A
    | "st6b" -> R.ST6B
    | "st7a" -> R.ST7A
    | "st7b" -> R.ST7B
    | "zmm0a" -> R.ZMM0A
    | "zmm0b" -> R.ZMM0B
    | "zmm0c" -> R.ZMM0C
    | "zmm0d" -> R.ZMM0D
    | "zmm0e" -> R.ZMM0E
    | "zmm0f" -> R.ZMM0F
    | "zmm0g" -> R.ZMM0G
    | "zmm0h" -> R.ZMM0H
    | "zmm1a" -> R.ZMM1A
    | "zmm1b" -> R.ZMM1B
    | "zmm1c" -> R.ZMM1C
    | "zmm1d" -> R.ZMM1D
    | "zmm1e" -> R.ZMM1E
    | "zmm1f" -> R.ZMM1F
    | "zmm1g" -> R.ZMM1G
    | "zmm1h" -> R.ZMM1H
    | "zmm2a" -> R.ZMM2A
    | "zmm2b" -> R.ZMM2B
    | "zmm2c" -> R.ZMM2C
    | "zmm2d" -> R.ZMM2D
    | "zmm2e" -> R.ZMM2E
    | "zmm2f" -> R.ZMM2F
    | "zmm2g" -> R.ZMM2G
    | "zmm2h" -> R.ZMM2H
    | "zmm3a" -> R.ZMM3A
    | "zmm3b" -> R.ZMM3B
    | "zmm3c" -> R.ZMM3C
    | "zmm3d" -> R.ZMM3D
    | "zmm3e" -> R.ZMM3E
    | "zmm3f" -> R.ZMM3F
    | "zmm3g" -> R.ZMM3G
    | "zmm3h" -> R.ZMM3H
    | "zmm4a" -> R.ZMM4A
    | "zmm4b" -> R.ZMM4B
    | "zmm4c" -> R.ZMM4C
    | "zmm4d" -> R.ZMM4D
    | "zmm4e" -> R.ZMM4E
    | "zmm4f" -> R.ZMM4F
    | "zmm4g" -> R.ZMM4G
    | "zmm4h" -> R.ZMM4H
    | "zmm5a" -> R.ZMM5A
    | "zmm5b" -> R.ZMM5B
    | "zmm5c" -> R.ZMM5C
    | "zmm5d" -> R.ZMM5D
    | "zmm5e" -> R.ZMM5E
    | "zmm5f" -> R.ZMM5F
    | "zmm5g" -> R.ZMM5G
    | "zmm5h" -> R.ZMM5H
    | "zmm6a" -> R.ZMM6A
    | "zmm6b" -> R.ZMM6B
    | "zmm6c" -> R.ZMM6C
    | "zmm6d" -> R.ZMM6D
    | "zmm6e" -> R.ZMM6E
    | "zmm6f" -> R.ZMM6F
    | "zmm6g" -> R.ZMM6G
    | "zmm6h" -> R.ZMM6H
    | "zmm7a" -> R.ZMM7A
    | "zmm7b" -> R.ZMM7B
    | "zmm7c" -> R.ZMM7C
    | "zmm7d" -> R.ZMM7D
    | "zmm7e" -> R.ZMM7E
    | "zmm7f" -> R.ZMM7F
    | "zmm7g" -> R.ZMM7G
    | "zmm7h" -> R.ZMM7H
    | "zmm8a" -> R.ZMM8A
    | "zmm8b" -> R.ZMM8B
    | "zmm8c" -> R.ZMM8C
    | "zmm8d" -> R.ZMM8D
    | "zmm8e" -> R.ZMM8E
    | "zmm8f" -> R.ZMM8F
    | "zmm8g" -> R.ZMM8G
    | "zmm8h" -> R.ZMM8H
    | "zmm9a" -> R.ZMM9A
    | "zmm9b" -> R.ZMM9B
    | "zmm9c" -> R.ZMM9C
    | "zmm9d" -> R.ZMM9D
    | "zmm9e" -> R.ZMM9E
    | "zmm9f" -> R.ZMM9F
    | "zmm9g" -> R.ZMM9G
    | "zmm9h" -> R.ZMM9H
    | "zmm10a" -> R.ZMM10A
    | "zmm10b" -> R.ZMM10B
    | "zmm10c" -> R.ZMM10C
    | "zmm10d" -> R.ZMM10D
    | "zmm10e" -> R.ZMM10E
    | "zmm10f" -> R.ZMM10F
    | "zmm10g" -> R.ZMM10G
    | "zmm10h" -> R.ZMM10H
    | "zmm11a" -> R.ZMM11A
    | "zmm11b" -> R.ZMM11B
    | "zmm11c" -> R.ZMM11C
    | "zmm11d" -> R.ZMM11D
    | "zmm11e" -> R.ZMM11E
    | "zmm11f" -> R.ZMM11F
    | "zmm11g" -> R.ZMM11G
    | "zmm11h" -> R.ZMM11H
    | "zmm12a" -> R.ZMM12A
    | "zmm12b" -> R.ZMM12B
    | "zmm12c" -> R.ZMM12C
    | "zmm12d" -> R.ZMM12D
    | "zmm12e" -> R.ZMM12E
    | "zmm12f" -> R.ZMM12F
    | "zmm12g" -> R.ZMM12G
    | "zmm12h" -> R.ZMM12H
    | "zmm13a" -> R.ZMM13A
    | "zmm13b" -> R.ZMM13B
    | "zmm13c" -> R.ZMM13C
    | "zmm13d" -> R.ZMM13D
    | "zmm13e" -> R.ZMM13E
    | "zmm13f" -> R.ZMM13F
    | "zmm13g" -> R.ZMM13G
    | "zmm13h" -> R.ZMM13H
    | "zmm14a" -> R.ZMM14A
    | "zmm14b" -> R.ZMM14B
    | "zmm14c" -> R.ZMM14C
    | "zmm14d" -> R.ZMM14D
    | "zmm14e" -> R.ZMM14E
    | "zmm14f" -> R.ZMM14F
    | "zmm14g" -> R.ZMM14G
    | "zmm14h" -> R.ZMM14H
    | "zmm15a" -> R.ZMM15A
    | "zmm15b" -> R.ZMM15B
    | "zmm15c" -> R.ZMM15C
    | "zmm15d" -> R.ZMM15D
    | "zmm15e" -> R.ZMM15E
    | "zmm15f" -> R.ZMM15F
    | "zmm15g" -> R.ZMM15G
    | "zmm15h" -> R.ZMM15H
    | "k0" -> R.K0
    | "k1" -> R.K1
    | "k2" -> R.K2
    | "k3" -> R.K3
    | "k4" -> R.K4
    | "k5" -> R.K5
    | "k6" -> R.K6
    | "k7" -> R.K7
    | _ -> Utils.impossible ()

  let toString = function
    | R.RAX -> "RAX"
    | R.RBX -> "RBX"
    | R.RCX -> "RCX"
    | R.RDX -> "RDX"
    | R.RSP -> "RSP"
    | R.RBP -> "RBP"
    | R.RSI -> "RSI"
    | R.RDI -> "RDI"
    | R.EAX -> "EAX"
    | R.EBX -> "EBX"
    | R.ECX -> "ECX"
    | R.EDX -> "EDX"
    | R.ESP -> "ESP"
    | R.EBP -> "EBP"
    | R.ESI -> "ESI"
    | R.EDI -> "EDI"
    | R.AX -> "AX"
    | R.BX -> "BX"
    | R.CX -> "CX"
    | R.DX -> "DX"
    | R.SP -> "SP"
    | R.BP -> "BP"
    | R.SI -> "SI"
    | R.DI -> "DI"
    | R.AL -> "AL"
    | R.BL -> "BL"
    | R.CL -> "CL"
    | R.DL -> "DL"
    | R.AH -> "AH"
    | R.BH -> "BH"
    | R.CH -> "CH"
    | R.DH -> "DH"
    | R.R8 -> "R8"
    | R.R9 -> "R9"
    | R.R10 -> "R10"
    | R.R11 -> "R11"
    | R.R12 -> "R12"
    | R.R13 -> "R13"
    | R.R14 -> "R14"
    | R.R15 -> "R15"
    | R.R8D -> "R8D"
    | R.R9D -> "R9D"
    | R.R10D -> "R10D"
    | R.R11D -> "R11D"
    | R.R12D -> "R12D"
    | R.R13D -> "R13D"
    | R.R14D -> "R14D"
    | R.R15D -> "R15D"
    | R.R8W -> "R8W"
    | R.R9W -> "R9W"
    | R.R10W -> "R10W"
    | R.R11W -> "R11W"
    | R.R12W -> "R12W"
    | R.R13W -> "R13W"
    | R.R14W -> "R14W"
    | R.R15W -> "R15W"
    | R.R8L -> "R8L"
    | R.R9L -> "R9L"
    | R.R10L -> "R10L"
    | R.R11L -> "R11L"
    | R.R12L -> "R12L"
    | R.R13L -> "R13L"
    | R.R14L -> "R14L"
    | R.R15L -> "R15L"
    | R.SPL -> "SPL"
    | R.BPL -> "BPL"
    | R.SIL -> "SIL"
    | R.DIL -> "DIL"
    | R.EIP -> "EIP"
    | R.RIP -> "RIP"
    | R.ST0 -> "ST0"
    | R.ST1 -> "ST1"
    | R.ST2 -> "ST2"
    | R.ST3 -> "ST3"
    | R.ST4 -> "ST4"
    | R.ST5 -> "ST5"
    | R.ST6 -> "ST6"
    | R.ST7 -> "ST7"
    | R.FCW -> "FCW"
    | R.FSW -> "FSW"
    | R.FTW -> "FTW"
    | R.FOP -> "FOP"
    | R.FIP -> "FIP"
    | R.FCS -> "FCS"
    | R.FDP -> "FDP"
    | R.FDS -> "FDS"
    | R.FTOP -> "FTOP"
    | R.FTW0 -> "FTW0"
    | R.FTW1 -> "FTW1"
    | R.FTW2 -> "FTW2"
    | R.FTW3 -> "FTW3"
    | R.FTW4 -> "FTW4"
    | R.FTW5 -> "FTW5"
    | R.FTW6 -> "FTW6"
    | R.FTW7 -> "FTW7"
    | R.FSWC0 -> "FSWC0"
    | R.FSWC1 -> "FSWC1"
    | R.FSWC2 -> "FSWC2"
    | R.FSWC3 -> "FSWC3"
    | R.MXCSR -> "MXCSR"
    | R.MXCSRMASK -> "MXCSRMASK"
    | R.MM0 -> "MM0"
    | R.MM1 -> "MM1"
    | R.MM2 -> "MM2"
    | R.MM3 -> "MM3"
    | R.MM4 -> "MM4"
    | R.MM5 -> "MM5"
    | R.MM6 -> "MM6"
    | R.MM7 -> "MM7"
    | R.XMM0 -> "XMM0"
    | R.XMM1 -> "XMM1"
    | R.XMM2 -> "XMM2"
    | R.XMM3 -> "XMM3"
    | R.XMM4 -> "XMM4"
    | R.XMM5 -> "XMM5"
    | R.XMM6 -> "XMM6"
    | R.XMM7 -> "XMM7"
    | R.XMM8 -> "XMM8"
    | R.XMM9 -> "XMM9"
    | R.XMM10 -> "XMM10"
    | R.XMM11 -> "XMM11"
    | R.XMM12 -> "XMM12"
    | R.XMM13 -> "XMM13"
    | R.XMM14 -> "XMM14"
    | R.XMM15 -> "XMM15"
    | R.YMM0 -> "YMM0"
    | R.YMM1 -> "YMM1"
    | R.YMM2 -> "YMM2"
    | R.YMM3 -> "YMM3"
    | R.YMM4 -> "YMM4"
    | R.YMM5 -> "YMM5"
    | R.YMM6 -> "YMM6"
    | R.YMM7 -> "YMM7"
    | R.YMM8 -> "YMM8"
    | R.YMM9 -> "YMM9"
    | R.YMM10 -> "YMM10"
    | R.YMM11 -> "YMM11"
    | R.YMM12 -> "YMM12"
    | R.YMM13 -> "YMM13"
    | R.YMM14 -> "YMM14"
    | R.YMM15 -> "YMM15"
    | R.ZMM0 -> "ZMM0"
    | R.ZMM1 -> "ZMM1"
    | R.ZMM2 -> "ZMM2"
    | R.ZMM3 -> "ZMM3"
    | R.ZMM4 -> "ZMM4"
    | R.ZMM5 -> "ZMM5"
    | R.ZMM6 -> "ZMM6"
    | R.ZMM7 -> "ZMM7"
    | R.ZMM8 -> "ZMM8"
    | R.ZMM9 -> "ZMM9"
    | R.ZMM10 -> "ZMM10"
    | R.ZMM11 -> "ZMM11"
    | R.ZMM12 -> "ZMM12"
    | R.ZMM13 -> "ZMM13"
    | R.ZMM14 -> "ZMM14"
    | R.ZMM15 -> "ZMM15"
    | R.CS -> "CS"
    | R.DS -> "DS"
    | R.SS -> "SS"
    | R.ES -> "ES"
    | R.FS -> "FS"
    | R.GS -> "GS"
    | R.CSBase -> "CSBase"
    | R.DSBase -> "DSBase"
    | R.ESBase -> "ESBase"
    | R.FSBase -> "FSBase"
    | R.GSBase -> "GSBase"
    | R.SSBase -> "SSBase"
    | R.CR0 -> "CR0"
    | R.CR2 -> "CR2"
    | R.CR3 -> "CR3"
    | R.CR4 -> "CR4"
    | R.CR8 -> "CR8"
    | R.DR0 -> "DR0"
    | R.DR1 -> "DR1"
    | R.DR2 -> "DR2"
    | R.DR3 -> "DR3"
    | R.DR6 -> "DR6"
    | R.DR7 -> "DR7"
    | R.BND0 -> "BND0"
    | R.BND1 -> "BND1"
    | R.BND2 -> "BND2"
    | R.BND3 -> "BND3"
    | R.OF -> "OF"
    | R.DF -> "DF"
    | R.IF -> "IF"
    | R.TF -> "TF"
    | R.SF -> "SF"
    | R.ZF -> "ZF"
    | R.AF -> "AF"
    | R.PF -> "PF"
    | R.CF -> "CF"
    | R.ST0A -> "ST0A"
    | R.ST0B -> "ST0B"
    | R.ST1A -> "ST1A"
    | R.ST1B -> "ST1B"
    | R.ST2A -> "ST2A"
    | R.ST2B -> "ST2B"
    | R.ST3A -> "ST3A"
    | R.ST3B -> "ST3B"
    | R.ST4A -> "ST4A"
    | R.ST4B -> "ST4B"
    | R.ST5A -> "ST5A"
    | R.ST5B -> "ST5B"
    | R.ST6A -> "ST6A"
    | R.ST6B -> "ST6B"
    | R.ST7A -> "ST7A"
    | R.ST7B -> "ST7B"
    | R.ZMM0A -> "ZMM0A"
    | R.ZMM0B -> "ZMM0B"
    | R.ZMM0C -> "ZMM0C"
    | R.ZMM0D -> "ZMM0D"
    | R.ZMM0E -> "ZMM0E"
    | R.ZMM0F -> "ZMM0F"
    | R.ZMM0G -> "ZMM0G"
    | R.ZMM0H -> "ZMM0H"
    | R.ZMM1A -> "ZMM1A"
    | R.ZMM1B -> "ZMM1B"
    | R.ZMM1C -> "ZMM1C"
    | R.ZMM1D -> "ZMM1D"
    | R.ZMM1E -> "ZMM1E"
    | R.ZMM1F -> "ZMM1F"
    | R.ZMM1G -> "ZMM1G"
    | R.ZMM1H -> "ZMM1H"
    | R.ZMM2A -> "ZMM2A"
    | R.ZMM2B -> "ZMM2B"
    | R.ZMM2C -> "ZMM2C"
    | R.ZMM2D -> "ZMM2D"
    | R.ZMM2E -> "ZMM2E"
    | R.ZMM2F -> "ZMM2F"
    | R.ZMM2G -> "ZMM2G"
    | R.ZMM2H -> "ZMM2H"
    | R.ZMM3A -> "ZMM3A"
    | R.ZMM3B -> "ZMM3B"
    | R.ZMM3C -> "ZMM3C"
    | R.ZMM3D -> "ZMM3D"
    | R.ZMM3E -> "ZMM3E"
    | R.ZMM3F -> "ZMM3F"
    | R.ZMM3G -> "ZMM3G"
    | R.ZMM3H -> "ZMM3H"
    | R.ZMM4A -> "ZMM4A"
    | R.ZMM4B -> "ZMM4B"
    | R.ZMM4C -> "ZMM4C"
    | R.ZMM4D -> "ZMM4D"
    | R.ZMM4E -> "ZMM4E"
    | R.ZMM4F -> "ZMM4F"
    | R.ZMM4G -> "ZMM4G"
    | R.ZMM4H -> "ZMM4H"
    | R.ZMM5A -> "ZMM5A"
    | R.ZMM5B -> "ZMM5B"
    | R.ZMM5C -> "ZMM5C"
    | R.ZMM5D -> "ZMM5D"
    | R.ZMM5E -> "ZMM5E"
    | R.ZMM5F -> "ZMM5F"
    | R.ZMM5G -> "ZMM5G"
    | R.ZMM5H -> "ZMM5H"
    | R.ZMM6A -> "ZMM6A"
    | R.ZMM6B -> "ZMM6B"
    | R.ZMM6C -> "ZMM6C"
    | R.ZMM6D -> "ZMM6D"
    | R.ZMM6E -> "ZMM6E"
    | R.ZMM6F -> "ZMM6F"
    | R.ZMM6G -> "ZMM6G"
    | R.ZMM6H -> "ZMM6H"
    | R.ZMM7A -> "ZMM7A"
    | R.ZMM7B -> "ZMM7B"
    | R.ZMM7C -> "ZMM7C"
    | R.ZMM7D -> "ZMM7D"
    | R.ZMM7E -> "ZMM7E"
    | R.ZMM7F -> "ZMM7F"
    | R.ZMM7G -> "ZMM7G"
    | R.ZMM7H -> "ZMM7H"
    | R.ZMM8A -> "ZMM8A"
    | R.ZMM8B -> "ZMM8B"
    | R.ZMM8C -> "ZMM8C"
    | R.ZMM8D -> "ZMM8D"
    | R.ZMM8E -> "ZMM8E"
    | R.ZMM8F -> "ZMM8F"
    | R.ZMM8G -> "ZMM8G"
    | R.ZMM8H -> "ZMM8H"
    | R.ZMM9A -> "ZMM9A"
    | R.ZMM9B -> "ZMM9B"
    | R.ZMM9C -> "ZMM9C"
    | R.ZMM9D -> "ZMM9D"
    | R.ZMM9E -> "ZMM9E"
    | R.ZMM9F -> "ZMM9F"
    | R.ZMM9G -> "ZMM9G"
    | R.ZMM9H -> "ZMM9H"
    | R.ZMM10A -> "ZMM10A"
    | R.ZMM10B -> "ZMM10B"
    | R.ZMM10C -> "ZMM10C"
    | R.ZMM10D -> "ZMM10D"
    | R.ZMM10E -> "ZMM10E"
    | R.ZMM10F -> "ZMM10F"
    | R.ZMM10G -> "ZMM10G"
    | R.ZMM10H -> "ZMM10H"
    | R.ZMM11A -> "ZMM11A"
    | R.ZMM11B -> "ZMM11B"
    | R.ZMM11C -> "ZMM11C"
    | R.ZMM11D -> "ZMM11D"
    | R.ZMM11E -> "ZMM11E"
    | R.ZMM11F -> "ZMM11F"
    | R.ZMM11G -> "ZMM11G"
    | R.ZMM11H -> "ZMM11H"
    | R.ZMM12A -> "ZMM12A"
    | R.ZMM12B -> "ZMM12B"
    | R.ZMM12C -> "ZMM12C"
    | R.ZMM12D -> "ZMM12D"
    | R.ZMM12E -> "ZMM12E"
    | R.ZMM12F -> "ZMM12F"
    | R.ZMM12G -> "ZMM12G"
    | R.ZMM12H -> "ZMM12H"
    | R.ZMM13A -> "ZMM13A"
    | R.ZMM13B -> "ZMM13B"
    | R.ZMM13C -> "ZMM13C"
    | R.ZMM13D -> "ZMM13D"
    | R.ZMM13E -> "ZMM13E"
    | R.ZMM13F -> "ZMM13F"
    | R.ZMM13G -> "ZMM13G"
    | R.ZMM13H -> "ZMM13H"
    | R.ZMM14A -> "ZMM14A"
    | R.ZMM14B -> "ZMM14B"
    | R.ZMM14C -> "ZMM14C"
    | R.ZMM14D -> "ZMM14D"
    | R.ZMM14E -> "ZMM14E"
    | R.ZMM14F -> "ZMM14F"
    | R.ZMM14G -> "ZMM14G"
    | R.ZMM14H -> "ZMM14H"
    | R.ZMM15A -> "ZMM15A"
    | R.ZMM15B -> "ZMM15B"
    | R.ZMM15C -> "ZMM15C"
    | R.ZMM15D -> "ZMM15D"
    | R.ZMM15E -> "ZMM15E"
    | R.ZMM15F -> "ZMM15F"
    | R.ZMM15G -> "ZMM15G"
    | R.ZMM15H -> "ZMM15H"
    | R.K0 -> "K0"
    | R.K1 -> "K1"
    | R.K2 -> "K2"
    | R.K3 -> "K3"
    | R.K4 -> "K4"
    | R.K5 -> "K5"
    | R.K6 -> "K6"
    | R.K7 -> "K7"
    | R.PKRU -> "PKRU"
#if DEBUG
    | _ -> Utils.impossible ()
#else
    | _ -> "?"
#endif

  let toRegType = function
    | R.MM0 | R.MM1 | R.MM2 | R.MM3 | R.MM4 | R.MM5 | R.MM6 | R.MM7
    | R.ST0A | R.ST1A | R.ST2A | R.ST3A | R.ST4A | R.ST5A | R.ST6A | R.ST7A
    | R.RIP | R.R8 | R.R9 | R.R10 | R.R11 | R.R12 | R.R13 | R.R14 | R.R15
    | R.RAX | R.RBX | R.RCX | R.RDX | R.RSP | R.RBP | R.RSI | R.RDI
    | R.ZMM0A | R.ZMM1A | R.ZMM2A | R.ZMM3A
    | R.ZMM4A | R.ZMM5A | R.ZMM6A | R.ZMM7A
    | R.ZMM8A | R.ZMM9A | R.ZMM10A | R.ZMM11A
    | R.ZMM12A | R.ZMM13A | R.ZMM14A | R.ZMM15A
    | R.ZMM0B | R.ZMM1B | R.ZMM2B | R.ZMM3B
    | R.ZMM4B | R.ZMM5B | R.ZMM6B | R.ZMM7B
    | R.ZMM8B | R.ZMM9B | R.ZMM10B | R.ZMM11B
    | R.ZMM12B | R.ZMM13B | R.ZMM14B | R.ZMM15B
    | R.ZMM0C | R.ZMM1C | R.ZMM2C | R.ZMM3C
    | R.ZMM4C | R.ZMM5C | R.ZMM6C | R.ZMM7C
    | R.ZMM8C | R.ZMM9C | R.ZMM10C | R.ZMM11C
    | R.ZMM12C | R.ZMM13C | R.ZMM14C | R.ZMM15C
    | R.ZMM0D | R.ZMM1D | R.ZMM2D | R.ZMM3D
    | R.ZMM4D | R.ZMM5D | R.ZMM6D | R.ZMM7D
    | R.ZMM8D | R.ZMM9D | R.ZMM10D | R.ZMM11D
    | R.ZMM12D | R.ZMM13D | R.ZMM14D | R.ZMM15D
    | R.ZMM0E | R.ZMM1E | R.ZMM2E | R.ZMM3E
    | R.ZMM4E | R.ZMM5E | R.ZMM6E | R.ZMM7E
    | R.ZMM8E | R.ZMM9E | R.ZMM10E | R.ZMM11E
    | R.ZMM12E | R.ZMM13E | R.ZMM14E | R.ZMM15E
    | R.ZMM0F | R.ZMM1F | R.ZMM2F | R.ZMM3F
    | R.ZMM4F | R.ZMM5F | R.ZMM6F | R.ZMM7F
    | R.ZMM8F | R.ZMM9F | R.ZMM10F | R.ZMM11F
    | R.ZMM12F | R.ZMM13F | R.ZMM14F | R.ZMM15F
    | R.ZMM0G | R.ZMM1G | R.ZMM2G | R.ZMM3G
    | R.ZMM4G | R.ZMM5G | R.ZMM6G | R.ZMM7G
    | R.ZMM8G | R.ZMM9G | R.ZMM10G | R.ZMM11G
    | R.ZMM12G | R.ZMM13G | R.ZMM14G | R.ZMM15G
    | R.ZMM0H | R.ZMM1H | R.ZMM2H | R.ZMM3H
    | R.ZMM4H | R.ZMM5H | R.ZMM6H | R.ZMM7H
    | R.ZMM8H | R.ZMM9H | R.ZMM10H | R.ZMM11H
    | R.ZMM12H | R.ZMM13H | R.ZMM14H | R.ZMM15H
    | R.FIP | R.FDP -> 64<rt>
    | R.R8D | R.R9D | R.R10D | R.R11D
    | R.R12D | R.R13D | R.R14D | R.R15D
    | R.EAX | R.EBX | R.ECX | R.EDX
    | R.ESP | R.EBP | R.ESI | R.EDI | R.EIP | R.PKRU
    | R.MXCSR | R.MXCSRMASK -> 32<rt>
    | R.R8W | R.R9W | R.R10W | R.R11W
    | R.R12W | R.R13W | R.R14W | R.R15W
    | R.ST0B | R.ST1B | R.ST2B | R.ST3B | R.ST4B | R.ST5B | R.ST6B | R.ST7B
    | R.ES | R.CS | R.SS | R.DS | R.FS | R.GS
    | R.AX | R.BX | R.CX | R.DX | R.SP | R.BP | R.SI | R.DI
    | R.FCW | R.FSW | R.FTW | R.FOP | R.FCS | R.FDS
    | R.K0 | R.K1 | R.K2 | R.K3 | R.K4 | R.K5 | R.K6 | R.K7 -> 16<rt>
    | R.R8L | R.R9L | R.R10L | R.R11L
    | R.R12L | R.R13L | R.R14L | R.R15L
    | R.SPL | R.BPL | R.SIL | R.DIL
    | R.AL | R.BL | R.CL | R.DL | R.AH | R.BH | R.CH | R.DH -> 8<rt>
    | R.XMM0 | R.XMM1 | R.XMM2 | R.XMM3
    | R.XMM4 | R.XMM5 | R.XMM6 | R.XMM7
    | R.XMM8 | R.XMM9 | R.XMM10 | R.XMM11
    | R.XMM12 | R.XMM13 | R.XMM14 | R.XMM15
    | R.BND0 | R.BND1 | R.BND2 | R.BND3 -> 128<rt>
    | R.YMM0 | R.YMM1 | R.YMM2 | R.YMM3
    | R.YMM4 | R.YMM5 | R.YMM6 | R.YMM7
    | R.YMM8 | R.YMM9 | R.YMM10 | R.YMM11
    | R.YMM12 | R.YMM13 | R.YMM14 | R.YMM15 -> 256<rt>
    | R.ZMM0 | R.ZMM1 | R.ZMM2 | R.ZMM3
    | R.ZMM4 | R.ZMM5 | R.ZMM6 | R.ZMM7
    | R.ZMM8 | R.ZMM9 | R.ZMM10 | R.ZMM11
    | R.ZMM12 | R.ZMM13 | R.ZMM14 | R.ZMM15 -> 512<rt>
    | R.ST0 | R.ST1 | R.ST2 | R.ST3 | R.ST4 | R.ST5 | R.ST6 | R.ST7 -> 80<rt>
    | R.DF | R.CF | R.PF | R.AF | R.ZF | R.SF | R.OF | R.IF
    | R.FSWC0 | R.FSWC1 | R.FSWC2 | R.FSWC3 -> 1<rt>
    | R.FTW0 | R.FTW1 | R.FTW2 | R.FTW3
    | R.FTW4 | R.FTW5 | R.FTW6 | R.FTW7
    | R.FTOP -> 8<rt>
    | _ -> raise UnknownRegException

  let extendRegister32 = function
    | R.EAX | R.AX | R.AL | R.AH -> R.EAX
    | R.EBX | R.BX | R.BL | R.BH -> R.EBX
    | R.ECX | R.CX | R.CL | R.CH -> R.ECX
    | R.EDX | R.DX | R.DL | R.DH -> R.EDX
    | R.ESP | R.SP | R.SPL -> R.ESP
    | R.EBP | R.BP | R.BPL -> R.EBP
    | R.ESI | R.SI | R.SIL -> R.ESI
    | R.EDI | R.DI | R.DIL -> R.EDI
    | R.XMM0 | R.YMM0 | R.ZMM0 -> R.YMM0
    | R.XMM1 | R.YMM1 | R.ZMM1 -> R.YMM1
    | R.XMM2 | R.YMM2 | R.ZMM2 -> R.YMM2
    | R.XMM3 | R.YMM3 | R.ZMM3 -> R.YMM3
    | R.XMM4 | R.YMM4 | R.ZMM4 -> R.YMM4
    | R.XMM5 | R.YMM5 | R.ZMM5 -> R.YMM5
    | R.XMM6 | R.YMM6 | R.ZMM6 -> R.YMM6
    | R.XMM7 | R.YMM7 | R.ZMM7 -> R.YMM7
    | R.DF | R.CF | R.PF | R.AF | R.ZF | R.SF | R.OF
    | R.BND0 | R.BND1 | R.BND2 | R.BND3 as e -> e
    | R.ESBase | R.ES -> R.ESBase
    | R.CSBase | R.CS -> R.CSBase
    | R.SSBase | R.SS -> R.SSBase
    | R.DSBase | R.DS -> R.DSBase
    | R.FSBase | R.FS -> R.FSBase
    | R.GSBase | R.GS -> R.GSBase
    | R.EIP -> R.EIP
    | e -> e

  let extendRegister64 = function
    | R.RAX | R.EAX | R.AX | R.AL | R.AH -> R.RAX
    | R.RBX | R.EBX | R.BX | R.BL | R.BH -> R.RBX
    | R.RCX | R.ECX | R.CX | R.CL | R.CH -> R.RCX
    | R.RDX | R.EDX | R.DX | R.DL | R.DH -> R.RDX
    | R.RSP | R.ESP | R.SP | R.SPL -> R.RSP
    | R.RBP | R.EBP | R.BP | R.BPL -> R.RBP
    | R.RSI | R.ESI | R.SI | R.SIL -> R.RSI
    | R.RDI | R.EDI | R.DI | R.DIL-> R.RDI
    | R.R8  | R.R8D | R.R8L | R.R8W -> R.R8
    | R.R9  | R.R9D | R.R9L | R.R9W -> R.R9
    | R.R10 | R.R10D | R.R10L | R.R10W -> R.R10
    | R.R11 | R.R11D | R.R11L | R.R11W -> R.R11
    | R.R12 | R.R12D | R.R12L | R.R12W -> R.R12
    | R.R13 | R.R13D | R.R13L | R.R13W -> R.R13
    | R.R14 | R.R14D | R.R14L | R.R14W -> R.R14
    | R.R15 | R.R15D | R.R15L | R.R15W -> R.R15
    | R.XMM0 | R.YMM0 | R.ZMM0 -> R.YMM0
    | R.XMM1 | R.YMM1 | R.ZMM1 -> R.YMM1
    | R.XMM2 | R.YMM2 | R.ZMM2 -> R.YMM2
    | R.XMM3 | R.YMM3 | R.ZMM3 -> R.YMM3
    | R.XMM4 | R.YMM4 | R.ZMM4 -> R.YMM4
    | R.XMM5 | R.YMM5 | R.ZMM5 -> R.YMM5
    | R.XMM6 | R.YMM6 | R.ZMM6 -> R.YMM6
    | R.XMM7 | R.YMM7 | R.ZMM7 -> R.YMM7
    | R.XMM8 | R.YMM8 | R.ZMM8 -> R.YMM8
    | R.XMM9 | R.YMM9 | R.ZMM9 -> R.YMM9
    | R.XMM10 | R.YMM10 | R.ZMM10 -> R.YMM10
    | R.XMM11 | R.YMM11 | R.ZMM11 -> R.YMM11
    | R.XMM12 | R.YMM12 | R.ZMM12 -> R.YMM12
    | R.XMM13 | R.YMM13 | R.ZMM13 -> R.YMM13
    | R.XMM14 | R.YMM14 | R.ZMM14 -> R.YMM14
    | R.XMM15 | R.YMM15 | R.ZMM15 -> R.YMM15
    | R.DF | R.CF | R.PF | R.AF | R.ZF | R.SF | R.OF
    | R.BND0 | R.BND1 | R.BND2 | R.BND3 as e -> e
    | R.ESBase | R.ES -> R.ESBase
    | R.CSBase | R.CS -> R.CSBase
    | R.SSBase | R.SS -> R.SSBase
    | R.DSBase | R.DS -> R.DSBase
    | R.FSBase | R.FS -> R.FSBase
    | R.GSBase | R.GS -> R.GSBase
    | R.RIP | R.EIP -> R.RIP
    | e -> e

  let getAliases = function
    | R.RAX | R.EAX | R.AX | R.AL | R.AH -> [| R.RAX; R.EAX; R.AX; R.AL; R.AH |]
    | R.RBX | R.EBX | R.BX | R.BL | R.BH -> [| R.RBX; R.EBX; R.BX; R.BL; R.BH |]
    | R.RCX | R.ECX | R.CX | R.CL | R.CH -> [| R.RCX; R.ECX; R.CX; R.CL; R.CH |]
    | R.RDX | R.EDX | R.DX | R.DL | R.DH -> [| R.RDX; R.EDX; R.DX; R.DL; R.DH |]
    | R.RSP | R.ESP | R.SP | R.SPL -> [| R.RSP; R.ESP; R.SP; R.SPL |]
    | R.RBP | R.EBP | R.BP | R.BPL -> [| R.RBP; R.EBP; R.BP; R.BPL |]
    | R.RSI | R.ESI | R.SI | R.SIL -> [| R.RSI; R.ESI; R.SI; R.SIL |]
    | R.RDI | R.EDI | R.DI | R.DIL -> [| R.RDI; R.EDI; R.DI; R.DIL |]
    | R.R8  | R.R8D | R.R8L | R.R8W -> [| R.R8; R.R8D; R.R8L; R.R8W |]
    | R.R9  | R.R9D | R.R9L | R.R9W -> [| R.R9; R.R9D; R.R9L; R.R9W |]
    | R.R10  | R.R10D | R.R10L | R.R10W -> [| R.R10; R.R10D; R.R10L; R.R10W |]
    | R.R11  | R.R11D | R.R11L | R.R11W -> [| R.R11; R.R11D; R.R11L; R.R11W |]
    | R.R12  | R.R12D | R.R12L | R.R12W -> [| R.R12; R.R12D; R.R12L; R.R12W |]
    | R.R13  | R.R13D | R.R13L | R.R13W -> [| R.R13; R.R13D; R.R13L; R.R13W |]
    | R.R14  | R.R14D | R.R14L | R.R14W -> [| R.R14; R.R14D; R.R14L; R.R14W |]
    | R.R15  | R.R15D | R.R15L | R.R15W -> [| R.R15; R.R15D; R.R15L; R.R15W |]
    | R.XMM0 | R.YMM0 | R.ZMM0 -> [| R.XMM0; R.YMM0; R.ZMM0 |]
    | R.XMM1 | R.YMM1 | R.ZMM1 -> [| R.XMM1; R.YMM1; R.ZMM1 |]
    | R.XMM2 | R.YMM2 | R.ZMM2 -> [| R.XMM2; R.YMM2; R.ZMM2 |]
    | R.XMM3 | R.YMM3 | R.ZMM3 -> [| R.XMM3; R.YMM3; R.ZMM3 |]
    | R.XMM4 | R.YMM4 | R.ZMM4 -> [| R.XMM4; R.YMM4; R.ZMM4 |]
    | R.XMM5 | R.YMM5 | R.ZMM5 -> [| R.XMM5; R.YMM5; R.ZMM5 |]
    | R.XMM6 | R.YMM6 | R.ZMM6 -> [| R.XMM6; R.YMM6; R.ZMM6 |]
    | R.XMM7 | R.YMM7 | R.ZMM7 -> [| R.XMM7; R.YMM7; R.ZMM7 |]
    | R.XMM8 | R.YMM8 | R.ZMM8 -> [| R.XMM8; R.YMM8; R.ZMM8 |]
    | R.XMM9 | R.YMM9 | R.ZMM9 -> [| R.XMM9; R.YMM9; R.ZMM9 |]
    | R.XMM10 | R.YMM10 | R.ZMM10 -> [| R.XMM10; R.YMM10; R.ZMM10 |]
    | R.XMM11 | R.YMM11 | R.ZMM11 -> [| R.XMM11; R.YMM11; R.ZMM11 |]
    | R.XMM12 | R.YMM12 | R.ZMM12 -> [| R.XMM12; R.YMM12; R.ZMM12 |]
    | R.XMM13 | R.YMM13 | R.ZMM13 -> [| R.XMM13; R.YMM13; R.ZMM13 |]
    | R.XMM14 | R.YMM14 | R.ZMM14 -> [| R.XMM14; R.YMM14; R.ZMM14 |]
    | R.XMM15 | R.YMM15 | R.ZMM15 -> [| R.XMM15; R.YMM15; R.ZMM15 |]
    | R.EIP | R.RIP -> [| R.EIP; R.RIP |]
    | r -> [| r |]

  let regToPseudoReg = function
    | R.XMM0  -> [ R.ZMM0B; R.ZMM0A ]
    | R.XMM1  -> [ R.ZMM1B; R.ZMM1A ]
    | R.XMM2  -> [ R.ZMM2B; R.ZMM2A ]
    | R.XMM3  -> [ R.ZMM3B; R.ZMM3A ]
    | R.XMM4  -> [ R.ZMM4B; R.ZMM4A ]
    | R.XMM5  -> [ R.ZMM5B; R.ZMM5A ]
    | R.XMM6  -> [ R.ZMM6B; R.ZMM6A ]
    | R.XMM7  -> [ R.ZMM7B; R.ZMM7A ]
    | R.XMM8  -> [ R.ZMM8B; R.ZMM8A ]
    | R.XMM9  -> [ R.ZMM9B; R.ZMM9A ]
    | R.XMM10 -> [ R.ZMM10B; R.ZMM10A ]
    | R.XMM11 -> [ R.ZMM11B; R.ZMM11A ]
    | R.XMM12 -> [ R.ZMM12B; R.ZMM12A ]
    | R.XMM13 -> [ R.ZMM13B; R.ZMM13A ]
    | R.XMM14 -> [ R.ZMM14B; R.ZMM14A ]
    | R.XMM15 -> [ R.ZMM15B; R.ZMM15A ]
    | R.YMM0  -> [ R.ZMM0D; R.ZMM0C; R.ZMM0B; R.ZMM0A ]
    | R.YMM1  -> [ R.ZMM1D; R.ZMM1C; R.ZMM1B; R.ZMM1A ]
    | R.YMM2  -> [ R.ZMM2D; R.ZMM2C; R.ZMM2B; R.ZMM2A ]
    | R.YMM3  -> [ R.ZMM3D; R.ZMM3C; R.ZMM3B; R.ZMM3A ]
    | R.YMM4  -> [ R.ZMM4D; R.ZMM4C; R.ZMM4B; R.ZMM4A ]
    | R.YMM5  -> [ R.ZMM5D; R.ZMM5C; R.ZMM5B; R.ZMM5A ]
    | R.YMM6  -> [ R.ZMM6D; R.ZMM6C; R.ZMM6B; R.ZMM6A ]
    | R.YMM7  -> [ R.ZMM7D; R.ZMM7C; R.ZMM7B; R.ZMM7A ]
    | R.YMM8  -> [ R.ZMM8D; R.ZMM8C; R.ZMM8B; R.ZMM8A ]
    | R.YMM9  -> [ R.ZMM9D; R.ZMM9C; R.ZMM9B; R.ZMM9A ]
    | R.YMM10 -> [ R.ZMM10D; R.ZMM10C; R.ZMM10B; R.ZMM10A ]
    | R.YMM11 -> [ R.ZMM11D; R.ZMM11C; R.ZMM11B; R.ZMM11A ]
    | R.YMM12 -> [ R.ZMM12D; R.ZMM12C; R.ZMM12B; R.ZMM12A ]
    | R.YMM13 -> [ R.ZMM13D; R.ZMM13C; R.ZMM13B; R.ZMM13A ]
    | R.YMM14 -> [ R.ZMM14D; R.ZMM14C; R.ZMM14B; R.ZMM14A ]
    | R.YMM15 -> [ R.ZMM15D; R.ZMM15C; R.ZMM15B; R.ZMM15A ]
    | R.ST0 -> [ R.ST0B; R.ST0A ]
    | R.ST1 -> [ R.ST1B; R.ST1A ]
    | R.ST2 -> [ R.ST2B; R.ST2A ]
    | R.ST3 -> [ R.ST3B; R.ST3A ]
    | R.ST4 -> [ R.ST4B; R.ST4A ]
    | R.ST5 -> [ R.ST5B; R.ST5A ]
    | R.ST6 -> [ R.ST6B; R.ST6A ]
    | R.ST7 -> [ R.ST7B; R.ST7A ]
    | R.MM0 -> [ R.ST0A ]
    | R.MM1 -> [ R.ST1A ]
    | R.MM2 -> [ R.ST2A ]
    | R.MM3 -> [ R.ST3A ]
    | R.MM4 -> [ R.ST4A ]
    | R.MM5 -> [ R.ST5A ]
    | R.MM6 -> [ R.ST6A ]
    | R.MM7 -> [ R.ST7A ]
    | e -> failwithf "Unhandled register: %A" e

  let pseudoRegToReg = function
    | R.ZMM0A
    | R.ZMM0B
    | R.ZMM0C
    | R.ZMM0D
    | R.ZMM0E
    | R.ZMM0F
    | R.ZMM0G
    | R.ZMM0H -> R.ZMM0
    | R.ZMM1A
    | R.ZMM1B
    | R.ZMM1C
    | R.ZMM1D
    | R.ZMM1E
    | R.ZMM1F
    | R.ZMM1G
    | R.ZMM1H -> R.ZMM1
    | R.ZMM2A
    | R.ZMM2B
    | R.ZMM2C
    | R.ZMM2D
    | R.ZMM2E
    | R.ZMM2F
    | R.ZMM2G
    | R.ZMM2H -> R.ZMM2
    | R.ZMM3A
    | R.ZMM3B
    | R.ZMM3C
    | R.ZMM3D
    | R.ZMM3E
    | R.ZMM3F
    | R.ZMM3G
    | R.ZMM3H -> R.ZMM3
    | R.ZMM4A
    | R.ZMM4B
    | R.ZMM4C
    | R.ZMM4D
    | R.ZMM4E
    | R.ZMM4F
    | R.ZMM4G
    | R.ZMM4H -> R.ZMM4
    | R.ZMM5A
    | R.ZMM5B
    | R.ZMM5C
    | R.ZMM5D
    | R.ZMM5E
    | R.ZMM5F
    | R.ZMM5G
    | R.ZMM5H -> R.ZMM5
    | R.ZMM6A
    | R.ZMM6B
    | R.ZMM6C
    | R.ZMM6D
    | R.ZMM6E
    | R.ZMM6F
    | R.ZMM6G
    | R.ZMM6H -> R.ZMM6
    | R.ZMM7A
    | R.ZMM7B
    | R.ZMM7C
    | R.ZMM7D
    | R.ZMM7E
    | R.ZMM7F
    | R.ZMM7G
    | R.ZMM7H -> R.ZMM7
    | R.ZMM8A
    | R.ZMM8B
    | R.ZMM8C
    | R.ZMM8D
    | R.ZMM8E
    | R.ZMM8F
    | R.ZMM8G
    | R.ZMM8H -> R.ZMM8
    | R.ZMM9A
    | R.ZMM9B
    | R.ZMM9C
    | R.ZMM9D
    | R.ZMM9E
    | R.ZMM9F
    | R.ZMM9G
    | R.ZMM9H -> R.ZMM9
    | R.ZMM10A
    | R.ZMM10B
    | R.ZMM10C
    | R.ZMM10D
    | R.ZMM10E
    | R.ZMM10F
    | R.ZMM10G
    | R.ZMM10H -> R.ZMM10
    | R.ZMM11A
    | R.ZMM11B
    | R.ZMM11C
    | R.ZMM11D
    | R.ZMM11E
    | R.ZMM11F
    | R.ZMM11G
    | R.ZMM11H -> R.ZMM11
    | R.ZMM12A
    | R.ZMM12B
    | R.ZMM12C
    | R.ZMM12D
    | R.ZMM12E
    | R.ZMM12F
    | R.ZMM12G
    | R.ZMM12H -> R.ZMM12
    | R.ZMM13A
    | R.ZMM13B
    | R.ZMM13C
    | R.ZMM13D
    | R.ZMM13E
    | R.ZMM13F
    | R.ZMM13G
    | R.ZMM13H -> R.ZMM13
    | R.ZMM14A
    | R.ZMM14B
    | R.ZMM14C
    | R.ZMM14D
    | R.ZMM14E
    | R.ZMM14F
    | R.ZMM14G
    | R.ZMM14H -> R.ZMM14
    | R.ZMM15A
    | R.ZMM15B
    | R.ZMM15C
    | R.ZMM15D
    | R.ZMM15E
    | R.ZMM15F
    | R.ZMM15G
    | R.ZMM15H -> R.ZMM15
    | R.ST0A | R.ST0B -> R.ST0
    | R.ST1A | R.ST1B -> R.ST1
    | R.ST2A | R.ST2B -> R.ST2
    | R.ST3A | R.ST3B -> R.ST3
    | R.ST4A | R.ST4B -> R.ST4
    | R.ST5A | R.ST5B -> R.ST5
    | R.ST6A | R.ST6B -> R.ST6
    | R.ST7A | R.ST7B -> R.ST7
    | e -> failwithf "Unhandled register: %A" e
end

/// This module defines sets of registers that are frequently grouped by Intel.
/// Table 3-1. Register Codes Associated With +rb, +rw, +rd, +ro
module internal RegGroup = begin
  /// Grp 0.
  let grpEAX = function
    | 64<rt> -> R.RAX
    | 32<rt> -> R.EAX
    | 16<rt> -> R.AX
    | 8<rt> -> R.AL
    | 128<rt> -> R.XMM0
    | 256<rt> -> R.YMM0
    | 512<rt> -> R.ZMM0
    | _ -> Utils.impossible ()

  /// Grp 1.
  let grpECX = function
    | 64<rt> -> R.RCX
    | 32<rt> -> R.ECX
    | 16<rt> -> R.CX
    | 8<rt> -> R.CL
    | 128<rt> -> R.XMM1
    | 256<rt> -> R.YMM1
    | 512<rt> -> R.ZMM1
    | _ -> Utils.impossible ()

  /// Grp 2.
  let grpEDX = function
    | 64<rt> -> R.RDX
    | 32<rt> -> R.EDX
    | 16<rt> -> R.DX
    | 8<rt> -> R.DL
    | 128<rt> -> R.XMM2
    | 256<rt> -> R.YMM2
    | 512<rt> -> R.ZMM2
    | _ -> Utils.impossible ()

  /// Grp 3.
  let grpEBX = function
    | 64<rt> -> R.RBX
    | 32<rt> -> R.EBX
    | 16<rt> -> R.BX
    | 8<rt> -> R.BL
    | 128<rt> -> R.XMM3
    | 256<rt> -> R.YMM3
    | 512<rt> -> R.ZMM3
    | _ -> Utils.impossible ()
end

IntelRegisterBay.fs
//这段代码定义了一个IntelRegisterBay类型,它是一个RegisterBay的派生类型,用于Intel体系结构下的寄存器相关操作。
//主要功能点包括:
//1. 根据字长判断是否为32位或64位模式,从而获取对应的寄存器列表。
//2. 通过RegExprs对象获取各种寄存器的抽象表达式。
//3. 提供转换寄存器ID、名称、类型的方法。
//4. 提供获取伪寄存器别名关系的方法。 
//5. 定义程序计数器、堆栈指针和帧指针对应的寄存器ID。
//6. 判断是否为程序计数器、堆栈指针或帧指针的方法。
//总的来说,它完成了RegisterBay类型针对Intel体系结构的具体实现,包括获取各类寄存器表达式、转换寄存器
//相关信息以及判断特殊寄存器类型等功能。
//这使得后续的BIN文件解析和代码生成可以针对不同的体系结构进行抽象,同时又保留了具体体系结构的信息,
//实现了二级抽象的目的。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.FrontEnd.BinLifter
open B2R2.BinIR.LowUIR

type IntelRegisterBay internal (wordSize, R: RegExprs) =

  inherit RegisterBay ()

  override __.GetAllRegExprs () =
    if WordSize.is32 wordSize then
      [ R.EAX; R.EBX; R.ECX; R.EDX; R.ESP; R.EBP; R.ESI; R.EDI; R.EIP; R.CSBase;
        R.DSBase; R.ESBase; R.FSBase; R.GSBase; R.SSBase; R.CR0; R.CR2; R.CR3;
        R.CR4; R.OF; R.DF; R.IF; R.TF; R.SF; R.ZF; R.AF; R.PF; R.CF; R.FCW;
        R.FSW; R.FTW; R.FOP; R.FIP; R.FCS; R.FDP; R.FDS; R.MXCSR; R.MXCSRMASK;
        R.PKRU; R.K0; R.K1; R.K2; R.K3; R.K4; R.K5; R.K6; R.K7; R.ST0A; R.ST0B;
        R.ST1A; R.ST1B; R.ST2A; R.ST2B; R.ST3A; R.ST3B; R.ST4A; R.ST4B; R.ST5A;
        R.ST5B; R.ST6A; R.ST6B; R.ST7A; R.ST7B; R.ZMM0A; R.ZMM0B; R.ZMM0C;
        R.ZMM0D; R.ZMM0E; R.ZMM0F; R.ZMM0G; R.ZMM0H; R.ZMM1A; R.ZMM1B; R.ZMM1C;
        R.ZMM1D; R.ZMM1E; R.ZMM1F; R.ZMM1G; R.ZMM1H; R.ZMM2A; R.ZMM2B; R.ZMM2C;
        R.ZMM2D; R.ZMM2E; R.ZMM2F; R.ZMM2G; R.ZMM2H; R.ZMM3A; R.ZMM3B; R.ZMM3C;
        R.ZMM3D; R.ZMM3E; R.ZMM3F; R.ZMM3G; R.ZMM3H; R.ZMM4A; R.ZMM4B; R.ZMM4C;
        R.ZMM4D; R.ZMM4E; R.ZMM4F; R.ZMM4G; R.ZMM4H; R.ZMM5A; R.ZMM5B; R.ZMM5C;
        R.ZMM5D; R.ZMM5E; R.ZMM5F; R.ZMM5G; R.ZMM5H; R.ZMM6A; R.ZMM6B; R.ZMM6C;
        R.ZMM6D; R.ZMM6E; R.ZMM6F; R.ZMM6G; R.ZMM6H; R.ZMM7A; R.ZMM7B; R.ZMM7C;
        R.ZMM7D; R.ZMM7E; R.ZMM7F; R.ZMM7G; R.ZMM7H; R.CS; R.DS; R.ES; R.FS;
        R.GS; R.SS; R.DR0; R.DR1; R.DR2; R.DR3; R.DR6; R.DR7 ]
    else
      [ R.RAX; R.RBX; R.RCX; R.RDX; R.RSP; R.RBP; R.RSI; R.RDI; R.R8; R.R9;
        R.R10; R.R11; R.R12; R.R13; R.R14; R.R15; R.RIP; R.CSBase; R.DSBase;
        R.ESBase; R.FSBase; R.GSBase; R.SSBase; R.CR0;R.CR2; R.CR3; R.CR4;
        R.CR8; R.OF; R.DF; R.IF; R.TF; R.SF; R.ZF; R.AF; R.PF; R.CF; R.FCW;
        R.FSW; R.FTW; R.FOP; R.FIP; R.FCS; R.FDP; R.FDS; R.MXCSR; R.MXCSRMASK;
        R.PKRU; R.K0; R.K1; R.K2; R.K3; R.K4; R.K5; R.K6; R.K7; R.ST0A; R.ST0B;
        R.ST1A; R.ST1B; R.ST2A; R.ST2B; R.ST3A; R.ST3B; R.ST4A; R.ST4B; R.ST5A;
        R.ST5B; R.ST6A; R.ST6B; R.ST7A; R.ST7B; R.ZMM0A; R.ZMM0B; R.ZMM0C;
        R.ZMM0D; R.ZMM0E; R.ZMM0F; R.ZMM0G; R.ZMM0H; R.ZMM1A; R.ZMM1B; R.ZMM1C;
        R.ZMM1D; R.ZMM1E; R.ZMM1F; R.ZMM1G; R.ZMM1H; R.ZMM2A; R.ZMM2B; R.ZMM2C;
        R.ZMM2D; R.ZMM2E; R.ZMM2F; R.ZMM2G; R.ZMM2H; R.ZMM3A; R.ZMM3B; R.ZMM3C;
        R.ZMM3D; R.ZMM3E; R.ZMM3F; R.ZMM3G; R.ZMM3H; R.ZMM4A; R.ZMM4B; R.ZMM4C;
        R.ZMM4D; R.ZMM4E; R.ZMM4F; R.ZMM4G; R.ZMM4H; R.ZMM5A; R.ZMM5B; R.ZMM5C;
        R.ZMM5D; R.ZMM5E; R.ZMM5F; R.ZMM5G; R.ZMM5H; R.ZMM6A; R.ZMM6B; R.ZMM6C;
        R.ZMM6D; R.ZMM6E; R.ZMM6F; R.ZMM6G; R.ZMM6H; R.ZMM7A; R.ZMM7B; R.ZMM7C;
        R.ZMM7D; R.ZMM7E; R.ZMM7F; R.ZMM7G; R.ZMM7H; R.ZMM8A; R.ZMM8B; R.ZMM8C;
        R.ZMM8D; R.ZMM8E; R.ZMM8F; R.ZMM8G; R.ZMM8H; R.ZMM9A; R.ZMM9B; R.ZMM9C;
        R.ZMM9D; R.ZMM9E; R.ZMM9F; R.ZMM9G; R.ZMM9H; R.ZMM10A; R.ZMM10B;
        R.ZMM10C; R.ZMM10D; R.ZMM10E; R.ZMM10F; R.ZMM10G; R.ZMM10H; R.ZMM11A;
        R.ZMM11B; R.ZMM11C; R.ZMM11D; R.ZMM11E; R.ZMM11F; R.ZMM11G; R.ZMM11H;
        R.ZMM12A; R.ZMM12B; R.ZMM12C; R.ZMM12D; R.ZMM12E; R.ZMM12F; R.ZMM12G;
        R.ZMM12H; R.ZMM13A; R.ZMM13B; R.ZMM13C; R.ZMM13D; R.ZMM13E; R.ZMM13F;
        R.ZMM13G; R.ZMM13H; R.ZMM14A; R.ZMM14B; R.ZMM14C; R.ZMM14D; R.ZMM14E;
        R.ZMM14F; R.ZMM14G; R.ZMM14H; R.ZMM15A; R.ZMM15B; R.ZMM15C; R.ZMM15D;
        R.ZMM15E; R.ZMM15F; R.ZMM15G; R.ZMM15H; R.CS; R.DS; R.ES; R.FS; R.GS;
        R.SS; R.DR0; R.DR1; R.DR2; R.DR3; R.DR6; R.DR7 ]

  override __.GetAllRegNames () =
    __.GetAllRegExprs ()
    |> List.map (__.RegIDFromRegExpr >> __.RegIDToString)

  override __.GetGeneralRegExprs () =
    if WordSize.is32 wordSize then
      [ R.EAX; R.EBX; R.ECX; R.EDX; R.ESP; R.EBP; R.ESI; R.EDI; R.EIP
        R.OF; R.DF; R.IF; R.SF; R.ZF; R.AF; R.PF; R.CF ]
    else
      [ R.RAX; R.RBX; R.RCX; R.RDX; R.RSP; R.RBP; R.RSI; R.RDI; R.R8; R.R9
        R.R10; R.R11; R.R12; R.R13; R.R14; R.R15; R.RIP
        R.OF; R.DF; R.IF; R.SF; R.ZF; R.AF; R.PF; R.CF ]

  override __.RegIDFromRegExpr (e) =
    match e.E with
    | Var (_,id, _,_) -> id
    | PCVar (regT, _) ->
      if regT = 32<rt> then Register.toRegID Register.EIP
      else Register.toRegID Register.RIP
    | _ -> failwith "not a register expression"

  override __.RegIDToRegExpr (id) =
    Register.ofRegID id |> R.GetRegVar

  override __.StrToRegExpr (s: string) =
    match s.ToUpper () with
    | "RAX" -> R.RAX
    | "RBX" -> R.RBX
    | "RCX" -> R.RCX
    | "RDX" -> R.RDX
    | "RSP" -> R.RSP
    | "RBP" -> R.RBP
    | "RSI" -> R.RSI
    | "RDI" -> R.RDI
    | "EAX" -> R.EAX
    | "EBX" -> R.EBX
    | "ECX" -> R.ECX
    | "EDX" -> R.EDX
    | "ESP" -> R.ESP
    | "EBP" -> R.EBP
    | "ESI" -> R.ESI
    | "EDI" -> R.EDI
    | "AX" -> R.AX
    | "BX" -> R.BX
    | "CX" -> R.CX
    | "DX" -> R.DX
    | "SP" -> R.SP
    | "BP" -> R.BP
    | "SI" -> R.SI
    | "DI" -> R.DI
    | "AL" -> R.AL
    | "BL" -> R.BL
    | "CL" -> R.CL
    | "DL" -> R.DL
    | "AH" -> R.AH
    | "BH" -> R.BH
    | "CH" -> R.CH
    | "DH" -> R.DH
    | "R8" -> R.R8
    | "R9" -> R.R9
    | "R10" -> R.R10
    | "R11" -> R.R11
    | "R12" -> R.R12
    | "R13" -> R.R13
    | "R14" -> R.R14
    | "R15" -> R.R15
    | "R8D" -> R.R8D
    | "R9D" -> R.R9D
    | "R10D" -> R.R10D
    | "R11D" -> R.R11D
    | "R12D" -> R.R12D
    | "R13D" -> R.R13D
    | "R14D" -> R.R14D
    | "R15D" -> R.R15D
    | "R8W" -> R.R8W
    | "R9W" -> R.R9W
    | "R10W" -> R.R10W
    | "R11W" -> R.R11W
    | "R12W" -> R.R12W
    | "R13W" -> R.R13W
    | "R14W" -> R.R14W
    | "R15W" -> R.R15W
    | "R8L" -> R.R8L
    | "R9L" -> R.R9L
    | "R10L" -> R.R10L
    | "R11L" -> R.R11L
    | "R12L" -> R.R12L
    | "R13L" -> R.R13L
    | "R14L" -> R.R14L
    | "R15L" -> R.R15L
    | "SPL" -> R.SPL
    | "BPL" -> R.BPL
    | "SIL" -> R.SIL
    | "DIL" -> R.DIL
    | "EIP" -> R.EIP
    | "RIP" -> R.RIP
    | "MM0" -> R.MM0
    | "MM1" -> R.MM1
    | "MM2" -> R.MM2
    | "MM3" -> R.MM3
    | "MM4" -> R.MM4
    | "MM5" -> R.MM5
    | "MM6" -> R.MM6
    | "MM7" -> R.MM7
    | "CS" -> R.CS
    | "DS" -> R.DS
    | "SS" -> R.SS
    | "ES" -> R.ES
    | "FS" -> R.FS
    | "GS" -> R.GS
    | "CSBASE" -> R.CSBase
    | "DSBASE" -> R.DSBase
    | "ESBASE" -> R.ESBase
    | "FSBASE" -> R.FSBase
    | "GSBASE" -> R.GSBase
    | "SSBASE" -> R.SSBase
    | "CR0" -> R.CR0
    | "CR2" -> R.CR2
    | "CR3" -> R.CR3
    | "CR4" -> R.CR4
    | "CR8" -> R.CR8
    | "OF" -> R.OF
    | "DF" -> R.DF
    | "IF" -> R.IF
    | "TF" -> R.TF
    | "SF" -> R.SF
    | "ZF" -> R.ZF
    | "AF" -> R.AF
    | "PF" -> R.PF
    | "CF" -> R.CF
    | "K0" -> R.K0
    | "K1" -> R.K1
    | "K2" -> R.K2
    | "K3" -> R.K3
    | "K4" -> R.K4
    | "K5" -> R.K5
    | "K6" -> R.K6
    | "K7" -> R.K7
    | "ST0A" -> R.ST0A
    | "ST0B" -> R.ST0B
    | "ST1A" -> R.ST1A
    | "ST1B" -> R.ST1B
    | "ST2A" -> R.ST2A
    | "ST2B" -> R.ST2B
    | "ST3A" -> R.ST3A
    | "ST3B" -> R.ST3B
    | "ST4A" -> R.ST4A
    | "ST4B" -> R.ST4B
    | "ST5A" -> R.ST5A
    | "ST5B" -> R.ST5B
    | "ST6A" -> R.ST6A
    | "ST6B" -> R.ST6B
    | "ST7A" -> R.ST7A
    | "ST7B" -> R.ST7B
    | "FCW" -> R.FCW
    | "FSW" -> R.FSW
    | "FTW" -> R.FTW
    | "FOP" -> R.FOP
    | "FIP" -> R.FIP
    | "FCS" -> R.FCS
    | "FDP" -> R.FDP
    | "FDS" -> R.FDS
    | "FTOP" -> R.FTOP
    | "FTW0" -> R.FTW0
    | "FTW1" -> R.FTW1
    | "FTW2" -> R.FTW2
    | "FTW3" -> R.FTW3
    | "FTW4" -> R.FTW4
    | "FTW5" -> R.FTW5
    | "FTW6" -> R.FTW6
    | "FTW7" -> R.FTW7
    | "FSWC0" -> R.FSWC0
    | "FSWC1" -> R.FSWC1
    | "FSWC2" -> R.FSWC2
    | "FSWC3" -> R.FSWC3
    | "MXCSR" -> R.MXCSR
    | "MXCSRMASK" -> R.MXCSRMASK
    | "ZMM0A" -> R.ZMM0A
    | "ZMM0B" -> R.ZMM0B
    | "ZMM0C" -> R.ZMM0C
    | "ZMM0D" -> R.ZMM0D
    | "ZMM0E" -> R.ZMM0E
    | "ZMM0F" -> R.ZMM0F
    | "ZMM0G" -> R.ZMM0G
    | "ZMM0H" -> R.ZMM0H
    | "ZMM1A" -> R.ZMM1A
    | "ZMM1B" -> R.ZMM1B
    | "ZMM1C" -> R.ZMM1C
    | "ZMM1D" -> R.ZMM1D
    | "ZMM1E" -> R.ZMM1E
    | "ZMM1F" -> R.ZMM1F
    | "ZMM1G" -> R.ZMM1G
    | "ZMM1H" -> R.ZMM1H
    | "ZMM2A" -> R.ZMM2A
    | "ZMM2B" -> R.ZMM2B
    | "ZMM2C" -> R.ZMM2C
    | "ZMM2D" -> R.ZMM2D
    | "ZMM2E" -> R.ZMM2E
    | "ZMM2F" -> R.ZMM2F
    | "ZMM2G" -> R.ZMM2G
    | "ZMM2H" -> R.ZMM2H
    | "ZMM3A" -> R.ZMM3A
    | "ZMM3B" -> R.ZMM3B
    | "ZMM3C" -> R.ZMM3C
    | "ZMM3D" -> R.ZMM3D
    | "ZMM3E" -> R.ZMM3E
    | "ZMM3F" -> R.ZMM3F
    | "ZMM3G" -> R.ZMM3G
    | "ZMM3H" -> R.ZMM3H
    | "ZMM4A" -> R.ZMM4A
    | "ZMM4B" -> R.ZMM4B
    | "ZMM4C" -> R.ZMM4C
    | "ZMM4D" -> R.ZMM4D
    | "ZMM4E" -> R.ZMM4E
    | "ZMM4F" -> R.ZMM4F
    | "ZMM4G" -> R.ZMM4G
    | "ZMM4H" -> R.ZMM4H
    | "ZMM5A" -> R.ZMM5A
    | "ZMM5B" -> R.ZMM5B
    | "ZMM5C" -> R.ZMM5C
    | "ZMM5D" -> R.ZMM5D
    | "ZMM5E" -> R.ZMM5E
    | "ZMM5F" -> R.ZMM5F
    | "ZMM5G" -> R.ZMM5G
    | "ZMM5H" -> R.ZMM5H
    | "ZMM6A" -> R.ZMM6A
    | "ZMM6B" -> R.ZMM6B
    | "ZMM6C" -> R.ZMM6C
    | "ZMM6D" -> R.ZMM6D
    | "ZMM6E" -> R.ZMM6E
    | "ZMM6F" -> R.ZMM6F
    | "ZMM6G" -> R.ZMM6G
    | "ZMM6H" -> R.ZMM6H
    | "ZMM7A" -> R.ZMM7A
    | "ZMM7B" -> R.ZMM7B
    | "ZMM7C" -> R.ZMM7C
    | "ZMM7D" -> R.ZMM7D
    | "ZMM7E" -> R.ZMM7E
    | "ZMM7F" -> R.ZMM7F
    | "ZMM7G" -> R.ZMM7G
    | "ZMM7H" -> R.ZMM7H
    | "ZMM8A" -> R.ZMM8A
    | "ZMM8B" -> R.ZMM8B
    | "ZMM8C" -> R.ZMM8C
    | "ZMM8D" -> R.ZMM8D
    | "ZMM8E" -> R.ZMM8E
    | "ZMM8F" -> R.ZMM8F
    | "ZMM8G" -> R.ZMM8G
    | "ZMM8H" -> R.ZMM8H
    | "ZMM9A" -> R.ZMM9A
    | "ZMM9B" -> R.ZMM9B
    | "ZMM9C" -> R.ZMM9C
    | "ZMM9D" -> R.ZMM9D
    | "ZMM9E" -> R.ZMM9E
    | "ZMM9F" -> R.ZMM9F
    | "ZMM9G" -> R.ZMM9G
    | "ZMM9H" -> R.ZMM9H
    | "ZMM10A" -> R.ZMM10A
    | "ZMM10B" -> R.ZMM10B
    | "ZMM10C" -> R.ZMM10C
    | "ZMM10D" -> R.ZMM10D
    | "ZMM10E" -> R.ZMM10E
    | "ZMM10F" -> R.ZMM10F
    | "ZMM10G" -> R.ZMM10G
    | "ZMM10H" -> R.ZMM10H
    | "ZMM11A" -> R.ZMM11A
    | "ZMM11B" -> R.ZMM11B
    | "ZMM11C" -> R.ZMM11C
    | "ZMM11D" -> R.ZMM11D
    | "ZMM11E" -> R.ZMM11E
    | "ZMM11F" -> R.ZMM11F
    | "ZMM11G" -> R.ZMM11G
    | "ZMM11H" -> R.ZMM11H
    | "ZMM12A" -> R.ZMM12A
    | "ZMM12B" -> R.ZMM12B
    | "ZMM12C" -> R.ZMM12C
    | "ZMM12D" -> R.ZMM12D
    | "ZMM12E" -> R.ZMM12E
    | "ZMM12F" -> R.ZMM12F
    | "ZMM12G" -> R.ZMM12G
    | "ZMM12H" -> R.ZMM12H
    | "ZMM13A" -> R.ZMM13A
    | "ZMM13B" -> R.ZMM13B
    | "ZMM13C" -> R.ZMM13C
    | "ZMM13D" -> R.ZMM13D
    | "ZMM13E" -> R.ZMM13E
    | "ZMM13F" -> R.ZMM13F
    | "ZMM13G" -> R.ZMM13G
    | "ZMM13H" -> R.ZMM13H
    | "ZMM14A" -> R.ZMM14A
    | "ZMM14B" -> R.ZMM14B
    | "ZMM14C" -> R.ZMM14C
    | "ZMM14D" -> R.ZMM14D
    | "ZMM14E" -> R.ZMM14E
    | "ZMM14F" -> R.ZMM14F
    | "ZMM14G" -> R.ZMM14G
    | "ZMM14H" -> R.ZMM14H
    | "ZMM15A" -> R.ZMM15A
    | "ZMM15B" -> R.ZMM15B
    | "ZMM15C" -> R.ZMM15C
    | "ZMM15D" -> R.ZMM15D
    | "ZMM15E" -> R.ZMM15E
    | "ZMM15F" -> R.ZMM15F
    | "ZMM15G" -> R.ZMM15G
    | "ZMM15H" -> R.ZMM15H
    | "PKRU" -> R.PKRU
    | "DR0" -> R.DR0
    | "DR1" -> R.DR1
    | "DR2" -> R.DR2
    | "DR3" -> R.DR3
    | "DR6" -> R.DR6
    | "DR7" -> R.DR7
    | _ -> raise UnhandledRegExprException

  override __.RegIDFromString str =
    Register.ofString str |> Register.toRegID

  override __.RegIDToString rid =
    Register.ofRegID rid |> Register.toString

  override __.RegIDToRegType rid =
    Register.ofRegID rid |> Register.toRegType

  override __.GetRegisterAliases rid =
    Register.ofRegID rid
    |> Register.getAliases
    |> Array.map Register.toRegID

  override __.ProgramCounter =
    if WordSize.is32 wordSize then Register.EIP |> Register.toRegID
    else Register.RIP |> Register.toRegID

  override __.StackPointer =
    if WordSize.is32 wordSize then Register.ESP |> Register.toRegID
    else Register.RSP |> Register.toRegID
    |> Some

  override __.FramePointer =
    if WordSize.is32 wordSize then Register.EBP |> Register.toRegID
    else Register.RBP |> Register.toRegID
    |> Some

  override __.IsProgramCounter regid =
    __.ProgramCounter = regid

  override __.IsStackPointer regid =
    (__.StackPointer |> Option.get) = regid

  override __.IsFramePointer regid =
    (__.FramePointer |> Option.get) = regid

IntelRegisterSet.fs
//这段代码定义了Intel体系结构的寄存器集类型IntelRegisterSet。
//主要功能:
//1. 继承自NonEmptyRegisterSet,实现寄存器集的基本操作。
//2. 重写Tag属性返回RegisterSetTag.Intel,表示该集是Intel相关。
//3. 实现RegIDToIndex和IndexToRegID,将寄存器ID转换为数组下标和 vice versa。
//4. 数组长度定为4,表示设定4个uint64位来管理Intel相关寄存器状态。 
//5. 提供单例构造方法singleton和空实例empty。
//该类型主要用来管理Intel指令处理中相关寄存器的使用状态。实现了寄存器ID与状态位数组下标之间的映射,
//并定义自身为Intel相关。
//后续处理Intel二进制代码时,可以使用这个类型维护指令对寄存器的影响,并通过基类接口完成状态检查、修改等功能。
//相比直接使用bitmap,它提供了更规范清晰的接口。
//总的来说,这个类型很好的实现了面向Intel体系结构的寄存器集管理,为Intel指令解析与执行奠定了基础。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2

module private RegisterSetLiteral =
  let [<Literal>] ArrLen = 4

open RegisterSetLiteral

type IntelRegisterSet (bitArray: uint64 [], s: Set<RegisterID>) =
  inherit NonEmptyRegisterSet (bitArray, s)

  new () = IntelRegisterSet (RegisterSet.MakeInternalBitArray ArrLen, Set.empty)

  override __.Tag = RegisterSetTag.Intel

  override __.ArrSize = ArrLen

  override __.New arr s = new IntelRegisterSet (arr, s) :> RegisterSet

  override __.RegIDToIndex rid =
    match Register.ofRegID rid with
    | R.EAX -> 0
    | R.EBX -> 1
    | R.ECX -> 2
    | R.EDX -> 3
    | R.ESP -> 4
    | R.EBP -> 5
    | R.ESI -> 6
    | R.EDI -> 7
    | R.RAX -> 8
    | R.RBX -> 9
    | R.RCX -> 10
    | R.RDX -> 11
    | R.RSP -> 12
    | R.RBP -> 13
    | R.RSI -> 14
    | R.RDI -> 15
    | R.R8  -> 16
    | R.R9  -> 17
    | R.R10 -> 18
    | R.R11 -> 19
    | R.R12 -> 20
    | R.R13 -> 21
    | R.R14 -> 22
    | R.R15 -> 23
    | R.SPL -> 24
    | R.BPL -> 25
    | R.SIL -> 26
    | R.DIL -> 27
    | R.ES -> 28
    | R.CS -> 29
    | R.SS -> 30
    | R.DS -> 31
    | R.FS -> 32
    | R.GS -> 33
    | R.ESBase -> 34
    | R.CSBase -> 35
    | R.SSBase -> 36
    | R.DSBase -> 37
    | R.FSBase -> 38
    | R.GSBase -> 39
    | R.OF -> 40
    | R.DF -> 41
    | R.IF -> 42
    | R.TF -> 43
    | R.SF -> 44
    | R.ZF -> 45
    | R.AF -> 46
    | R.PF -> 47
    | R.CF -> 48
    | R.MM0 -> 49
    | R.MM1 -> 50
    | R.MM2 -> 51
    | R.MM3 -> 52
    | R.MM4 -> 53
    | R.MM5 -> 54
    | R.MM6 -> 55
    | R.MM7 -> 56
    | R.ZMM0A -> 57
    | R.ZMM0B -> 58
    | R.ZMM0C -> 59
    | R.ZMM0D -> 60
    | R.ZMM0E -> 61
    | R.ZMM0F -> 62
    | R.ZMM0G -> 63
    | R.ZMM0H -> 64
    | R.ZMM1A -> 65
    | R.ZMM1B -> 66
    | R.ZMM1C -> 67
    | R.ZMM1D -> 68
    | R.ZMM1E -> 69
    | R.ZMM1F -> 70
    | R.ZMM1G -> 71
    | R.ZMM1H -> 72
    | R.ZMM2A -> 73
    | R.ZMM2B -> 74
    | R.ZMM2C -> 75
    | R.ZMM2D -> 76
    | R.ZMM2E -> 77
    | R.ZMM2F -> 78
    | R.ZMM2G -> 79
    | R.ZMM2H -> 80
    | R.ZMM3A -> 81
    | R.ZMM3B -> 82
    | R.ZMM3C -> 83
    | R.ZMM3D -> 84
    | R.ZMM3E -> 85
    | R.ZMM3F -> 86
    | R.ZMM3G -> 87
    | R.ZMM3H -> 88
    | R.ZMM4A -> 89
    | R.ZMM4B -> 90
    | R.ZMM4C -> 91
    | R.ZMM4D -> 92
    | R.ZMM4E -> 93
    | R.ZMM4F -> 94
    | R.ZMM4G -> 95
    | R.ZMM4H -> 96
    | R.ZMM5A -> 97
    | R.ZMM5B -> 98
    | R.ZMM5C -> 99
    | R.ZMM5D -> 100
    | R.ZMM5E -> 101
    | R.ZMM5F -> 102
    | R.ZMM5G -> 103
    | R.ZMM5H -> 104
    | R.ZMM6A -> 105
    | R.ZMM6B -> 106
    | R.ZMM6C -> 107
    | R.ZMM6D -> 108
    | R.ZMM6E -> 109
    | R.ZMM6F -> 110
    | R.ZMM6G -> 111
    | R.ZMM6H -> 112
    | R.ZMM7A -> 113
    | R.ZMM7B -> 114
    | R.ZMM7C -> 115
    | R.ZMM7D -> 116
    | R.ZMM7E -> 117
    | R.ZMM7F -> 118
    | R.ZMM7G -> 119
    | R.ZMM7H -> 120
    | R.ZMM8A -> 121
    | R.ZMM8B -> 122
    | R.ZMM8C -> 123
    | R.ZMM8D -> 124
    | R.ZMM8E -> 125
    | R.ZMM8F -> 126
    | R.ZMM8G -> 127
    | R.ZMM8H -> 128
    | R.ZMM9A -> 129
    | R.ZMM9B -> 130
    | R.ZMM9C -> 131
    | R.ZMM9D -> 132
    | R.ZMM9E -> 133
    | R.ZMM9F -> 134
    | R.ZMM9G -> 135
    | R.ZMM9H -> 136
    | R.ZMM10A -> 137
    | R.ZMM10B -> 138
    | R.ZMM10C -> 139
    | R.ZMM10D -> 140
    | R.ZMM10E -> 141
    | R.ZMM10F -> 142
    | R.ZMM10G -> 143
    | R.ZMM10H -> 144
    | R.ZMM11A -> 145
    | R.ZMM11B -> 146
    | R.ZMM11C -> 147
    | R.ZMM11D -> 148
    | R.ZMM11E -> 149
    | R.ZMM11F -> 150
    | R.ZMM11G -> 151
    | R.ZMM11H -> 152
    | R.ZMM12A -> 153
    | R.ZMM12B -> 154
    | R.ZMM12C -> 155
    | R.ZMM12D -> 156
    | R.ZMM12E -> 157
    | R.ZMM12F -> 158
    | R.ZMM12G -> 159
    | R.ZMM12H -> 160
    | R.ZMM13A -> 161
    | R.ZMM13B -> 162
    | R.ZMM13C -> 163
    | R.ZMM13D -> 164
    | R.ZMM13E -> 165
    | R.ZMM13F -> 166
    | R.ZMM13G -> 167
    | R.ZMM13H -> 168
    | R.ZMM14A -> 169
    | R.ZMM14B -> 170
    | R.ZMM14C -> 171
    | R.ZMM14D -> 172
    | R.ZMM14E -> 173
    | R.ZMM14F -> 174
    | R.ZMM14G -> 175
    | R.ZMM14H -> 176
    | R.ZMM15A -> 177
    | R.ZMM15B -> 178
    | R.ZMM15C -> 179
    | R.ZMM15D -> 180
    | R.ZMM15E -> 181
    | R.ZMM15F -> 182
    | R.ZMM15G -> 183
    | R.ZMM15H -> 184
    | R.BND0A -> 185
    | R.BND0B -> 186
    | R.BND1A -> 187
    | R.BND1B -> 188
    | R.BND2A -> 189
    | R.BND2B -> 190
    | R.BND3A -> 191
    | R.BND3B -> 192
    | R.FCW -> 193
    | R.FSW -> 194
    | R.FTW -> 195
    | R.FOP -> 196
    | R.FIP -> 197
    | R.FCS -> 198
    | R.FDP -> 199
    | R.FDS -> 200
    | R.MXCSR -> 201
    | R.MXCSRMASK -> 202
    | R.PKRU -> 203
    | R.DR0 -> 204
    | R.DR1 -> 205
    | R.DR2 -> 206
    | R.DR3 -> 207
    | R.DR6 -> 208
    | R.DR7 -> 209
    | _ -> -1

  override __.IndexToRegID index =
    match index with
    | 0 -> R.EAX
    | 1 -> R.EBX
    | 2 -> R.ECX
    | 3 -> R.EDX
    | 4 -> R.ESP
    | 5 -> R.EBP
    | 6 -> R.ESI
    | 7 -> R.EDI
    | 8 -> R.RAX
    | 9 -> R.RBX
    | 10 -> R.RCX
    | 11 -> R.RDX
    | 12 -> R.RSP
    | 13 -> R.RBP
    | 14 -> R.RSI
    | 15 -> R.RDI
    | 16 -> R.R8
    | 17 -> R.R9
    | 18 -> R.R10
    | 19 -> R.R11
    | 20 -> R.R12
    | 21 -> R.R13
    | 22 -> R.R14
    | 23 -> R.R15
    | 24 -> R.SPL
    | 25 -> R.BPL
    | 26 -> R.SIL
    | 27 -> R.DIL
    | 28 -> R.ES
    | 29 -> R.CS
    | 30 -> R.SS
    | 31 -> R.DS
    | 32 -> R.FS
    | 33 -> R.GS
    | 34 -> R.ESBase
    | 35 -> R.CSBase
    | 36 -> R.SSBase
    | 37 -> R.DSBase
    | 38 -> R.FSBase
    | 39 -> R.GSBase
    | 40 -> R.OF
    | 41 -> R.DF
    | 42 -> R.IF
    | 43 -> R.TF
    | 44 -> R.SF
    | 45 -> R.ZF
    | 46 -> R.AF
    | 47 -> R.PF
    | 48 -> R.CF
    | 49 -> R.MM0
    | 50 -> R.MM1
    | 51 -> R.MM2
    | 52 -> R.MM3
    | 53 -> R.MM4
    | 54 -> R.MM5
    | 55 -> R.MM6
    | 56 -> R.MM7
    | 57 -> R.ZMM0A
    | 58 -> R.ZMM0B
    | 59 -> R.ZMM0C
    | 60 -> R.ZMM0D
    | 61 -> R.ZMM0E
    | 62 -> R.ZMM0F
    | 63 -> R.ZMM0G
    | 64 -> R.ZMM0H
    | 65 -> R.ZMM1A
    | 66 -> R.ZMM1B
    | 67 -> R.ZMM1C
    | 68 -> R.ZMM1D
    | 69 -> R.ZMM1E
    | 70 -> R.ZMM1F
    | 71 -> R.ZMM1G
    | 72 -> R.ZMM1H
    | 73 -> R.ZMM2A
    | 74 -> R.ZMM2B
    | 75 -> R.ZMM2C
    | 76 -> R.ZMM2D
    | 77 -> R.ZMM2E
    | 78 -> R.ZMM2F
    | 79 -> R.ZMM2G
    | 80 -> R.ZMM2H
    | 81 -> R.ZMM3A
    | 82 -> R.ZMM3B
    | 83 -> R.ZMM3C
    | 84 -> R.ZMM3D
    | 85 -> R.ZMM3E
    | 86 -> R.ZMM3F
    | 87 -> R.ZMM3G
    | 88 -> R.ZMM3H
    | 89 -> R.ZMM4A
    | 90 -> R.ZMM4B
    | 91 -> R.ZMM4C
    | 92 -> R.ZMM4D
    | 93 -> R.ZMM4E
    | 94 -> R.ZMM4F
    | 95 -> R.ZMM4G
    | 96 -> R.ZMM4H
    | 97 -> R.ZMM5A
    | 98 -> R.ZMM5B
    | 99 -> R.ZMM5C
    | 100 -> R.ZMM5D
    | 101 -> R.ZMM5E
    | 102 -> R.ZMM5F
    | 103 -> R.ZMM5G
    | 104 -> R.ZMM5H
    | 105 -> R.ZMM6A
    | 106 -> R.ZMM6B
    | 107 -> R.ZMM6C
    | 108 -> R.ZMM6D
    | 109 -> R.ZMM6E
    | 110 -> R.ZMM6F
    | 111 -> R.ZMM6G
    | 112 -> R.ZMM6H
    | 113 -> R.ZMM7A
    | 114 -> R.ZMM7B
    | 115 -> R.ZMM7C
    | 116 -> R.ZMM7D
    | 117 -> R.ZMM7E
    | 118 -> R.ZMM7F
    | 119 -> R.ZMM7G
    | 120 -> R.ZMM7H
    | 121 -> R.ZMM8A
    | 122 -> R.ZMM8B
    | 123 -> R.ZMM8C
    | 124 -> R.ZMM8D
    | 125 -> R.ZMM8E
    | 126 -> R.ZMM8F
    | 127 -> R.ZMM8G
    | 128 -> R.ZMM8H
    | 129 -> R.ZMM9A
    | 130 -> R.ZMM9B
    | 131 -> R.ZMM9C
    | 132 -> R.ZMM9D
    | 133 -> R.ZMM9E
    | 134 -> R.ZMM9F
    | 135 -> R.ZMM9G
    | 136 -> R.ZMM9H
    | 137 -> R.ZMM10A
    | 138 -> R.ZMM10B
    | 139 -> R.ZMM10C
    | 140 -> R.ZMM10D
    | 141 -> R.ZMM10E
    | 142 -> R.ZMM10F
    | 143 -> R.ZMM10G
    | 144 -> R.ZMM10H
    | 145 -> R.ZMM11A
    | 146 -> R.ZMM11B
    | 147 -> R.ZMM11C
    | 148 -> R.ZMM11D
    | 149 -> R.ZMM11E
    | 150 -> R.ZMM11F
    | 151 -> R.ZMM11G
    | 152 -> R.ZMM11H
    | 153 -> R.ZMM12A
    | 154 -> R.ZMM12B
    | 155 -> R.ZMM12C
    | 156 -> R.ZMM12D
    | 157 -> R.ZMM12E
    | 158 -> R.ZMM12F
    | 159 -> R.ZMM12G
    | 160 -> R.ZMM12H
    | 161 -> R.ZMM13A
    | 162 -> R.ZMM13B
    | 163 -> R.ZMM13C
    | 164 -> R.ZMM13D
    | 165 -> R.ZMM13E
    | 166 -> R.ZMM13F
    | 167 -> R.ZMM13G
    | 168 -> R.ZMM13H
    | 169 -> R.ZMM14A
    | 170 -> R.ZMM14B
    | 171 -> R.ZMM14C
    | 172 -> R.ZMM14D
    | 173 -> R.ZMM14E
    | 174 -> R.ZMM14F
    | 175 -> R.ZMM14G
    | 176 -> R.ZMM14H
    | 177 -> R.ZMM15A
    | 178 -> R.ZMM15B
    | 179 -> R.ZMM15C
    | 180 -> R.ZMM15D
    | 181 -> R.ZMM15E
    | 182 -> R.ZMM15F
    | 183 -> R.ZMM15G
    | 184 -> R.ZMM15H
    | 185 -> R.BND0A
    | 186 -> R.BND0B
    | 187 -> R.BND1A
    | 188 -> R.BND1B
    | 189 -> R.BND2A
    | 190 -> R.BND2B
    | 191 -> R.BND3A
    | 192 -> R.BND3B
    | 193 -> R.FCW
    | 194 -> R.FSW
    | 195 -> R.FTW
    | 196 -> R.FOP
    | 197 -> R.FIP
    | 198 -> R.FCS
    | 199 -> R.FDP
    | 200 -> R.FDS
    | 201 -> R.MXCSR
    | 202 -> R.MXCSRMASK
    | 203 -> R.PKRU
    | 204 -> R.DR0
    | 205 -> R.DR1
    | 206 -> R.DR2
    | 207 -> R.DR3
    | 208 -> R.DR6
    | 209 -> R.DR7
    | _ -> Utils.impossible ()
    |> Register.toRegID

  override __.ToString () =
    sprintf "IntelRegisterSet<%x, %x, %x, %x>" __.BitArray[0] __.BitArray[1]
      __.BitArray[2] __.BitArray[3]

[<RequireQualifiedAccess>]
module IntelRegisterSet =
  let singleton rid = IntelRegisterSet().Add(rid)
  let empty = IntelRegisterSet () :> RegisterSet

IntelSSELifter.fs
//这个模块实现了SSE指令集相关多媒体/SIMD指令的翻译。
//主要功能点:
//1. 定义向量寄存器访问和操作的翻译函数。
//2. 指令操作数多元组打包和解包函数。
//3. 每个具体SSE指令的翻译实现函数。
//4. 提供公用函数生成SIMD指令中间代码。
//翻译过程:
//1. 解析/翻译操作数获取中间表达式。
//2. 调用具体函数实现SIMD语义。 
//3. 多元组打包解包处理向量数据。
//4. 返回翻译后的IRBuilder。
//它给上层提供了SSE指令集统一翻译接口。
//与通用/MMX模块配合,完成x86多媒体指令翻译。
//是SSE体系结构翻译不可或缺的重要组成部分。

module internal B2R2.FrontEnd.BinLifter.Intel.SSELifter

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.Helper
open B2R2.FrontEnd.BinLifter.Intel.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel.MMXLifter

let buildMove ins insLen ctxt bufSize =
  let ir = IRBuilder (bufSize)
  let oprSize = getOperationSize ins
  !<ir insLen
  match oprSize with
  | 32<rt> | 64<rt> ->
    let struct (dst, src) = transTwoOprs ins insLen ctxt
    !!ir (dst := src)
  | 128<rt> | 256<rt> | 512<rt> ->
    let struct (dst, src) = getTwoOprs ins
    let dst = transOprToExprVec ins insLen ctxt dst
    let src = transOprToExprVec ins insLen ctxt src
    List.iter2 (fun d s -> !!ir (d := s)) dst src
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let movaps ins insLen ctxt = buildMove ins insLen ctxt 4

let movapd ins insLen ctxt = buildMove ins insLen ctxt 4

let movups ins insLen ctxt = buildMove ins insLen ctxt 4

let movupd ins insLen ctxt = buildMove ins insLen ctxt 4

let movhps ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src with
  | OprMem (_, _, _, 64<rt>), OprReg r ->
    let dst = transOprToExpr ins insLen ctxt dst
    !!ir (dst := getPseudoRegVar ctxt r 2)
  | OprReg r, OprMem (_, _, _, 64<rt>)->
    let src = transOprToExpr ins insLen ctxt src
    !!ir (getPseudoRegVar ctxt r 2 := src)
  | _ -> raise InvalidOperandException
  !>ir insLen

let movhpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src with
  | OprReg r, OprMem _ ->
    let src = transOprToExpr ins insLen ctxt src
    !!ir (getPseudoRegVar ctxt r 2 := src)
  | OprMem _, OprReg r ->
    let dst = transOprToExpr ins insLen ctxt dst
    !!ir (dst := getPseudoRegVar ctxt r 1)
  | _ -> raise InvalidOperandException
  !>ir insLen

let movhlps ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr128 ins insLen ctxt dst |> snd
  let src = transOprToExpr128 ins insLen ctxt src |> fst
  !<ir insLen
  !!ir (dst := src)
  !>ir insLen

let movlpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src with
  | OprReg r, OprMem _ ->
    let src = transOprToExpr ins insLen ctxt src
    !!ir (getPseudoRegVar ctxt r 1 := src)
  | OprMem _, OprReg r ->
    let dst = transOprToExpr ins insLen ctxt dst
    !!ir (dst := getPseudoRegVar ctxt r 1)
  | _ -> raise InvalidOperandException
  !>ir insLen

let movlps ins insLen ctxt = movlpd ins insLen ctxt

let movlhps ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr128 ins insLen ctxt dst |> fst
  let src = transOprToExpr128 ins insLen ctxt src |> snd
  !<ir insLen
  !!ir (dst := src)
  !>ir insLen

let movmskps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let srcB, srcA= transOprToExpr128 ins insLen ctxt src
  let oprSize = getOperationSize ins
  !<ir insLen
  let srcA = AST.concat (AST.extract srcA 1<rt> 63) (AST.extract srcA 1<rt> 31)
  let srcB = AST.concat (AST.extract srcB 1<rt> 63) (AST.extract srcB 1<rt> 31)
  !!ir (dst := AST.zext oprSize <| AST.concat srcB srcA)
  !>ir insLen

let movmskpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let src1, src2 = transOprToExpr128 ins insLen ctxt src
  let oprSize = getOperationSize ins
  !<ir insLen
  let src63 = AST.sext oprSize (AST.xthi 1<rt> src2)
  let src127 = (AST.sext oprSize (AST.xthi 1<rt> src1)) << AST.num1 oprSize
  !!ir (dst := src63 .| src127)
  !>ir insLen

let movss (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  match dst, src with
  | OprReg r1, OprReg r2 ->
    let dst = getPseudoRegVar ctxt r1 1 |> AST.xtlo 32<rt>
    let src = getPseudoRegVar ctxt r2 1 |> AST.xtlo 32<rt>
    !!ir (dst := src)
  | OprReg r1, OprMem _ ->
    let dst2, dst1 = getPseudoRegVar128 ctxt r1
    let src = transOprToExpr ins insLen ctxt src
    !!ir (dstAssign 32<rt> dst1 src)
    !!ir (dst2 := AST.num0 64<rt>)
  | OprMem _ , OprReg r1 ->
    let dst = transOprToExpr ins insLen ctxt dst
    let src = getPseudoRegVar ctxt r1 1 |> AST.xtlo 32<rt>
    !!ir (dstAssign 32<rt> dst src)
  | _ -> raise InvalidOperandException
  !>ir insLen

let movsd (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (4)
  if ins.Operands = NoOperand then
    GeneralLifter.movs ins insLen ctxt
  else
    let struct (dst, src) = getTwoOprs ins
    !<ir insLen
    match dst, src with
    | OprReg r1, OprReg r2 ->
      let dst = getPseudoRegVar ctxt r1 1
      let src = getPseudoRegVar ctxt r2 1
      !!ir (dst := src)
    | OprReg r1, OprMem _ ->
      let dst2, dst1 = getPseudoRegVar128 ctxt r1
      let src = transOprToExpr ins insLen ctxt src
      !!ir (dst1 := src)
      !!ir (dst2 := AST.num0 64<rt>)
    | OprMem _ , OprReg r1 ->
      let dst = transOprToExpr ins insLen ctxt dst
      let src = getPseudoRegVar ctxt r1 1
      !!ir (dstAssign 64<rt> dst src)
    | _ -> raise InvalidOperandException
    !>ir insLen

let addps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> (opP AST.fadd) 8

let addpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> (opP AST.fadd) 8

let private getFstOperand = function
  | OneOperand o -> o
  | TwoOperands (o, _) -> o
  | ThreeOperands (o, _, _) -> o
  | FourOperands (o, _, _, _) -> o
  | _ -> raise InvalidOperandException

let private getTwoSrcOperands = function
  | TwoOperands (op1, op2) -> (op1, op2)
  | ThreeOperands (_op1, op2, op3) -> (op2, op3)
  | _ -> raise InvalidOperandException

let private handleScalarFPOp (ins: InsInfo) insLen ctxt sz op =
  let ir = IRBuilder(8)
  let _dst2, dst1 =
    ins.Operands |> getFstOperand |> transOprToExpr128 ins insLen ctxt
  let src1, src2 = getTwoSrcOperands ins.Operands
  let src1 = transOprToExpr64 ins insLen ctxt src1
  let src2 =
    if sz = 32<rt> then transOprToExpr32 ins insLen ctxt src2
    else transOprToExpr64 ins insLen ctxt src2
  let dst1, src1 =
    if sz = 32<rt> then AST.xtlo 32<rt> dst1, AST.xtlo 32<rt> src1
    else dst1, src1
  let struct (t1, t2, t3) = tmpVars3 ir sz
  !<ir insLen
  !!ir (t1 := src1)
  !!ir (t2 := src2)
  !!ir (t3 := op t1 t2)
  !!ir (dst1 := t3)
  !>ir insLen

let addss ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 32<rt> AST.fadd

let addsd ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 64<rt> AST.fadd

let subps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> (opP AST.fsub) 8

let subpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  let dst1, dst2 = transOprToExpr128 ins insLen ctxt dst
  let src1, src2 = transOprToExpr128 ins insLen ctxt src
  !!ir (dst1 := dst1 .- src1)
  !!ir (dst2 := dst2 .- src2)
  !>ir insLen

let subss ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 32<rt> AST.fsub

let subsd ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 64<rt> AST.fsub

let mulps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> (opP AST.fmul) 8

let mulpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> (opP AST.fmul) 8

let mulss ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 32<rt> AST.fmul

let mulsd ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 64<rt> AST.fmul

let divps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> (opP AST.fdiv) 8

let divpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> (opP AST.fdiv) 8

let divss ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 32<rt> AST.fdiv

let divsd ins insLen ctxt =
  handleScalarFPOp ins insLen ctxt 64<rt> AST.fdiv

let rcpps ins insLen ctxt =
  let ir = IRBuilder(8)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt opr1
  let src2, src1 = transOprToExpr128 ins insLen ctxt opr2
  let dst1b, dst1a = AST.xthi 32<rt> dst1, AST.xtlo 32<rt> dst1
  let dst2b, dst2a = AST.xthi 32<rt> dst2, AST.xtlo 32<rt> dst2
  let src1b, src1a = AST.xthi 32<rt> src1, AST.xtlo 32<rt> src1
  let src2b, src2a = AST.xthi 32<rt> src2, AST.xtlo 32<rt> src2
  let tmp = !*ir 32<rt>
  let flt1 = numI32 0x3f800000 32<rt>
  !<ir insLen
  !!ir (dst1a := AST.fdiv flt1 src1a)
  !!ir (dst1b := AST.fdiv flt1 src1b)
  !!ir (dst2a := AST.fdiv flt1 src2a)
  !!ir (dst2b := AST.fdiv flt1 src2b)
  !>ir insLen

let rcpss ins insLen ctxt =
  let ir = IRBuilder(4)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst = transOprToExpr32 ins insLen ctxt opr1
  let src = transOprToExpr32 ins insLen ctxt opr2
  let tmp = !*ir 32<rt>
  let flt1 = numI32 0x3f800000 32<rt>
  !<ir insLen
  !!ir (dst := AST.fdiv flt1 src)
  !>ir insLen

let sqrtps ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt opr1
  let src2, src1 = transOprToExpr128 ins insLen ctxt opr2
  let struct (tmp1, tmp2, tmp3, tmp4) = tmpVars4 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src1)
  !!ir (tmp2 := AST.xthi 32<rt> src1)
  !!ir (tmp3 := AST.xtlo 32<rt> src2)
  !!ir (tmp4 := AST.xthi 32<rt> src2)
  !!ir (AST.xtlo 32<rt> dst1 := AST.unop UnOpType.FSQRT tmp1)
  !!ir (AST.xthi 32<rt> dst1 := AST.unop UnOpType.FSQRT tmp2)
  !!ir (AST.xtlo 32<rt> dst2 := AST.unop UnOpType.FSQRT tmp3)
  !!ir (AST.xthi 32<rt> dst2 := AST.unop UnOpType.FSQRT tmp4)
  !>ir insLen

let sqrtpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt opr1
  let src2, src1 = transOprToExpr128 ins insLen ctxt opr2
  !<ir insLen
  !!ir (dst1 := AST.unop UnOpType.FSQRT src1)
  !!ir (dst2 := AST.unop UnOpType.FSQRT src2)
  !>ir insLen

let sqrtss ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst = transOprToExpr32 ins insLen ctxt opr1
  let src = transOprToExpr32 ins insLen ctxt opr2
  !<ir insLen
  !!ir (dst := AST.unop UnOpType.FSQRT src)
  !>ir insLen

let sqrtsd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt opr1
  let src = transOprToExpr64 ins insLen ctxt opr2
  !<ir insLen
  !!ir (dst := AST.unop UnOpType.FSQRT src)
  !>ir insLen

let rsqrtps ins insLen ctxt =
  let ir = IRBuilder(16)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt opr1
  let src2, src1 = transOprToExpr128 ins insLen ctxt opr2
  let dst1b, dst1a = AST.xthi 32<rt> dst1, AST.xtlo 32<rt> dst1
  let dst2b, dst2a = AST.xthi 32<rt> dst2, AST.xtlo 32<rt> dst2
  let src1b, src1a = AST.xthi 32<rt> src1, AST.xtlo 32<rt> src1
  let src2b, src2a = AST.xthi 32<rt> src2, AST.xtlo 32<rt> src2
  let tmp = !*ir 32<rt>
  let flt1 = numI32 0x3f800000 32<rt>
  !<ir insLen
  !!ir (tmp := AST.unop UnOpType.FSQRT src1a)
  !!ir (dst1a := AST.fdiv flt1 tmp)
  !!ir (tmp := AST.unop UnOpType.FSQRT src1b)
  !!ir (dst1b := AST.fdiv flt1 tmp)
  !!ir (tmp := AST.unop UnOpType.FSQRT src2a)
  !!ir (dst2a := AST.fdiv flt1 tmp)
  !!ir (tmp := AST.unop UnOpType.FSQRT src2b)
  !!ir (dst2b := AST.fdiv flt1 tmp)
  !>ir insLen

let rsqrtss ins insLen ctxt =
  let ir = IRBuilder(4)
  let struct (opr1, opr2) = getTwoOprs ins
  let dst = transOprToExpr32 ins insLen ctxt opr1
  let src = transOprToExpr32 ins insLen ctxt opr2
  let tmp = !*ir 32<rt>
  let flt1 = numI32 0x3f800000 32<rt>
  !<ir insLen
  !!ir (tmp := AST.unop UnOpType.FSQRT src)
  !!ir (dst := AST.fdiv flt1 tmp)
  !>ir insLen

let private minMaxPS ins insLen ctxt compare =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let dst1A, dst1B = AST.xtlo 32<rt> dst1, AST.xthi 32<rt> dst1
  let dst2A, dst2B = AST.xtlo 32<rt> dst2, AST.xthi 32<rt> dst2
  let src1A, src1B = AST.xtlo 32<rt> src1, AST.xthi 32<rt> src1
  let src2A, src2B = AST.xtlo 32<rt> src2, AST.xthi 32<rt> src2
  let struct (val4, val3, val2, val1) = tmpVars4 ir 32<rt>
  !<ir insLen
  !!ir (val1 := AST.ite (compare dst1A src1A) dst1A src1A)
  !!ir (val2 := AST.ite (compare dst1B src1B) dst1B src1B)
  !!ir (val3 := AST.ite (compare dst2A src2A) dst2A src2A)
  !!ir (val4 := AST.ite (compare dst2B src2B) dst2B src2B)
  !!ir (dst1A := val1)
  !!ir (dst1B := val2)
  !!ir (dst2A := val3)
  !!ir (dst2B := val4)
  !>ir insLen

let private minMaxPD ins insLen ctxt compare =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let struct (val2, val1) = tmpVars2 ir 64<rt>
  !<ir insLen
  !!ir (val1 := AST.ite (compare dst1 src1) dst1 src1)
  !!ir (val2 := AST.ite (compare dst2 src2) dst2 src2)
  !!ir (dst1 := val1)
  !!ir (dst2 := val2)
  !>ir insLen

let private minMaxSS ins insLen ctxt compare =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr32 ins insLen ctxt dst
  let src = transOprToExpr32 ins insLen ctxt src
  let tmp = !*ir 32<rt>
  !<ir insLen
  !!ir (tmp := AST.ite (compare dst src) dst src)
  !!ir (dst := tmp)
  !>ir insLen

let private minMaxSD ins insLen ctxt compare =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let tmp = !*ir 64<rt>
  !<ir insLen
  !!ir (tmp := AST.ite (compare dst src) dst src)
  !!ir (dst := tmp)
  !>ir insLen

let maxps ins insLen ctxt =
  minMaxPS ins insLen ctxt AST.fgt

let maxpd ins insLen ctxt =
  minMaxPD ins insLen ctxt AST.fgt

let maxss ins insLen ctxt =
  minMaxSS ins insLen ctxt AST.fgt

let maxsd ins insLen ctxt =
  minMaxSD ins insLen ctxt AST.fgt

let minps ins insLen ctxt =
  minMaxPS ins insLen ctxt AST.flt

let minpd ins insLen ctxt =
  minMaxPD ins insLen ctxt AST.flt

let minss ins insLen ctxt =
  minMaxSS ins insLen ctxt AST.flt

let minsd ins insLen ctxt =
  minMaxSD ins insLen ctxt AST.flt

let cmpps ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (op1, op2, op3) = getThreeOprs ins
  let dst1, dst2 = transOprToExpr128 ins insLen ctxt op1
  let src1, src2 = transOprToExpr128 ins insLen ctxt op2
  let dst1A, dst1B = AST.xtlo 32<rt> dst1, AST.xthi 32<rt> dst1
  let dst2A, dst2B = AST.xtlo 32<rt> dst2, AST.xthi 32<rt> dst2
  let imm = transOprToExpr ins insLen ctxt op3 |> AST.xtlo 8<rt>
  let isNan expr =
    (AST.extract expr 8<rt> 23  == AST.num (BitVector.unsignedMax 8<rt>))
     .& (AST.xtlo 23<rt> expr != AST.num0 23<rt>)
  let cmpCond c expr1 expr2 =
    !!ir (c := AST.b0)
    !!ir (c := AST.ite (imm == AST.num0 8<rt>) (expr1 == expr2) c)
    !!ir (c := AST.ite (imm == AST.num1 8<rt>) (AST.flt expr1  expr2) c)
    !!ir (c := AST.ite (imm == numI32 2 8<rt>) (AST.fle expr1 expr2) c)
    !!ir (c := AST.ite (imm == numI32 3 8<rt>) (isNan expr1 .| isNan expr2) c)
    !!ir (c := AST.ite (imm == numI32 4 8<rt>) (expr1 != expr2) c)
    !!ir
      (c := AST.ite (imm == numI32 5 8<rt>) (AST.flt expr1 expr2 |> AST.not) c)
    !!ir
      (c := AST.ite (imm == numI32 6 8<rt>) (AST.fle expr1 expr2 |> AST.not) c)
    !!ir (c := AST.ite (imm == numI32 7 8<rt>)
                       (isNan expr1 .| isNan expr2 |> AST.not) c)
  let struct (cond1, cond2, cond3, cond4) = tmpVars4 ir 1<rt>
  !<ir insLen
  cmpCond cond1 dst1A (AST.xtlo 32<rt> src1)
  cmpCond cond2 dst1B (AST.xthi 32<rt> src1)
  cmpCond cond3 dst2A (AST.xtlo 32<rt> src2)
  cmpCond cond4 dst2B (AST.xthi 32<rt> src2)
  !!ir (dst1A := AST.ite cond1 (maxNum 32<rt>) (AST.num0 32<rt>))
  !!ir (dst1B := AST.ite cond2 (maxNum 32<rt>) (AST.num0 32<rt>))
  !!ir (dst2A := AST.ite cond3 (maxNum 32<rt>) (AST.num0 32<rt>))
  !!ir (dst2B := AST.ite cond4 (maxNum 32<rt>) (AST.num0 32<rt>))
  !>ir insLen

let cmppd ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (op1, op2, op3) = getThreeOprs ins
  let dst1, dst2 = transOprToExpr128 ins insLen ctxt op1
  let src1, src2 = transOprToExpr128 ins insLen ctxt op2
  let imm = transOprToExpr ins insLen ctxt op3 |> AST.xtlo 8<rt>
  let isNan expr =
    (AST.extract expr 11<rt> 52 == AST.num (BitVector.unsignedMax 11<rt>))
     .& (AST.xtlo 52<rt> expr != AST.num0 52<rt>)
  let cmpCond c expr1 expr2 =
    !!ir (c := AST.b0)
    !!ir (c := AST.ite (imm == AST.num0 8<rt>) (expr1 == expr2) c)
    !!ir (c := AST.ite (imm == AST.num1 8<rt>) (AST.flt expr1  expr2) c)
    !!ir (c := AST.ite (imm == numI32 2 8<rt>) (AST.fle expr1 expr2) c)
    !!ir (c := AST.ite (imm == numI32 3 8<rt>) (isNan expr1 .| isNan expr2) c)
    !!ir (c := AST.ite (imm == numI32 4 8<rt>) (expr1 != expr2) c)
    !!ir
      (c := AST.ite (imm == numI32 5 8<rt>) (AST.flt expr1 expr2 |> AST.not) c)
    !!ir
      (c := AST.ite (imm == numI32 6 8<rt>) (AST.fle expr1 expr2 |> AST.not) c)
    !!ir (c := AST.ite (imm == numI32 7 8<rt>)
                       (isNan expr1 .| isNan expr2 |> AST.not) c)
  let struct (cond1, cond2) = tmpVars2 ir 1<rt>
  !<ir insLen
  cmpCond cond1 dst1 src1
  cmpCond cond2 dst2 src2
  !!ir (dst1 := AST.ite cond1 (maxNum 64<rt>) (AST.num0 64<rt>))
  !!ir (dst2 := AST.ite cond2 (maxNum 64<rt>) (AST.num0 64<rt>))
  !>ir insLen

let cmpss ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src, imm) = getThreeOprs ins
  let dst = transOprToExpr32 ins insLen ctxt dst
  let src = transOprToExpr32 ins insLen ctxt src
  let imm = transOprToExpr ins insLen ctxt imm |> AST.xtlo 8<rt>
  let n num = numI32 num 8<rt>
  let max32 = maxNum 32<rt>
  let isNan expr =
    (AST.extract expr 8<rt> 23  == AST.num (BitVector.unsignedMax 8<rt>))
     .& (AST.xtlo 23<rt> expr != AST.num0 23<rt>)
  let cond = !*ir 1<rt>
  !<ir insLen
  !!ir (cond := (dst == src))
  !!ir (cond := AST.ite (imm == n 1) (AST.flt dst src) cond)
  !!ir (cond := AST.ite (imm == n 2) (AST.fle dst src) cond)
  !!ir (cond := AST.ite (imm == n 3) ((isNan dst) .| (isNan src)) cond)
  !!ir (cond := AST.ite (imm == n 4) (dst != src) cond)
  !!ir (cond := AST.ite (imm == n 5) (AST.flt dst src |> AST.not) cond)
  !!ir (cond := AST.ite (imm == n 6) (AST.fle dst src |> AST.not) cond)
  !!ir (cond := AST.ite (imm == n 7)
                          ((isNan dst) .| (isNan src) |> AST.not) cond)
  !!ir (dst := AST.ite cond max32 (AST.num0 32<rt>))
  !>ir insLen

let cmpsd (ins: InsInfo) insLen ctxt =
  match ins.Operands with
  | NoOperand -> GeneralLifter.cmps ins insLen ctxt
  | ThreeOperands (dst, src, imm) ->
    let ir = IRBuilder (16)
    let dst = transOprToExpr64 ins insLen ctxt dst
    let src = transOprToExpr64 ins insLen ctxt src
    let imm = transOprToExpr ins insLen ctxt imm |> AST.xtlo 8<rt>
    let n i = numI32 i 8<rt>
    let max64 = maxNum 64<rt>
    let isNan expr =
      (AST.extract expr 11<rt> 52  == AST.num (BitVector.unsignedMax 11<rt>))
       .& (AST.xtlo 52<rt> expr != AST.num0 52<rt>)
    let cond = !*ir 1<rt>
    !<ir insLen
    !!ir (cond := (dst == src))
    !!ir (cond := AST.ite (imm == n 1) (AST.flt dst src) cond)
    !!ir (cond := AST.ite (imm == n 2) (AST.fle dst src) cond)
    !!ir (cond := AST.ite (imm == n 3) ((isNan dst) .| (isNan src)) cond)
    !!ir (cond := AST.ite (imm == n 4) (dst != src) cond)
    !!ir (cond := AST.ite (imm == n 5) (AST.flt dst src |> AST.not) cond)
    !!ir (cond := AST.ite (imm == n 6) (AST.fle dst src |> AST.not) cond)
    !!ir (cond := AST.ite (imm == n 7)
                            ((isNan dst) .| (isNan src) |> AST.not) cond)
    !!ir (dst := AST.ite cond max64 (AST.num0 64<rt>))
    !>ir insLen
  | _ -> raise InvalidOperandException

let comiss ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (opr1, opr2) = getTwoOprs ins
  let opr1 = transOprToExpr32 ins insLen ctxt opr1
  let opr2 = transOprToExpr32 ins insLen ctxt opr2
  let lblNan = ir.NewSymbol "IsNan"
  let lblExit = ir.NewSymbol "Exit"
  let zf = !.ctxt R.ZF
  let pf = !.ctxt R.PF
  let cf = !.ctxt R.CF
  !<ir insLen
  !!ir (zf := AST.ite (opr1 == opr2) AST.b1 AST.b0)
  !!ir (pf := AST.b0)
  !!ir (cf := AST.ite (AST.flt opr1 opr2) AST.b1 AST.b0)
  let isNan expr =
    (AST.extract expr 8<rt> 23  == AST.num (BitVector.unsignedMax 8<rt>))
     .& (AST.xtlo 23<rt> expr != AST.num0 23<rt>)
  !!ir (AST.cjmp (isNan opr1 .| isNan opr2)
                 (AST.name lblNan) (AST.name lblExit))
  !!ir (AST.lmark lblNan)
  !!ir (zf := AST.b1)
  !!ir (pf := AST.b1)
  !!ir (cf := AST.b1)
  !!ir (AST.lmark lblExit)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !>ir insLen

let comisd ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (opr1, opr2) = getTwoOprs ins
  let opr1 = transOprToExpr64 ins insLen ctxt opr1
  let opr2 = transOprToExpr64 ins insLen ctxt opr2
  let lblNan = ir.NewSymbol "IsNan"
  let lblExit = ir.NewSymbol "Exit"
  let zf = !.ctxt R.ZF
  let pf = !.ctxt R.PF
  let cf = !.ctxt R.CF
  !<ir insLen
  !!ir (zf := AST.ite (opr1 == opr2) AST.b1 AST.b0)
  !!ir (pf := AST.b0)
  !!ir (cf := AST.ite (AST.flt opr1 opr2) AST.b1 AST.b0)
  let isNan expr =
    (AST.extract expr 11<rt> 52  == AST.num (BitVector.unsignedMax 11<rt>))
     .& (AST.xtlo 52<rt> expr != AST.num0 52<rt>)
  !!ir (AST.cjmp (isNan opr1 .| isNan opr2)
                 (AST.name lblNan) (AST.name lblExit))
  !!ir (AST.lmark lblNan)
  !!ir (zf := AST.b1)
  !!ir (pf := AST.b1)
  !!ir (cf := AST.b1)
  !!ir (AST.lmark lblExit)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !>ir insLen

let ucomiss ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (opr1, opr2) = getTwoOprs ins
  let opr1 = transOprToExpr32 ins insLen ctxt opr1
  let opr2 = transOprToExpr32 ins insLen ctxt opr2
  let lblNan = ir.NewSymbol "IsNan"
  let lblExit = ir.NewSymbol "Exit"
  let zf = !.ctxt R.ZF
  let pf = !.ctxt R.PF
  let cf = !.ctxt R.CF
  !<ir insLen
  !!ir (zf := AST.ite (opr1 == opr2) AST.b1 AST.b0)
  !!ir (pf := AST.b0)
  !!ir (cf := AST.ite (AST.flt opr1 opr2) AST.b1 AST.b0)
  let isNan expr =
    (AST.extract expr 8<rt> 23  == AST.num (BitVector.unsignedMax 8<rt>))
     .& (AST.xtlo 23<rt> expr != AST.num0 23<rt>)
  !!ir (AST.cjmp (isNan opr1 .| isNan opr2)
                 (AST.name lblNan) (AST.name lblExit))
  !!ir (AST.lmark lblNan)
  !!ir (zf := AST.b1)
  !!ir (pf := AST.b1)
  !!ir (cf := AST.b1)
  !!ir (AST.lmark lblExit)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !>ir insLen

let ucomisd ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (opr1, opr2) = getTwoOprs ins
  let opr1 = transOprToExpr64 ins insLen ctxt opr1
  let opr2 = transOprToExpr64 ins insLen ctxt opr2
  let lblNan = ir.NewSymbol "IsNan"
  let lblExit = ir.NewSymbol "Exit"
  let zf = !.ctxt R.ZF
  let pf = !.ctxt R.PF
  let cf = !.ctxt R.CF
  !<ir insLen
  !!ir (zf := AST.ite (opr1 == opr2) AST.b1 AST.b0)
  !!ir (pf := AST.b0)
  !!ir (cf := AST.ite (AST.flt opr1 opr2) AST.b1 AST.b0)
  let isNan expr =
    (AST.extract expr 11<rt> 52  == AST.num (BitVector.unsignedMax 11<rt>))
     .& (AST.xtlo 52<rt> expr != AST.num0 52<rt>)
  !!ir (AST.cjmp (isNan opr1 .| isNan opr2)
                 (AST.name lblNan) (AST.name lblExit))
  !!ir (AST.lmark lblNan)
  !!ir (zf := AST.b1)
  !!ir (pf := AST.b1)
  !!ir (cf := AST.b1)
  !!ir (AST.lmark lblExit)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !>ir insLen

let andps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPand 16

let andpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPand 16

let andnps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPandn 8

let andnpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPandn 8

let orps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPor 16

let orpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPor 16

let private opPxor _ = Array.map2 (.|)

let xorps ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPxor 16

let xorpd ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPxor 16

let shufps ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (dst, src, imm) = getThreeOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let imm = transOprToExpr ins insLen ctxt imm
  let dst1A, dst1B = AST.xtlo 32<rt> dst1, AST.xthi 32<rt> dst1
  let dst2A, dst2B = AST.xtlo 32<rt> dst2, AST.xthi 32<rt> dst2
  let src1A, src1B = AST.xtlo 32<rt> src1, AST.xthi 32<rt> src1
  let src2A, src2B = AST.xtlo 32<rt> src2, AST.xthi 32<rt> src2
  let doShuf cond dst e0 e1 e2 e3 =
    !!ir (dst := AST.num0 32<rt>)
    !!ir (dst := AST.ite (cond == AST.num0 2<rt>) e0 dst)
    !!ir (dst := AST.ite (cond == AST.num1 2<rt>) e1 dst)
    !!ir (dst := AST.ite (cond == numI32 2 2<rt>) e2 dst)
    !!ir (dst := AST.ite (cond == numI32 3 2<rt>) e3 dst)
  let cond1 = AST.xtlo 2<rt> imm
  let cond2 = AST.extract imm 2<rt> 2
  let cond3 = AST.extract imm 2<rt> 4
  let cond4 = AST.extract imm 2<rt> 6
  let struct (tmp1, tmp2, tmp3, tmp4) = tmpVars4 ir 32<rt>
  !<ir insLen
  doShuf cond1 tmp1 dst1A dst1B dst2A dst2B
  doShuf cond2 tmp2 dst1A dst1B dst2A dst2B
  doShuf cond3 tmp3 src1A src1B src2A src2B
  doShuf cond4 tmp4 src1A src1B src2A src2B
  !!ir (dst1A := tmp1)
  !!ir (dst1B := tmp2)
  !!ir (dst2A := tmp3)
  !!ir (dst2B := tmp4)
  !>ir insLen

let shufpd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let imm = transOprToExpr ins insLen ctxt imm
  let cond1 = AST.xtlo 1<rt> imm
  let cond2 = AST.extract imm 1<rt> 1
  !<ir insLen
  !!ir (dst1 := AST.ite cond1 dst2 dst1)
  !!ir (dst2 := AST.ite cond2 src2 src1)
  !>ir insLen

let unpckhps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, _src1 = transOprToExpr128 ins insLen ctxt src
  let dst1A, dst1B = AST.xtlo 32<rt> dst1, AST.xthi 32<rt> dst1
  let dst2A, dst2B = AST.xtlo 32<rt> dst2, AST.xthi 32<rt> dst2
  let src2A, src2B = AST.xtlo 32<rt> src2, AST.xthi 32<rt> src2
  !<ir insLen
  !!ir (dst1A := dst2A)
  !!ir (dst1B := src2A)
  !!ir (dst2A := dst2B)
  !!ir (dst2B := src2B)
  !>ir insLen

let unpckhpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, _src1 = transOprToExpr128 ins insLen ctxt src
  !<ir insLen
  !!ir (dst1 := dst2)
  !!ir (dst2 := src2)
  !>ir insLen

let unpcklps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let _src2, src1 = transOprToExpr128 ins insLen ctxt src
  let _dst1A, dst1B = AST.xtlo 32<rt> dst1, AST.xthi 32<rt> dst1
  let dst2A, dst2B = AST.xtlo 32<rt> dst2, AST.xthi 32<rt> dst2
  let src1A, src1B = AST.xtlo 32<rt> src1, AST.xthi 32<rt> src1
  !<ir insLen
  !!ir (dst2A := dst1B)
  !!ir (dst1B := src1A)
  !!ir (dst2B := src1B)
  !>ir insLen

let unpcklpd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let _src2, src1 = transOprToExpr128 ins insLen ctxt src
  !<ir insLen
  !!ir (dst2 := src1)
  !>ir insLen

let cvtpi2ps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let struct (tmp2, tmp1) = tmpVars2 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src)
  !!ir (tmp2 := AST.xthi 32<rt> src)
  !!ir (AST.xtlo 32<rt> dst := AST.cast CastKind.IntToFloat 32<rt> tmp1)
  !!ir (AST.xthi 32<rt> dst := AST.cast CastKind.IntToFloat 32<rt> tmp2)
  !>ir insLen

let cvtdq2pd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let struct (tmp1, tmp2) = tmpVars2 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src)
  !!ir (tmp2 := AST.xthi 32<rt> src)
  !!ir (dst1 := AST.cast CastKind.IntToFloat 64<rt> tmp1)
  !!ir (dst2 := AST.cast CastKind.IntToFloat 64<rt> tmp2)
  !>ir insLen

let cvtpi2pd ins insLen ctxt = cvtdq2pd ins insLen ctxt

let cvtsi2ss ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr ins insLen ctxt src
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dst := AST.cast CastKind.IntToFloat 32<rt> src)
  !>ir insLen

let cvtsi2sd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr ins insLen ctxt src
  !<ir insLen
  !!ir (dst := AST.cast CastKind.IntToFloat 64<rt> src)
  !>ir insLen

let cvtps2pi ins insLen ctxt rounded =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let struct (tmp1, tmp2) = tmpVars2 ir 32<rt>
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src)
  !!ir (tmp2 := AST.xthi 32<rt> src)
  !!ir (AST.xtlo 32<rt> dst := AST.cast castKind 32<rt> tmp1)
  !!ir (AST.xthi 32<rt> dst := AST.cast castKind 32<rt> tmp2)
  !>ir insLen

let cvtps2pd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let struct (tmp1, tmp2) = tmpVars2 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src)
  !!ir (tmp2 := AST.xthi 32<rt> src)
  !!ir (dst1 := AST.cast CastKind.FloatCast 64<rt> tmp1)
  !!ir (dst2 := AST.cast CastKind.FloatCast 64<rt> tmp2)
  !>ir insLen

let cvtpd2ps ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dst1 := AST.cast CastKind.FloatCast 32<rt> src1)
  !!ir (AST.xthi 32<rt> dst1 := AST.cast CastKind.FloatCast 32<rt> src2)
  !!ir (dst2 := AST.num0 64<rt>)
  !>ir insLen

let cvtpd2pi ins insLen ctxt rounded =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dst := AST.cast castKind 32<rt> src1)
  !!ir (AST.xthi 32<rt> dst := AST.cast castKind 32<rt> src2)
  !>ir insLen

let cvtpd2dq ins insLen ctxt rounded =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dst1 := AST.cast castKind 32<rt> src1)
  !!ir (AST.xthi 32<rt> dst1 := AST.cast castKind 32<rt> src2)
  !!ir (dst2 := AST.num0 64<rt>)
  !>ir insLen

let cvtdq2ps ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let struct (tmp1, tmp2, tmp3, tmp4) = tmpVars4 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src1)
  !!ir (tmp2 := AST.xthi 32<rt> src1)
  !!ir (tmp3 := AST.xtlo 32<rt> src2)
  !!ir (tmp4 := AST.xthi 32<rt> src2)
  !!ir (AST.xtlo 32<rt> dst1 := AST.cast CastKind.IntToFloat 32<rt> tmp1)
  !!ir (AST.xthi 32<rt> dst1 := AST.cast CastKind.IntToFloat 32<rt> tmp2)
  !!ir (AST.xtlo 32<rt> dst2 := AST.cast CastKind.IntToFloat 32<rt> tmp3)
  !!ir (AST.xthi 32<rt> dst2 := AST.cast CastKind.IntToFloat 32<rt> tmp4)
  !>ir insLen

let cvtps2dq ins insLen ctxt rounded =
  let ir = IRBuilder (16)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let struct (tmp1, tmp2, tmp3, tmp4) = tmpVars4 ir 32<rt>
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src1)
  !!ir (tmp2 := AST.xthi 32<rt> src1)
  !!ir (tmp3 := AST.xtlo 32<rt> src2)
  !!ir (tmp4 := AST.xthi 32<rt> src2)
  !!ir (AST.xtlo 32<rt> dst1 := AST.cast castKind 32<rt> tmp1)
  !!ir (AST.xthi 32<rt> dst1 := AST.cast castKind 32<rt> tmp2)
  !!ir (AST.xtlo 32<rt> dst2 := AST.cast castKind 32<rt> tmp3)
  !!ir (AST.xthi 32<rt> dst2 := AST.cast castKind 32<rt> tmp4)
  !>ir insLen

let cvtss2si ins insLen ctxt rounded =
  let ir = IRBuilder (4)
  let oprSize = getOperationSize ins
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let src = transOprToExpr32 ins insLen ctxt src
  let tmp = !*ir 32<rt>
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  !<ir insLen
  if is64bit ctxt && oprSize = 64<rt> then
    !!ir (dst := AST.cast castKind 64<rt> src)
  else
    !!ir (tmp := AST.cast castKind 32<rt> src)
    !!ir (dstAssign 32<rt> dst tmp)
  !>ir insLen

let cvtss2sd ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr32 ins insLen ctxt src
  !<ir insLen
  !!ir (dst := AST.cast CastKind.FloatCast 64<rt> src)
  !>ir insLen

let cvtsd2ss ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  !<ir insLen
  !!ir (AST.xtlo 32<rt> dst := AST.cast CastKind.FloatCast 32<rt> src)
  !>ir insLen

let cvtsd2si ins insLen ctxt rounded =
  let ir = IRBuilder (8)
  let oprSize = getOperationSize ins
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let castKind = if rounded then CastKind.FtoIRound else CastKind.FtoITrunc
  let tmp = !*ir 32<rt>
  !<ir insLen
  if is64bit ctxt && oprSize = 64<rt> then
    !!ir (dst := AST.cast castKind 64<rt> src)
  else
    !!ir (tmp := AST.cast castKind 32<rt> src)
    !!ir (dstAssign 32<rt> dst tmp)
  !>ir insLen

let ldmxcsr ins insLen ctxt =
  let ir = IRBuilder (4)
  let src = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (!.ctxt R.MXCSR := src)
  !>ir insLen

let stmxcsr ins insLen ctxt =
  let ir = IRBuilder (4)
  let dst = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (dst := !.ctxt R.MXCSR)
  !>ir insLen

let private opAveragePackedInt (packSz: int<rt>) =
  let dblSz = packSz * 2
  let dblExt expr = AST.zext dblSz expr
  let avg e1 e2 =
    AST.extract (dblExt e1 .+ dblExt e2 .+ AST.num1 dblSz) packSz 1
  Array.map2 avg

let private opPavgb _ = opAveragePackedInt 8<rt>

let pavgb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPavgb 64

let private opPavgw _ = opAveragePackedInt 16<rt>

let pavgw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPavgw 32

let pextrw ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, count) = getThreeOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let count = getImmValue count
  let oprSize = getOperationSize ins
  !<ir insLen
  match src with
  | OprReg reg ->
    match Register.getKind reg with
    | Register.Kind.MMX ->
      let src = transOprToExpr ins insLen ctxt src
      let count = count &&& 0b11 (* COUNT[1:0] *)
      let sel = !*ir 64<rt>
      !!ir (sel := numI64 count 64<rt>)
      let t = (src >> (sel .* numU32 16u 64<rt>)) .& numU32 0xFFFFu 64<rt>
      !!ir (dstAssign oprSize dst (AST.xtlo oprSize t))
    | Register.Kind.XMM ->
      let srcB, srcA = getPseudoRegVar128 ctxt reg
      let count = (count &&& 0b111) (* COUNT[2:0] *) * 16L
      let lAmt = numI64 (64L - (count % 64L)) 64<rt> (* Left Shift *)
      let rAmt = numI64 (count % 64L) 64<rt> (* Right Shift *)
      let result =
        if count < 64 then
          ((srcB << lAmt) .| (srcA >> rAmt)) .& numU32 0xFFFFu 64<rt>
        else (srcB >> rAmt) .& numU32 0xFFFFu 64<rt>
      !!ir (dstAssign oprSize dst (AST.xtlo 16<rt> result))
    | _ -> raise InvalidRegisterException
  | _ -> raise InvalidOperandException
  !>ir insLen

let pinsrw ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, count) = getThreeOprs ins
  let src = transOprToExpr ins insLen ctxt src
  let sel = !*ir 64<rt>
  !<ir insLen
  match dst with
  | OprReg reg ->
    match Register.getKind reg with
    | Register.Kind.MMX ->
      let dst = transOprToExpr ins insLen ctxt dst
      let count = transOprToExpr ins insLen ctxt count
      let mask = !*ir 64<rt>
      !!ir (sel := count .| numI64 3L 64<rt>)
      let pos = sel .* numU64 0x10UL 64<rt>
      !!ir (mask := (numU64 0xffffUL 64<rt>) << pos)
      !!ir
        (dst := (dst .& (AST.not mask)) .| (AST.zext 64<rt> src << pos .& mask))
    | Register.Kind.XMM ->
      let dst1, dst2 = transOprToExpr128 ins insLen ctxt dst
      let mask = !*ir 64<rt>
      let count = getImmValue count
      !!ir (sel := numI64 count 64<rt> .| numI64 7L 64<rt>)
      if count > 3L then
        let pos = (sel .- numI32 4 64<rt>) .* numI32 16 64<rt>
        !!ir (mask := (numU64 0xffffUL 64<rt>) << pos)
        !!ir (dst1 := (dst1 .& (AST.not mask))
                            .| (AST.zext 64<rt> src << pos .& mask))
      else
        let pos = sel .* numI32 16 64<rt>
        !!ir (mask := (numU64 0xffffUL 64<rt>) << pos)
        !!ir (dst2 := (dst2 .& (AST.not mask))
                            .| (AST.zext 64<rt> src << pos .& mask))
    | _ -> raise InvalidOperandSizeException
  | _ -> raise InvalidOperandException
  !>ir insLen

let private opMaxMinPacked cmp =
  Array.map2 (fun e1 e2 -> AST.ite (cmp e1 e2) e1 e2)

let private opPmaxub _ = opMaxMinPacked AST.gt

let pmaxub ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPmaxub 64

let private opPmaxsw _ = opMaxMinPacked AST.sgt

let pmaxsw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPmaxsw 32

let private opPmaxsb _ = opMaxMinPacked AST.sgt

let pmaxsb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPmaxsb 64

let opPminub _ = opMaxMinPacked AST.lt

let pminub ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPminub 64

let private opPminsw _ = opMaxMinPacked AST.slt

let pminsw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPminsw 32

let opPminud _ = opMaxMinPacked AST.lt

let pminud ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 32<rt> opPminud 32

let private opPminsb _ = opMaxMinPacked AST.slt

let pminsb ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPminsb 32

let private mskArrayInit cnt src =
  Array.init cnt (fun i -> AST.extract src 1<rt> (i * 8 + 7))

let private concatBits (bitExprs: Expr[]) =
  let head = bitExprs[0]
  let tail = bitExprs[1..]
  let rt = RegType.fromBitWidth bitExprs.Length
  tail
  |> Array.foldi (fun acc i bitExpr ->
    let e = AST.zext rt bitExpr
    acc .| (e << (numI32 (i + 1) rt))
  ) (AST.zext rt head)
  |> fst

let pmovmskb ins insLen ctxt =
  let ir = IRBuilder (4)
  let oprSize = getOperationSize ins
  let struct (dst, src) = getTwoOprs ins
  !<ir insLen
  let r = match src with | OprReg r -> r | _ -> raise InvalidOperandException
  match Register.getKind r with
  | Register.Kind.MMX ->
    let struct (dst, src) = transTwoOprs ins insLen ctxt
    let srcSize = TypeCheck.typeOf src
    let cnt = RegType.toByteWidth srcSize
    let tmps = mskArrayInit cnt src
    !!ir (dstAssign oprSize dst <| AST.zext oprSize (concatBits tmps))
  | Register.Kind.XMM ->
    let dst = transOprToExpr ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let srcSize = TypeCheck.typeOf srcA
    let cnt = RegType.toByteWidth srcSize
    let tmpsA = mskArrayInit cnt srcA
    let tmpsB = mskArrayInit cnt srcB
    let tmps = AST.concat (concatBits tmpsB) (concatBits tmpsA)
    !!ir (dstAssign oprSize dst <| AST.zext oprSize tmps)
  | Register.Kind.YMM ->
    let dst = transOprToExpr ins insLen ctxt dst
    let srcD, srcC, srcB, srcA = transOprToExpr256 ins insLen ctxt src
    let srcSize = TypeCheck.typeOf srcA
    let cnt = RegType.toByteWidth srcSize
    let tmpsA = mskArrayInit cnt srcA
    let tmpsB = mskArrayInit cnt srcB
    let tmpsC = mskArrayInit cnt srcC
    let tmpsD = mskArrayInit cnt srcD
    let tmps =
      AST.concat (AST.concat (concatBits tmpsD) (concatBits tmpsC))
        (AST.concat (concatBits tmpsB) (concatBits tmpsA))
    !!ir (dstAssign oprSize dst <| AST.zext oprSize tmps)
  | _ -> raise InvalidOperandException
  !>ir insLen

let private opPmulhuw _ = opPmul AST.xthi AST.zext 32<rt> 16<rt>

let pmulhuw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 16<rt> opPmulhuw 32

let private opPsadbw _ =
  let abs expr = AST.ite (AST.lt expr (AST.num0 8<rt>)) (AST.neg expr) (expr)
  Array.map2 (fun e1 e2 -> abs (e1 .- e2))

let psadbw ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 8<rt> opPsadbw 64

let pshufw ins insLen ctxt =
  let struct (dst, src, ord) = transThreeOprs ins insLen ctxt
  let oprSize = getOperationSize ins
  let cnt = RegType.toBitWidth oprSize / 16
  let ir = IRBuilder (2 * cnt)
  !<ir insLen
  let tmps = Array.init cnt (fun _ -> !*ir 16<rt>)
  let n16 = numI32 16 oprSize
  let mask2 = numI32 3 16<rt> (* 2-bit mask *)
  for i in 1 .. cnt do
    let order =
      ((AST.xtlo 16<rt> ord) >> (numI32 ((i - 1) * 2) 16<rt>)) .& mask2
    let order' = AST.zext oprSize order
    !!ir (tmps[i - 1] := AST.xtlo 16<rt> (src >> (order' .* n16)))
  done
  !!ir (dst := AST.concatArr tmps)
  !>ir insLen

let pshufd ins insLen ctxt =
  let struct (dst, src, ord) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let srcB, srcA = transOprToExpr128 ins insLen ctxt src
  let ord = getImmValue ord
  let oprSize = getOperationSize ins
  let cnt = RegType.toBitWidth oprSize / 32
  let ir = IRBuilder (2 * cnt)
  let rShiftTo64 hiExpr lowExpr amount =
    let rightAmt = numI64 (amount % 64L) 64<rt>
    let leftAmt = numI64 (64L - (amount % 64L)) 64<rt>
    if amount < 64L then
      AST.xtlo 32<rt> ((hiExpr << leftAmt) .| (lowExpr >> rightAmt))
    elif amount < 128 then AST.xtlo 32<rt> (hiExpr >> rightAmt)
    else AST.num0 32<rt>
  let amount idx = ((ord >>> (idx * 2)) &&& 0b11L) * 32L
  let struct (tSrcB, tSrcA) = tmpVars2 ir 64<rt>
  !<ir insLen
  !!ir (tSrcA := srcA)
  !!ir (tSrcB := srcB)
  let src amtIdx = rShiftTo64 tSrcB tSrcA (amount amtIdx)
  !!ir (dstA := AST.concat (src 1) (src 0))
  !!ir (dstB := AST.concat (src 3) (src 2))
  !>ir insLen

let pshuflw ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let srcB, srcA = transOprToExpr128 ins insLen ctxt src
  let imm = numI64 (getImmValue imm) 64<rt>
  !<ir insLen
  let tmps = Array.init 4 (fun _ -> !*ir 16<rt>)
  let n16 = numI32 16 64<rt>
  let mask2 = numI32 3 64<rt> (* 2-bit mask *)
  for i in 1 .. 4 do
    let imm =
      (imm >> (numI32 ((i - 1) * 2) 64<rt>)) .& mask2
    !!ir (tmps[i - 1] := AST.xtlo 16<rt> (srcA >> (imm .* n16)))
  done
  !!ir (dstA := AST.concatArr tmps)
  !!ir (dstB := srcB)
  !>ir insLen

let pshufhw ins insLen ctxt =
  let struct (dst, src, imm) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let srcB, srcA = transOprToExpr128 ins insLen ctxt src
  let imm = numI64 (getImmValue imm) 64<rt>
  let ir = IRBuilder (8)
  !<ir insLen
  let tmps = Array.init 4 (fun _ -> !*ir 16<rt>)
  let n16 = numI32 16 64<rt>
  let mask2 = numI32 3 64<rt> (* 2-bit mask *)
  for i in 1 .. 4 do
    let imm =
      (imm >> (numI32 ((i - 1) * 2) 64<rt>)) .& mask2
    !!ir (tmps[i - 1] := AST.xtlo 16<rt> (srcB >> (imm .* n16)))
  done
  !!ir (dstA := srcA)
  !!ir (dstB := AST.concatArr tmps)
  !>ir insLen

let pshufb ins insLen ctxt =
  let oprSize = getOperationSize ins
  let cnt = RegType.toBitWidth oprSize / 8
  let ir = IRBuilder (2 * cnt)
  !<ir insLen
  let mask = numI32 (cnt - 1) 8<rt>
  let n0 = AST.num0 8<rt>
  match oprSize with
  | 64<rt> ->
    let struct (dst, src) = transTwoOprs ins insLen ctxt
    let tmps = Array.init cnt (fun _ -> !*ir 8<rt>)
    for i in 0 .. cnt - 1 do
      let cond = AST.extract src 1<rt> (i * 8 + 7)
      let idx = (AST.extract src 8<rt> (i * 8)) .& mask
      let numShift = AST.zext oprSize idx .* numI32 8 oprSize
      !!ir
        (tmps[i] :=
          AST.ite cond n0 (AST.xtlo 8<rt> (dst >> numShift)))
    done
    !!ir (dst := AST.concatArr tmps)
  | 128<rt> ->
    let struct (dst, src) = getTwoOprs ins
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let highTmps = Array.init (cnt / 2) (fun _ -> !*ir 8<rt>)
    let lowTmps = Array.init (cnt / 2) (fun _ -> !*ir 8<rt>)
    let struct (tDst, tSrc) = tmpVars2 ir 64<rt>
    for i in 0 .. cnt - 1 do
      !!ir (tSrc := if i < 8 then srcA else srcB)
      let cond = AST.extract tSrc 1<rt> (((i * 8) % 64) + 7)
      let idx = (AST.extract tSrc 8<rt> ((i * 8) % 64)) .& mask
      let numShift =
        ((AST.zext 64<rt> idx) .* (numI32 8 64<rt>)) .% (numI32 64 64<rt>)
      !!ir (tDst := AST.ite (idx .< numI32 8 8<rt>) dstA dstB)
      let temp = AST.xtlo 8<rt> (tDst >> numShift)
      if i < 8 then !!ir (lowTmps[i] := AST.ite cond n0 temp)
      else !!ir (highTmps[i - 8] := AST.ite cond n0 temp)
    done
    !!ir (dstA := AST.concatArr lowTmps)
    !!ir (dstB := AST.concatArr highTmps)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let movdqa ins insLen ctxt =
  buildMove ins insLen ctxt 4

let movdqu ins insLen ctxt =
  buildMove ins insLen ctxt 4

let movq2dq ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src = transOprToExpr ins insLen ctxt src
  !<ir insLen
  !!ir (dstA := src)
  !!ir (dstB := AST.num0 64<rt>)
  !>ir insLen

let movdq2q ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst = transOprToExpr ins insLen ctxt dst
  let _, srcA = transOprToExpr128 ins insLen ctxt src
  !<ir insLen
  !!ir (dst := srcA)
  !>ir insLen

let private opPmuludq _ =
  let low32 expr = expr .& numI64 0xffffffffL 64<rt>
  Array.map2 (fun e1 e2 -> low32 e1 .* low32 e2)

let pmuludq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPmuludq 8

let paddq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> (opP (.+)) 8

let psubq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPsub 8

let pslldq ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, cnt) = getTwoOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let cnt = getImmValue cnt
  let amount = if cnt > 15L then 16L * 8L else cnt * 8L
  let rightAmt = numI64 (64L - (amount % 64L)) 64<rt>
  let leftAmt = numI64 (amount % 64L) 64<rt>
  let struct (tDstB, tDstA) = tmpVars2 ir 64<rt>
  !<ir insLen
  !!ir (tDstA := dstA)
  !!ir (tDstB := dstB)
  if amount < 64 then
    !!ir (dstA := tDstA << leftAmt)
    !!ir (dstB := (tDstB << leftAmt) .| (tDstA >> rightAmt))
  elif amount < 128 then
    !!ir (dstA := AST.num0 64<rt>)
    !!ir (dstB := tDstA << leftAmt)
  else
    !!ir (dstA := AST.num0 64<rt>)
    !!ir (dstB := AST.num0 64<rt>)
  !>ir insLen

let psrldq ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, cnt) = getTwoOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let cnt = getImmValue cnt
  let amount = if cnt > 15L then 16L * 8L else cnt * 8L
  let rightAmt = numI64 (amount % 64L) 64<rt>
  let leftAmt = numI64 (64L - (amount % 64L)) 64<rt>
  let struct (tDstB, tDstA) = tmpVars2 ir 64<rt>
  !<ir insLen
  !!ir (tDstA := dstA)
  !!ir (tDstB := dstB)
  if amount < 64 then
    !!ir (dstA := (tDstB << leftAmt) .| (tDstA >> rightAmt))
    !!ir (dstB := tDstB >> rightAmt)
  elif amount < 128 then
    !!ir (dstA := tDstB >> rightAmt)
    !!ir (dstB := AST.num0 64<rt>)
  else
    !!ir (dstA := AST.num0 64<rt>)
    !!ir (dstB := AST.num0 64<rt>)
  !>ir insLen

let punpckhqdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPunpckHigh 8

let punpcklqdq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPunpckLow 8

let movntq ins insLen ctxt = buildMove ins insLen ctxt 4

let movntps ins insLen ctxt = buildMove ins insLen ctxt 4

let movntpd ins insLen ctxt = buildMove ins insLen ctxt 4

let movntdq ins insLen ctxt = buildMove ins insLen ctxt 4

let movnti ins insLen ctxt = buildMove ins insLen ctxt 4

let lddqu ins insLen ctxt = buildMove ins insLen ctxt 4

let movshdup ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let struct (tmp1, tmp2) = tmpVars2 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xthi 32<rt> src1)
  !!ir (tmp2 := AST.xthi 32<rt> src2)
  !!ir (AST.xtlo 32<rt> dst1 := tmp1)
  !!ir (AST.xthi 32<rt> dst1 := tmp1)
  !!ir (AST.xtlo 32<rt> dst2 := tmp2)
  !!ir (AST.xthi 32<rt> dst2 := tmp2)
  !>ir insLen

let movsldup ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src) = getTwoOprs ins
  let dst2, dst1 = transOprToExpr128 ins insLen ctxt dst
  let src2, src1 = transOprToExpr128 ins insLen ctxt src
  let struct (tmp1, tmp2) = tmpVars2 ir 32<rt>
  !<ir insLen
  !!ir (tmp1 := AST.xtlo 32<rt> src1)
  !!ir (tmp2 := AST.xtlo 32<rt> src2)
  !!ir (AST.xtlo 32<rt> dst1 := tmp1)
  !!ir (AST.xthi 32<rt> dst1 := tmp1)
  !!ir (AST.xtlo 32<rt> dst2 := tmp2)
  !!ir (AST.xthi 32<rt> dst2 := tmp2)
  !>ir insLen

let movddup ins insLen ctxt =
  let ir = IRBuilder (4)
  let struct (dst, src) = getTwoOprs ins
  let dst1, dst0 = transOprToExpr128 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  !<ir insLen
  !!ir (dst0 := src)
  !!ir (dst1 := src)
  !>ir insLen

let palignr ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let imm8 = getImmValue imm
  let amount = imm8 * 8L
  let rightAmt = numI64 (amount % 64L) 64<rt>
  let leftAmt = numI64 (64L - (amount % 64L)) 64<rt>
  !<ir insLen
  match getOperationSize ins with
  | 64<rt> ->
    let dst = transOprToExpr ins insLen ctxt dst
    let src = transOprToExpr ins insLen ctxt src
    let struct (tDst, tSrc) = tmpVars2 ir 64<rt>
    !!ir (tDst := dst)
    !!ir (tSrc := src)
    if amount < 64 then !!ir (dst := (tDst << leftAmt) .| (tSrc >> rightAmt))
    elif amount < 128 then !!ir (dst := tDst >> rightAmt)
    else !!ir (dst := AST.num0 64<rt>)
  | 128<rt> ->
    let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
    let srcB, srcA = transOprToExpr128 ins insLen ctxt src
    let struct (tDstB, tDstA, tSrcB, tSrcA) = tmpVars4 ir 64<rt>
    !!ir (tDstA := dstA)
    !!ir (tDstB := dstB)
    !!ir (tSrcA := srcA)
    !!ir (tSrcB := srcB)
    if amount < 64 then
      !!ir (dstA := (tSrcB << leftAmt) .| (tSrcA >> rightAmt))
      !!ir (dstB := (tDstA << leftAmt) .| (tSrcB >> rightAmt))
    elif amount < 128 then
      !!ir (dstA := (tDstA << leftAmt) .| (tSrcB >> rightAmt))
      !!ir (dstB := (tDstB << leftAmt) .| (tDstA >> rightAmt))
    elif amount < 192 then
      !!ir (dstA := (tDstB << leftAmt) .| (tDstA >> rightAmt))
      !!ir (dstB := tDstB >> rightAmt)
    elif amount < 256 then
      !!ir (dstA := tDstB >> rightAmt)
      !!ir (dstB := AST.num0 64<rt>)
    else
      !!ir (dstA := AST.num0 64<rt>)
      !!ir (dstB := AST.num0 64<rt>)
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let roundsd ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, imm) = getThreeOprs ins
  let dst = transOprToExpr64 ins insLen ctxt dst
  let src = transOprToExpr64 ins insLen ctxt src
  let imm = transOprToExpr ins insLen ctxt imm
  let rc = AST.extract (!.ctxt R.FCW) 2<rt> 10
  let tmp = !*ir 2<rt>
  let cster castKind = AST.cast castKind 64<rt> src
  !<ir insLen
  !!ir (tmp := AST.ite (AST.extract imm 1<rt> 2) rc (AST.xtlo 2<rt> imm))
  !!ir (dst := AST.num0 64<rt>)
  !!ir (dst := AST.ite (tmp == AST.num0 2<rt>) (cster CastKind.FtoIRound) dst)
  !!ir (dst := AST.ite (tmp == AST.num1 2<rt>) (cster CastKind.FtoIFloor) dst)
  !!ir (dst := AST.ite (tmp == numI32 2 2<rt>) (cster CastKind.FtoICeil) dst)
  !!ir (dst := AST.ite (tmp == numI32 3 2<rt>) (cster CastKind.FtoITrunc) dst)
  !>ir insLen

let pinsrb ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (dst, src, count) = getThreeOprs ins
  let dstB, dstA = transOprToExpr128 ins insLen ctxt dst
  let src = transOprToExpr ins insLen ctxt src
  let sel = getImmValue count &&& 0b1111L (* COUNT[3:0] *)
  let mask = numI64 (0xFFL <<< ((int32 sel * 8) % 64)) 64<rt>
  let amount = sel * 8L
  let t = !*ir 64<rt>
  let expAmt = numI64 (amount % 64L) 64<rt>
  !<ir insLen
  !!ir (t := ((AST.zext 64<rt> (AST.xtlo 8<rt> src)) << expAmt) .& mask)
  if amount < 64 then !!ir (dstA := (dstA .& (AST.not mask)) .& t)
  else !!ir (dstB := (dstB .& (AST.not mask)) .& t)
  !>ir insLen

let ptest ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (src1, src2) = getTwoOprs ins
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
  let struct (t1, t2, t3, t4) = tmpVars4 ir 64<rt>
  !<ir insLen
  !!ir (t1 := src2A .& src1A)
  !!ir (t2 := src2B .& src1B)
  !!ir (!.ctxt R.ZF := (t1 .| t2) == (AST.num0 64<rt>))
  !!ir (t3 := src2A .& AST.not src1A)
  !!ir (t4 := src2B .& AST.not src1B)
  !!ir (!.ctxt R.CF := (t3 .| t4) == (AST.num0 64<rt>))
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.OF := AST.b0)
  !!ir (!.ctxt R.PF := AST.b0)
  !!ir (!.ctxt R.SF := AST.b0)
  !>ir insLen

let opPcmpeqq _ = opPcmp 64<rt> (==)

let pcmpeqq ins insLen ctxt =
  buildPackedInstr ins insLen ctxt 64<rt> opPcmpeqq 8

/// XXX (cleanup required)
/// imm8 control byte operation for PCMPESTRI, PCMPESTRM, etc..
/// See Chapter 4.1 of the manual vol. 2B.
type Imm8ControlByte = {
  PackSize   : RegType
  NumElems   : uint32
  Sign       : Sign
  Agg        : Agg
  Polarity   : Polarity
  OutSelect  : OutSelect
  Len        : Length
  Ret        : Return
}

and Sign =
  | Signed
  | UnSigned

and Agg =
  | EqualAny
  | Ranges
  | EqualEach
  | EqualOrdered

and Polarity =
  | PosPolarity
  | NegPolarity
  | PosMasked
  | NegMasked

and OutSelect =
  | Least
  | Most

and Length =
  | Implicit
  | Explicit

and Return =
  | Index
  | Mask

let private getPcmpstrInfo opCode (imm: Expr) =
  let immByte = match imm.E with
                | Num n -> BitVector.getValue n
                | _ -> raise InvalidExprException
  let agg = match (immByte >>> 2) &&& 3I with
            | v when v = 0I -> EqualAny
            | v when v = 1I -> Ranges
            | v when v = 2I -> EqualEach
            | v when v = 3I -> EqualOrdered
            | _ -> Utils.impossible ()
  let pol = match (immByte >>> 4) &&& 3I with
            | v when v = 0I -> PosPolarity
            | v when v = 1I -> NegPolarity
            | v when v = 2I -> PosMasked
            | v when v = 3I -> NegMasked
            | _ -> Utils.impossible ()
  let size, nElem =
    if immByte &&& 1I = 0I then 8<rt>, 16u else 16<rt>, 8u
  let len, ret =
    match opCode with
    | Opcode.PCMPISTRI | Opcode.VPCMPISTRI -> Implicit, Index
    | Opcode.PCMPESTRI | Opcode.VPCMPESTRI -> Explicit, Index
    | Opcode.PCMPISTRM | Opcode.VPCMPISTRM -> Implicit, Mask
    | Opcode.PCMPESTRM | Opcode.VPCMPESTRM -> Explicit, Mask
    | _ -> raise InvalidOpcodeException
  { PackSize = size
    NumElems = nElem
    Sign = if (immByte >>> 1) &&& 1I = 0I then UnSigned else Signed
    Agg = agg
    Polarity = pol
    OutSelect = if (immByte >>> 6) &&& 1I = 0I then Least else Most
    Len = len
    Ret = ret }

let private explicitValidCheck ctrl reg rSz ir =
  let tmps = [| for _ in 1u .. ctrl.NumElems -> !*ir 1<rt> |]
  let checkNum = numU32 ctrl.NumElems rSz
  let rec getValue idx =
    let v = AST.lt (numU32 idx rSz) (AST.ite (AST.lt checkNum reg) checkNum reg)
    if idx = ctrl.NumElems then ()
    else !!ir (tmps[int idx] := v)
         getValue (idx + 1u)
  getValue 0u
  tmps

let private implicitValidCheck ctrl srcB srcA ir =
  let unitWidth = RegType.toBitWidth ctrl.PackSize
  let tmps = [| for _ in 1u .. ctrl.NumElems -> !*ir 1<rt> |]
  let getSrc idx e = AST.extract e ctrl.PackSize (unitWidth * idx)
  let rec getValue idx =
    if idx = int ctrl.NumElems then ()
    else
      let half = int ctrl.NumElems / 2
      let e, amount = if idx < half then srcA, idx else srcB, idx - half
      let v e = tmps[idx - 1] .& (getSrc amount e != AST.num0 ctrl.PackSize)
      !!ir (tmps[idx] := v e)
      getValue (idx + 1)
  !!ir (tmps[0] := AST.b1 .& (getSrc 0 srcA != AST.num0 ctrl.PackSize))
  getValue 1
  tmps

let private genValidCheck ins insLen ctxt ctrl e1 e2 ir =
  let src1B, src1A = transOprToExpr128 ins insLen ctxt e1
  let src2B, src2A = transOprToExpr128 ins insLen ctxt e2
  match ctrl.Len with
  | Implicit -> implicitValidCheck ctrl src1B src1A ir,
                implicitValidCheck ctrl src2B src2A ir
  | Explicit ->
    let regSize, ax, dx =
      if hasREXW ins.REXPrefix
      then 64<rt>, !.ctxt R.RAX, !.ctxt R.RDX
      else 32<rt>, !.ctxt R.EAX, !.ctxt R.EDX
    explicitValidCheck ctrl ax regSize ir,
    explicitValidCheck ctrl dx regSize ir

let private genBoolRes ins insLen ctrl ctxt e1 e2 (ck1: Expr []) (ck2: Expr [])
            j i cmp =
  let src1B, src1A = transOprToExpr128 ins insLen ctxt e1
  let src2B, src2A = transOprToExpr128 ins insLen ctxt e2
  let elemSz = RegType.fromBitWidth <| int ctrl.NumElems
  let getSrc s idx =
    let unitWidth = RegType.toBitWidth ctrl.PackSize
    let amount = unitWidth * idx
    let amount = if amount < 64 then amount else amount - 64
    AST.extract s ctrl.PackSize amount
  let b =
    let e1 = if j < int ctrl.NumElems / 2 then src1A else src1B
    let e2 = if i < int ctrl.NumElems / 2 then src2A else src2B
    (AST.ite (cmp (getSrc e1 j) (getSrc e2 i)) (AST.num1 elemSz)
      (AST.num0 elemSz))
  match ctrl.Agg with
  | EqualAny | Ranges ->
    AST.ite (AST.not ck1[j] .& AST.not ck2[i]) (AST.num0 elemSz)
      (AST.ite (AST.not ck1[j] .| AST.not ck2[i]) (AST.num0 elemSz) b)
  | EqualEach ->
    AST.ite (AST.not ck1[i] .& AST.not ck2[i]) (AST.num1 elemSz)
      (AST.ite (AST.not ck1[i] .| AST.not ck2[i]) (AST.num0 elemSz) b)
  | EqualOrdered ->
    AST.ite (AST.not ck1[j] .& AST.not ck2[i]) (AST.num1 elemSz)
      (AST.ite (AST.not ck1[j] .& ck2[i]) (AST.num1 elemSz)
        (AST.ite (ck1[j] .& AST.not ck2[i]) (AST.num0 elemSz) b))

let private aggOpr ins insLen
           ctxt ctrl src1 src2 ck1 ck2 (res1 : Expr []) ir =
  let nElem = int ctrl.NumElems
  let elemSz = RegType.fromBitWidth <| nElem
  let boolRes = genBoolRes ins insLen ctrl ctxt src2 src1 ck2 ck1
  let rangesCmp idx =
    match ctrl.Sign, idx % 2 = 0 with
    | Signed, true -> AST.sge
    | Signed, _ -> AST.sle
    | _, true -> AST.ge
    | _, _ -> AST.le
  match ctrl.Agg with
  | EqualAny ->
    for j in 0 .. nElem - 1 do
      let tRes = [| for _ in 1 .. nElem -> !*ir elemSz |]
      let boolRes i = boolRes j i (==)
      !!ir (tRes[0] := AST.num0 elemSz .| boolRes 0)
      for i in 1 .. nElem - 1 do
        !!ir (tRes[i] := tRes[i - 1] .| boolRes i)
      done
      !!ir (res1[j] := tRes[nElem - 1] << numI32 j elemSz)
    done
  | EqualEach ->
    for i in 0 .. nElem - 1 do
      let boolRes i = boolRes i i (==)
      !!ir (res1[i] := boolRes i << numI32 i elemSz)
    done
  | EqualOrdered ->
    for j in 0 .. nElem - 1 do
      let tRes = [| for _ in 1 .. nElem -> !*ir elemSz |]
      let boolRes k i = boolRes k i (==)
      !!ir (tRes[0] := numI32 -1 elemSz .& boolRes j 0)
      for i in 1 .. nElem - 1 - j do
        let k = i + j
        !!ir (tRes[i] := tRes[i - 1] .& boolRes k i)
      done
      !!ir (res1[j] := tRes[nElem - 1] << numI32 j elemSz)
    done
  | Ranges ->
    for j in 0 .. nElem - 1 do
      let tRes = [| for _ in 1 .. nElem -> !*ir elemSz |]
      let cmp i = rangesCmp i
      let boolRes i = boolRes j i (cmp i)
      !!ir (tRes[0] := AST.num0 elemSz .| (boolRes 0 .& boolRes 1))
      for i in 2 .. 2 .. nElem - 1 do
        !!ir
          (tRes[i] := tRes[i - 1] .| (boolRes i .& boolRes (i + 1)))
      done
      !!ir (res1[j] := tRes[nElem - 1] << numI32 j elemSz)
    done

let private getIntRes2 e ctrInfo (booRes: Expr []) =
  let elemSz = RegType.fromBitWidth <| int ctrInfo.NumElems
  let elemCnt = ctrInfo.NumElems |> int
  match ctrInfo.Polarity with
  | PosPolarity | PosMasked -> e
  | NegPolarity -> numI32 -1 elemSz <+> e
  | NegMasked ->
    List.fold (fun acc i ->
      let e1 = e .& numI32 (pown 2 i) elemSz
      let e2 = (AST.not e) .& numI32 (pown 2 i) elemSz
      (AST.ite (booRes[i]) e2 e1) :: acc) [] [0 .. elemCnt - 1]
    |> List.reduce (.|)

let rec private genOutput ctrl e acc i =
  let elemSz = RegType.fromBitWidth <| int ctrl.NumElems
  let isSmallOut = ctrl.OutSelect = Least
  let e' = e >> numI32 i elemSz
  let next = if isSmallOut then i - 1 else i + 1
  let cond = if isSmallOut then i = 0 else i = int ctrl.NumElems - 1
  if cond then AST.ite (AST.xtlo 1<rt> e') (numI32 i elemSz) acc
  else genOutput ctrl e (AST.ite (AST.xtlo 1<rt> e') (numI32 i elemSz) acc) next

let private pcmpStrRet (ins: InsInfo) info ctxt intRes2 ir =
  let nElem = int info.NumElems
  let elemSz = RegType.fromBitWidth <| nElem
  match info.Ret with
  | Index ->
    let outSz, cx =
      if hasREXW ins.REXPrefix then 64<rt>, R.RCX else 32<rt>, R.ECX
    let cx = !.ctxt cx
    let nMaxSz = numI32 nElem elemSz
    let idx = if info.OutSelect = Least then nElem - 1 else 0
    let out = AST.zext outSz <| genOutput info intRes2 nMaxSz idx
    !!ir (dstAssign outSz cx out)
  | Mask ->
    let xmmB, xmmA = getPseudoRegVar128 ctxt Register.XMM0
    let loop (acc1, acc2) i =
      let src = AST.extract intRes2 1<rt> i
      if (i < nElem / 2) then (acc1, (AST.zext info.PackSize src) :: acc2)
      else ((AST.zext info.PackSize src) :: acc1, acc2)
    if info.OutSelect = Least then
      !!ir (xmmA := AST.zext 64<rt> intRes2)
      !!ir (xmmB := AST.num0 64<rt>)
    else let r1, r2 = List.fold loop ([], []) [0 .. nElem - 1]
         !!ir (xmmB := AST.concatArr (List.toArray r1))
         !!ir (xmmA := AST.concatArr (List.toArray r2))

let private getZSFForPCMPSTR ins insLen ctrl ctxt src1 src2 ir =
  let src1B, src1A = transOprToExpr128 ins insLen ctxt src1
  let src2B, src2A = transOprToExpr128 ins insLen ctxt src2
  let getExZSFlag r =
    let reg = !.ctxt r
    AST.lt (AST.ite (AST.xthi 1<rt> reg) (AST.neg reg) reg)
       (numU32 ctrl.NumElems 32<rt>)
  let rec getImZSFlag acc srcB srcA idx =
    let packSz = ctrl.PackSize
    let packWidth = RegType.toBitWidth packSz
    let half = ctrl.NumElems / 2u |> int
    let e, amount = if idx < half then srcA, idx else srcB, idx - half
    let v e = e >> numI32 (amount * packWidth) 64<rt>
    let next, cond = idx - 1, idx = 0
    if cond then AST.ite (AST.xtlo packSz (v e) == AST.num0 packSz) AST.b1 acc
    else let acc = AST.ite (AST.xtlo packSz (v e) == AST.num0 packSz) AST.b1 acc
         getImZSFlag acc srcB srcA next
  match ctrl.Len with
  | Implicit ->
    !!ir (!.ctxt R.ZF :=
      getImZSFlag AST.b0 src2B src2A (ctrl.NumElems - 1u |> int))
    !!ir (!.ctxt R.SF :=
      getImZSFlag AST.b0 src1B src1A (ctrl.NumElems - 1u |> int))
  | Explicit ->
    !!ir (!.ctxt R.ZF := getExZSFlag R.EDX)
    !!ir (!.ctxt R.SF := getExZSFlag R.EAX)

let pcmpstr ins insLen ctxt =
  let ir = IRBuilder (64)
  !<ir insLen
  let struct (src1, src2, imm) = getThreeOprs ins
  let imm = transOprToExpr ins insLen ctxt imm
  let ctrl = getPcmpstrInfo ins.Opcode imm
  let nElem = int ctrl.NumElems
  let elemSz = RegType.fromBitWidth <| nElem
  let ck1, ck2 = genValidCheck ins insLen ctxt ctrl src1 src2 ir
  let struct (intRes1, intRes2) = tmpVars2 ir elemSz
  let res1 = [| for _ in 1 .. nElem -> !*ir elemSz |]
  aggOpr ins insLen ctxt ctrl src1 src2 ck1 ck2 res1 ir
  !!ir (intRes1 := Array.reduce (.|) res1)
  !!ir (intRes2 := getIntRes2 intRes1 ctrl ck2)
  pcmpStrRet ins ctrl ctxt intRes2 ir
  !!ir (!.ctxt R.CF := intRes2 != AST.num0 elemSz)
  getZSFForPCMPSTR ins insLen ctrl ctxt src1 src2 ir
  !!ir (!.ctxt R.OF := AST.xtlo 1<rt> intRes2)
  !!ir (!.ctxt R.AF := AST.b0)
  !!ir (!.ctxt R.PF := AST.b0)
  !>ir insLen

IntelTypes.fs
//这段代码定义了x86指令设置中的一些关键类型:
//- Prefix定义了前缀类型,如LOCK前缀等
//- REXPrefix定义了REX前缀 
//- RegGrp定义了寄存器组
//- OpGroup定义了指令组
//- Scale定义了标度因子
//- ScaledIndex定义了标度寄存器
//- JumpTarget定义了跳转目标
//- Operand定义了操作数类型
//- Operands定义了操作数组合
//- SzCond定义了操作数大小条件
//- VEXType定义了旋转扩展类型 
//- MemLookupType定义了内存寻址类型
//- ZeroingOrMerging定义了重心或零化
//- EVEXPrefix定义了evex前缀
//- VEXInfo定义了vex信息
//- MPref定义了强制前缀
//- InsInfo定义了内部指令信息类
//它定义了x86指令设置中的基本单元,为后续指令分析、解码和翻译奠定基础。

namespace B2R2.FrontEnd.BinLifter.Intel

open B2R2
open B2R2.FrontEnd.BinLifter

/// Instruction prefixes.
[<System.FlagsAttribute>]
type Prefix =
  /// No prefix.
  | PrxNone = 0x0
  /// Lock prefix.
  | PrxLOCK = 0x1
  /// REPNE/REPNZ prefix is encoded using F2H.
  | PrxREPNZ = 0x2
  /// Bound prefix is encoded using F2H.
  | PrxBND = 0x4
  /// REP or REPE/REPZ is encoded using F3H.
  | PrxREPZ = 0x8
  /// CS segment prefix.
  | PrxCS = 0x10
  /// SS segment prefix.
  | PrxSS = 0x20
  /// DS segment prefix.
  | PrxDS = 0x40
  /// ES segment prefix.
  | PrxES = 0x80
  /// FS segment prefix.
  | PrxFS = 0x100
  /// GS segment prefix.
  | PrxGS = 0x200
  /// Operand-size override prefix is encoded using 66H.
  | PrxOPSIZE = 0x400
  /// 67H - Address-size override prefix.
  | PrxADDRSIZE = 0x800

/// REX prefixes.
type REXPrefix =
  /// No REX: this is to represent the case where there is no REX
  | NOREX = 0b0000000
  /// Extension of the ModR/M reg, Opcode reg field (SPL, BPL, ...).
  | REX = 0b1000000
  /// Extension of the ModR/M rm, SIB base, Opcode reg field.
  | REXB = 0b1000001
  /// Extension of the SIB index field.
  | REXX = 0b1000010
  /// Extension of the ModR/M SIB index, base field.
  | REXXB = 0b1000011
  /// Extension of the ModR/M reg field.
  | REXR = 0b1000100
  /// Extension of the ModR/M reg, r/m field.
  | REXRB = 0b1000101
  /// Extension of the ModR/M reg, SIB index field.
  | REXRX = 0b1000110
  /// Extension of the ModR/M reg, SIB index, base.
  | REXRXB = 0b1000111
  /// Operand 64bit.
  | REXW = 0b1001000
  /// REX.B + Operand 64bit.
  | REXWB = 0b1001001
  /// REX.X + Operand 64bit.
  | REXWX = 0b1001010
  /// REX.XB + Operand 64bit.
  | REXWXB = 0b1001011
  /// REX.R + Operand 64bit.
  | REXWR = 0b1001100
  /// REX.RB + Operand 64bit.
  | REXWRB = 0b1001101
  /// REX.RX + Operand 64bit.
  | REXWRX = 0b1001110
  /// REX.RXB + Operand 64bit.
  | REXWRXB = 0b1001111

/// We define 8 different RegGrp types. Intel instructions use an integer value
/// such as a REG field of a ModR/M value.
type RegGrp =
  /// AL/AX/EAX/...
  | RG0 = 0
  /// CL/CX/ECX/...
  | RG1 = 1
  /// DL/DX/EDX/...
  | RG2 = 2
  /// BL/BX/EBX/...
  | RG3 = 3
  /// AH/SP/ESP/...
  | RG4 = 4
  /// CH/BP/EBP/...
  | RG5 = 5
  /// DH/SI/ESI/...
  | RG6 = 6
  /// BH/DI/EDI/...
  | RG7 = 7

/// Opcode groups defined in manual Vol 2. Table A-6.
type OpGroup =
  | G1 = 0
  | G1Inv64 = 1
  | G1A = 2
  | G2 = 3
  | G3A = 4
  | G3B = 5
  | G4 = 6
  | G5 = 7
  | G6 = 8
  | G7 = 9
  | G8 = 10
  | G9 = 11
  | G10 = 12
  | G11A = 13
  | G11B = 14
  | G12 = 15
  | G13 = 16
  | G14 = 17
  | G15 = 18
  | G16 = 19
  | G17 = 20

/// The scale of Scaled Index.
type Scale =
  /// Times 1
  | X1 = 1
  /// Times 2
  | X2 = 2
  /// Times 4
  | X4 = 4
  /// Times 8
  | X8 = 8

/// Scaled index.
type ScaledIndex = Register * Scale

/// Jump target of a branch instruction.
type JumpTarget =
  | Absolute of Selector * Addr * OperandSize
  | Relative of Offset
and Selector = int16
and Offset = int64
and OperandSize = RegType

/// We define four different types of X86 operands:
/// register, memory, direct address, and immediate.
type Operand =
  /// A register operand.
  | OprReg of Register
  /// OprMem represents a memory operand. The OperandSize here means the memory
  /// access size of the operand, i.e., how many bytes do we read/write here.
  | OprMem of Register option * ScaledIndex option * Disp option * OperandSize
  /// OprDirAddr is a direct branch target address.
  | OprDirAddr of JumpTarget
  /// OprImm represents an immediate operand. The OperandSize here means the
  /// size of the encoded immediate value.
  | OprImm of int64 * OperandSize
  /// Label is *not* encoded in the actual binary. This is only used when we
  /// assemble binaries.
  | Label of string * RegType
/// Displacement.
and Disp = int64

/// A set of operands in an X86 instruction.
type Operands =
  | NoOperand
  | OneOperand of Operand
  | TwoOperands of Operand * Operand
  | ThreeOperands of Operand * Operand * Operand
  | FourOperands of Operand * Operand * Operand * Operand

/// Specific conditions for determining the size of operands.
/// (See Table A-1, Appendix A.2.5 of Vol. 2D).
type SzCond =
  /// (d64) When in 64-bit mode, instruction defaults to 64-bit operand size and
  /// cannot encode 32-bit operand size.
  | D64 = 0
  /// (f64) The operand size is forced to a 64-bit operand size when in 64-bit
  /// mode (prefixes that change operand size, e.g., 66 prefix, are ignored for
  /// this instruction in 64-bit mode).
  | F64 = 1
  /// Normal conditions. This includes all other size conditions in Table A-1.
  | Nor = 2

/// Types of VEX (Vector Extension).
[<System.FlagsAttribute>]
type VEXType =
  /// Original VEX that refers to two-byte opcode map.
  | VEXTwoByteOp = 0x1
  /// Original VEX that refers to three-byte opcode map #1.
  | VEXThreeByteOpOne = 0x2
  /// Original VEX that refers to three-byte opcode map #2.
  | VEXThreeByteOpTwo = 0x4
  /// EVEX Mask
  | EVEX = 0x10

/// Intel's memory operand is represented by two tables (ModR/M and SIB table).
/// Some memory operands do need SIB table lookups, whereas some memory operands
/// only need to look up the ModR/M table.
type internal MemLookupType =
  | SIB (* Need SIB lookup *)
  | NOSIB of RegGrp option (* No need *)

/// Vector destination merging/zeroing: P[23] encodes the destination result
/// behavior which either zeroes the masked elements or leave masked element
/// unchanged.
type ZeroingOrMerging =
  | Zeroing
  | Merging

type EVEXPrefix = {
  /// Embedded opmask register specifier, P[18:16].
  AAA: uint8
  /// Zeroing/Merging, P[23].
  Z: ZeroingOrMerging
  /// Broadcast/RC/SAE Context, P[20].
  B: uint8
}

/// Information about Intel vector extension.
type VEXInfo = {
  VVVV: byte
  VectorLength: RegType
  VEXType: VEXType
  VPrefixes: Prefix
  EVEXPrx: EVEXPrefix option
}

/// Mandatory prefixes. The 66H, F2H, and F3H prefixes are mandatory for opcode
/// extensions.
type MPref =
  /// Indicates the use of 66/F2/F3 prefixes (beyond those already part of the
  /// instructions opcode) are not allowed with the instruction.
  | MPrxNP = 0
  /// 66 prefix.
  | MPrx66 = 1
  /// F3 prefix.
  | MPrxF3 = 2
  /// F2 prefix.
  | MPrxF2 = 3
  /// 66 & F2 prefix.
  | MPrx66F2 = 4

[<AbstractClass>]
type IntelInternalInstruction
  (addr, len, wordSz, pref, rex, vex, opcode, oprs, opsz, psz) =
  inherit Instruction (addr, len, wordSz)

  /// Prefixes.
  member __.Prefixes with get(): Prefix = pref

  /// REX Prefix.
  member __.REXPrefix with get(): REXPrefix = rex

  /// VEX information.
  member __.VEXInfo with get(): VEXInfo option = vex

  /// Opcode.
  member __.Opcode with get(): Opcode = opcode

  /// Operands.
  member __.Operands with get(): Operands = oprs

  /// Size of the main operation performed by the instruction. This field is
  /// mainly used by our lifter, and we suggest not to use this field for
  /// analyzing binaries because there is some ambiguity in deciding the
  /// operation size when the instruction semantics are complex. We use this
  /// only for the purpose of optimizing the lifting process.
  member __.MainOperationSize with get(): RegType = opsz

  /// Size of the memory pointer in the instruction, i.e., how many bytes are
  /// required to represent a memory address. This field may hold a dummy value
  /// if there's no memory operand. This is mainly used for the lifting purpose
  /// along with the MainOperationSize.
  member __.PointerSize with get(): RegType = psz

  override __.Equals (rhs) =
    match rhs with
    | :? IntelInternalInstruction as rhs ->
      __.Prefixes = rhs.Prefixes
      && __.REXPrefix = rhs.REXPrefix
      && __.VEXInfo = rhs.VEXInfo
      && __.Opcode = rhs.Opcode
      && __.Operands = rhs.Operands
    | _ -> false

  override __.GetHashCode () =
    let hash = System.HashCode ()
    hash.Add __.Prefixes
    hash.Add __.REXPrefix
    hash.Add __.VEXInfo
    hash.Add __.Opcode
    hash.Add __.Operands
    hash.ToHashCode ()

type internal InsInfo = IntelInternalInstruction

// vim: set tw=80 sts=2 sw=2:

IntelX87Lifter.fs
//该模块实现了x87浮点数协处理器相关指令的翻译。
//主要功能点:
//1. 定义了x87浮点数寄存器访问和操作的翻译函数。
//2. 各个x87指令的具体翻译实现函数。 
//3. 带条件代码更新的二元操作及弹栈推入操作翻译。
//4. 浮点数与整数之间的转换。
//5. 状态控制寄存器和控制字访问。
//翻译流程:
//1. 解析/翻译x87操作数获取中间表达式。
//2. 根据指令调用具体实现函数完成语义转换。
//3. 处理状态控制及条件码更新。
//4. 返回翻译后的IR。
//它给上层提供了x87指令集的统一翻译接口。
//与通用和SIMD模块配合,完成整个x86指令集翻译。
//是x87浮点数体系结构关键组成部分。

module internal B2R2.FrontEnd.BinLifter.Intel.X87Lifter

open B2R2
open B2R2.BinIR
open B2R2.BinIR.LowUIR
open B2R2.BinIR.LowUIR.AST.InfixOp
open B2R2.FrontEnd.BinLifter
open B2R2.FrontEnd.BinLifter.LiftingOperators
open B2R2.FrontEnd.BinLifter.LiftingUtils
open B2R2.FrontEnd.BinLifter.Intel
open B2R2.FrontEnd.BinLifter.Intel.LiftingUtils

let private undefC0 = AST.undef 1<rt> "C0 is undefined."

let private undefC1 = AST.undef 1<rt> "C1 is undefined."

let private undefC2 = AST.undef 1<rt> "C2 is undefined."

let private undefC3 = AST.undef 1<rt> "C3 is undefined."

let private allCFlagsUndefined ctxt ir =
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC1 := undefC1)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)

let private cflagsUndefined023 ctxt ir =
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)

let inline private getFPUPseudoRegVars ctxt r =
  struct (getPseudoRegVar ctxt r 2, getPseudoRegVar ctxt r 1)

let private updateC1OnLoad ctxt ir =
  let top = !.ctxt R.FTOP
  let c1Flag = !.ctxt R.FSWC1
  (* Top value has been wrapped around, which means stack overflow in B2R2. *)
  !!ir (c1Flag := (top == AST.num0 8<rt>))
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)

let private updateC1OnStore ctxt ir =
  let top = !.ctxt R.FTOP
  let c1Flag = !.ctxt R.FSWC1
  (* Top value has been wrapped around, which means stack underflow in B2R2. *)
  !!ir (c1Flag := (top != numI32 7 8<rt>))
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)

let private moveFPRegtoFPReg regdst regsrc ctxt ir =
  let struct (dstB, dstA) = getFPUPseudoRegVars ctxt regdst
  let struct (srcB, srcA) = getFPUPseudoRegVars ctxt regsrc
  !!ir (dstA := srcA)
  !!ir (dstB := srcB)

let private clearFPReg reg ctxt ir =
  let struct (stB, stA) = getFPUPseudoRegVars ctxt reg
  !!ir (stB := AST.num0 16<rt>)
  !!ir (stA := AST.num0 64<rt>)

let private pushFPUStack ctxt ir =
  let top = !.ctxt R.FTOP
  (* We increment TOP here (which is the opposite way of what the manual says),
     because it is more intuitive to consider it as a counter. *)
  !!ir (extractDstAssign top (top .+ AST.num1 8<rt>))
  !?ir (moveFPRegtoFPReg R.ST7 R.ST6 ctxt)
  !?ir (moveFPRegtoFPReg R.ST6 R.ST5 ctxt)
  !?ir (moveFPRegtoFPReg R.ST5 R.ST4 ctxt)
  !?ir (moveFPRegtoFPReg R.ST4 R.ST3 ctxt)
  !?ir (moveFPRegtoFPReg R.ST3 R.ST2 ctxt)
  !?ir (moveFPRegtoFPReg R.ST2 R.ST1 ctxt)
  !?ir (moveFPRegtoFPReg R.ST1 R.ST0 ctxt)

let private popFPUStack ctxt ir =
  let top = !.ctxt R.FTOP
  (* We decrement TOP here (the opposite way compared to the manual) because it
     is more intuitive, because it is more intuitive to consider it as a
     counter. *)
  !!ir (extractDstAssign top (top .- AST.num1 8<rt>))
  !?ir (moveFPRegtoFPReg R.ST0 R.ST1 ctxt)
  !?ir (moveFPRegtoFPReg R.ST1 R.ST2 ctxt)
  !?ir (moveFPRegtoFPReg R.ST2 R.ST3 ctxt)
  !?ir (moveFPRegtoFPReg R.ST3 R.ST4 ctxt)
  !?ir (moveFPRegtoFPReg R.ST4 R.ST5 ctxt)
  !?ir (moveFPRegtoFPReg R.ST5 R.ST6 ctxt)
  !?ir (moveFPRegtoFPReg R.ST6 R.ST7 ctxt)
  !?ir (clearFPReg R.ST7 ctxt)

let inline private getLoadAddressExpr (src: Expr) =
  match src.E with
  | Load (_, _, addr, _) -> struct (addr, TypeCheck.typeOf addr)
  | _ -> Utils.impossible ()

let private castTo80Bit ctxt tmpB tmpA srcExpr ir =
  let oprSize = TypeCheck.typeOf srcExpr
  match oprSize with
  | 32<rt> ->
    let tmpSrc = !*ir oprSize
    let n31 = numI32 31 32<rt>
    let n15 = numI32 15 32<rt>
    let n23 = numI32 23 32<rt>
    let one = numI32 1 32<rt>
    let biasDiff = numI32 0x3f80 32<rt>
    let sign = AST.xtlo 16<rt> (((tmpSrc >> n31) .& one) << n15)
    let exponent =
      AST.xtlo 16<rt> (((tmpSrc >> n23) .& (numI32 0xff 32<rt>)) .+ biasDiff)
    let integerpart = numI64 0x0010000000000000L 64<rt>
    let significand =
      (AST.zext 64<rt> (tmpSrc .& numI32 0x7fffff 32<rt>)) .| integerpart
    !!ir (tmpSrc := srcExpr)
    !!ir (tmpB := sign .| exponent)
    !!ir (tmpA := (significand << numI32 40 64<rt>))
  | 64<rt> ->
    let tmpSrc = !*ir oprSize
    let n63 = numI32 63 64<rt>
    let n15 = numI32 15 64<rt>
    let n52 = numI32 52 64<rt>
    let one = numI32 1 64<rt>
    let biasDiff = numI32 0x3c00 64<rt>
    let sign = AST.xtlo 16<rt> (((tmpSrc >> n63) .& one) << n15)
    let exponent =
      AST.xtlo 16<rt> (((tmpSrc>> n52) .& (numI32 0x7ff 64<rt>)) .+ biasDiff)
    let integerpart = numI64 0x0010000000000000L 64<rt>
    let significand = tmpSrc .& numI64 0xFFFFFFFFFFFFFL 64<rt> .| integerpart
    !!ir (tmpSrc := srcExpr)
    !!ir (tmpB := sign .| exponent)
    !!ir (tmpA := (significand << numI32 11 64<rt>))
  | 80<rt> ->
    match srcExpr.E with
    | Load (_, _, addrExpr, _) ->
      let addrSize = TypeCheck.typeOf addrExpr
      !!ir (tmpB := AST.loadLE 16<rt> (addrExpr .+ numI32 8 addrSize))
      !!ir (tmpA := AST.loadLE 64<rt> addrExpr)
    | BinOp (_, _, { E = Var (_, r, _, _) }, { E = Var (_, _, _, _)}, _) ->
      let reg = Register.pseudoRegToReg (Register.ofRegID r)
      let struct (srcB, srcA) = getFPUPseudoRegVars ctxt reg
      !!ir (tmpB := srcB)
      !!ir (tmpA := srcA)
    | _ -> raise InvalidOperandException
  | _ -> Utils.impossible ()

let private fpuLoad insLen ctxt oprExpr =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmpB, tmpA = !*ir 16<rt>, !*ir 64<rt>
  !<ir insLen
  !?ir (castTo80Bit ctxt tmpB tmpA oprExpr)
  !?ir (pushFPUStack ctxt)
  !!ir (st0b := tmpB)
  !!ir (st0a := tmpA)
  !?ir (updateC1OnLoad ctxt)
  !>ir insLen

let fld ins insLen ctxt =
  let oprExpr = transOneOpr ins insLen ctxt
  fpuLoad insLen ctxt oprExpr

let private castFrom80Bit dstExpr dstSize srcB srcA ir =
  match dstSize with
  | 32<rt> ->
    let n16 = numI32 16 32<rt>
    let sign = (AST.zext 32<rt> srcB .& (numI32 0x8000 32<rt>)) << n16
    let biasDiff = numI32 0x3f80 32<rt>
    let exponent = AST.zext 32<rt> (srcB .& (numI32 0x7fff 16<rt>)) .- biasDiff
    let exponent = exponent << numI32 23 32<rt>
    let n40 = numI32 40 64<rt>
    let significand =
      AST.xtlo 32<rt> ((srcA .& numI64 0x7FFFFFFFFFFFFFFFL 64<rt>) >> n40)
    !!ir (dstExpr := (sign .| exponent .| significand))
  | 64<rt> ->
    let n48 = numI32 48 64<rt>
    let sign = (AST.zext 64<rt> srcB .& (numI32 0x8000 64<rt>)) << n48
    let biasDiff = numI32 0x3c00 64<rt>
    let exponent = AST.zext 64<rt> (srcB .& (numI32 0x7fff 16<rt>)) .- biasDiff
    let exponent = exponent << numI32 52 64<rt>
    let n11 = numI32 11 64<rt>
    let significand = (srcA .& numI64 0x7FFFFFFFFFFFFFFFL 64<rt>) >> n11
    !!ir (dstExpr := (sign .| exponent .| significand))
  | 80<rt> ->
    let struct (addrExpr, addrSize) = getLoadAddressExpr dstExpr
    !!ir (AST.store Endian.Little (addrExpr) srcA)
    !!ir (AST.store Endian.Little (addrExpr .+ numI32 8 addrSize) srcB)
  | _ -> Utils.impossible ()

let ffst (ins: InsInfo) insLen ctxt doPop =
  let ir = IRBuilder (32)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  !<ir insLen
  match ins.Operands with
  | OneOperand (OprReg r) ->
    let struct (dstB, dstA) = getFPUPseudoRegVars ctxt r
    !!ir (dstB := st0b)
    !!ir (dstA := st0a)
  | OneOperand (opr) ->
    let oprExpr = transOprToExpr ins insLen ctxt opr
    let oprSize = TypeCheck.typeOf oprExpr
    !?ir (castFrom80Bit oprExpr oprSize st0b st0a)
  | _ -> raise InvalidOperandException
  if doPop then !?ir (popFPUStack ctxt) else ()
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fild ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let oprExpr = transOneOpr ins insLen ctxt
  let tmpB, tmpA = !*ir 16<rt>, !*ir 64<rt>
  !<ir insLen
  !?ir
    (castTo80Bit ctxt tmpB tmpA (AST.cast CastKind.IntToFloat 64<rt> oprExpr))
  !?ir (pushFPUStack ctxt)
  !!ir (st0b := tmpB)
  !!ir (st0a := tmpA)
  !?ir (updateC1OnLoad ctxt)
  !>ir insLen

let fist ins insLen ctxt doPop =
  let ir = IRBuilder (32)
  let oprExpr = transOneOpr ins insLen ctxt
  let oprSize = TypeCheck.typeOf oprExpr
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmp0 = !*ir oprSize
  let rcField = !*ir 2<rt> (* Rounding Control *)
  let num2 = numI32 2 2<rt>
  let cst00 = AST.cast CastKind.FtoIRound oprSize tmp0
  let cst01 = AST.cast CastKind.FtoIFloor oprSize tmp0
  let cst10 = AST.cast CastKind.FtoICeil oprSize tmp0
  let cst11 = AST.cast CastKind.FtoITrunc oprSize tmp0
  !<ir insLen
  !?ir (castFrom80Bit tmp0 oprSize st0b st0a)
  !!ir (rcField := AST.extract (!.ctxt R.FCW) 2<rt> 10)
  !!ir (tmp0 := AST.ite (rcField == AST.num0 2<rt>) cst00 cst11)
  !!ir (tmp0 := AST.ite (rcField == AST.num1 2<rt>) cst01 tmp0)
  !!ir (tmp0 := AST.ite (rcField == num2) cst10 tmp0)
  !!ir (oprExpr := tmp0)
  if doPop then !?ir (popFPUStack ctxt) else ()
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fisttp ins insLen ctxt =
  let ir = IRBuilder (32)
  let oprExpr = transOneOpr ins insLen ctxt
  let oprSize = TypeCheck.typeOf oprExpr
  let tmp1 = !*ir 64<rt>
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  !<ir insLen
  !?ir (castFrom80Bit tmp1 64<rt> st0b st0a)
  !!ir (oprExpr := AST.cast CastKind.FtoITrunc oprSize tmp1)
  !?ir (popFPUStack ctxt)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let private getTwoBCDDigits addrExpr addrSize startPos =
  let byteValue = AST.loadLE 8<rt> (addrExpr .+ numI32 startPos addrSize)
  let d1 = AST.extract byteValue 4<rt> 0 |> AST.sext 64<rt>
  let d2 = AST.extract byteValue 4<rt> 4 |> AST.sext 64<rt>
  struct (d1, d2)

let private bcdToInt intgr addrExpr addrSize ir =
  let struct (d1, d2) = getTwoBCDDigits addrExpr addrSize 0
  let struct (d3, d4) = getTwoBCDDigits addrExpr addrSize 1
  let struct (d5, d6) = getTwoBCDDigits addrExpr addrSize 2
  let struct (d7, d8) = getTwoBCDDigits addrExpr addrSize 3
  let struct (d9, d10) = getTwoBCDDigits addrExpr addrSize 4
  let struct (d11, d12) = getTwoBCDDigits addrExpr addrSize 5
  let struct (d13, d14) = getTwoBCDDigits addrExpr addrSize 6
  let struct (d15, d16) = getTwoBCDDigits addrExpr addrSize 7
  let struct (d17, d18) = getTwoBCDDigits addrExpr addrSize 8
  let signByte = AST.loadLE 8<rt> (addrExpr .+ numI32 9 addrSize)
  let signBit = AST.xthi 1<rt> signByte
  !!ir (intgr := d1)
  !!ir (intgr := intgr .+  d2 .* numI64 10L 64<rt>)
  !!ir (intgr := intgr .+  d3 .* numI64 100L 64<rt>)
  !!ir (intgr := intgr .+  d4 .* numI64 1000L 64<rt>)
  !!ir (intgr := intgr .+  d5 .* numI64 10000L 64<rt>)
  !!ir (intgr := intgr .+  d6 .* numI64 100000L 64<rt>)
  !!ir (intgr := intgr .+  d7 .* numI64 1000000L 64<rt>)
  !!ir (intgr := intgr .+  d8 .* numI64 10000000L 64<rt>)
  !!ir (intgr := intgr .+  d9 .* numI64 100000000L 64<rt>)
  !!ir (intgr := intgr .+ d10 .* numI64 1000000000L 64<rt>)
  !!ir (intgr := intgr .+ d11 .* numI64 10000000000L 64<rt>)
  !!ir (intgr := intgr .+ d12 .* numI64 100000000000L 64<rt>)
  !!ir (intgr := intgr .+ d13 .* numI64 1000000000000L 64<rt>)
  !!ir (intgr := intgr .+ d14 .* numI64 10000000000000L 64<rt>)
  !!ir (intgr := intgr .+ d15 .* numI64 100000000000000L 64<rt>)
  !!ir (intgr := intgr .+ d16 .* numI64 1000000000000000L 64<rt>)
  !!ir (intgr := intgr .+ d17 .* numI64 10000000000000000L 64<rt>)
  !!ir (intgr := intgr .+ d18 .* numI64 100000000000000000L 64<rt>)
  !!ir (AST.xthi 1<rt> intgr := signBit)

let fbld ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let src = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr src
  let intgr = !*ir 64<rt>
  let tmpB, tmpA = !*ir 16<rt>, !*ir 64<rt>
  !<ir insLen
  !?ir (bcdToInt intgr addrExpr addrSize)
  !?ir (castTo80Bit ctxt tmpB tmpA (AST.cast CastKind.IntToFloat 64<rt> intgr))
  !?ir (pushFPUStack ctxt)
  !!ir (st0b := tmpB)
  !!ir (st0a := tmpA)
  !?ir (updateC1OnLoad ctxt)
  !>ir insLen

let private storeTwoDigitBCD n10 addrExpr addrSize intgr pos ir =
  let d1 = AST.extract (intgr .% n10) 4<rt> 0
  let d2 = AST.extract ((intgr ./ n10) .% n10) 4<rt> 0
  let ds = AST.concat d2 d1
  !!ir (AST.store Endian.Little (addrExpr .+ numI32 pos addrSize) ds)

let private storeBCD addrExpr addrSize intgr ir =
  let n10 = numI32 10 64<rt>
  let n100 = numI32 100 64<rt>
  let sign = !*ir 1<rt>
  let signByte = (AST.zext 8<rt> sign) << numI32 7 8<rt>
  !!ir (sign := AST.xthi 1<rt> intgr)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 0)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 1)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 2)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 3)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 4)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 5)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 6)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 7)
  !!ir (intgr := intgr ./ n100)
  !?ir (storeTwoDigitBCD n10 addrExpr addrSize intgr 8)
  !!ir (AST.store Endian.Little (addrExpr .+ numI32 9 addrSize) signByte)

let fbstp ins insLen ctxt =
  let ir = IRBuilder (64)
  let dst = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr dst
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmp = !*ir 64<rt>
  let intgr = !*ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp 64<rt> st0b st0a)
  !!ir (intgr := AST.cast CastKind.FtoIRound 64<rt> tmp)
  !?ir (storeBCD addrExpr addrSize intgr)
  !?ir (popFPUStack ctxt)
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fxch (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (16)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmpB, tmpA = !*ir 16<rt>, !*ir 64<rt>
  !<ir insLen
  !!ir (tmpB := st0b)
  !!ir (tmpA := st0a)
  let struct (srcB, srcA) =
    match ins.Operands with
    | OneOperand (OprReg reg) -> getFPUPseudoRegVars ctxt reg
    | NoOperand -> getFPUPseudoRegVars ctxt R.ST1
    | _ -> raise InvalidOperandException
  !!ir (st0b := srcB)
  !!ir (st0a := srcA)
  !!ir (srcB := tmpB)
  !!ir (srcA := tmpA)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !?ir (cflagsUndefined023 ctxt)
  !>ir insLen

let private fcmov (ins: InsInfo) insLen ctxt cond =
  let ir = IRBuilder (8)
  let srcReg =
    match ins.Operands with
    | TwoOperands (_, OprReg reg) -> reg
    | _ -> raise InvalidOperandException
  let struct (srcB, srcA) = getFPUPseudoRegVars ctxt srcReg
  let struct (dstB, dstA) = getFPUPseudoRegVars ctxt R.ST0
  !<ir insLen
  !!ir (dstB := AST.ite cond srcB dstB)
  !!ir (dstA := AST.ite cond srcA dstA)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let fcmove ins insLen ctxt =
  !.ctxt R.ZF |> fcmov ins insLen ctxt

let fcmovne ins insLen ctxt =
  !.ctxt R.ZF |> AST.not |> fcmov ins insLen ctxt

let fcmovb ins insLen ctxt =
  !.ctxt R.CF |> fcmov ins insLen ctxt

let fcmovbe ins insLen ctxt =
  (!.ctxt R.CF .| !.ctxt R.ZF) |> fcmov ins insLen ctxt

let fcmovnb ins insLen ctxt =
  !.ctxt R.CF |> AST.not |> fcmov ins insLen ctxt

let fcmovnbe ins insLen ctxt =
  let cond1 = !.ctxt R.CF |> AST.not
  let cond2 = !.ctxt R.ZF |> AST.not
  cond1 .& cond2 |> fcmov ins insLen ctxt

let fcmovu ins insLen ctxt =
  !.ctxt R.PF |> fcmov ins insLen ctxt

let fcmovnu ins insLen ctxt =
  !.ctxt R.PF |> AST.not |> fcmov ins insLen ctxt

let private fpuFBinOp (ins: InsInfo) insLen ctxt binOp doPop leftToRight =
  let ir = IRBuilder (64)
  !<ir insLen
  match ins.Operands with
  | NoOperand ->
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
    let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
    let struct (tmp0, tmp1) = tmpVars2 ir 64<rt>
    let res = !*ir 64<rt>
    !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
    !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
    if leftToRight then !!ir (res := binOp tmp0 tmp1)
    else !!ir (res := binOp tmp1 tmp0)
    !?ir (castTo80Bit ctxt st1b st1a res)
  | OneOperand opr ->
    let oprExpr = transOneOpr ins insLen ctxt
    let oprSize = TypeCheck.typeOf oprExpr
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
    let struct (tmp0, tmp1) = tmpVars2 ir oprSize
    let res = !*ir oprSize
    !?ir (castFrom80Bit tmp0 oprSize st0b st0a)
    !!ir (tmp1 := oprExpr)
    if leftToRight then !!ir (res := binOp tmp0 tmp1)
    else !!ir (res := binOp tmp1 tmp0)
    !?ir (castTo80Bit ctxt st0b st0a res)
  | TwoOperands (OprReg reg0, OprReg reg1) ->
    let struct (r0B, r0A) = getFPUPseudoRegVars ctxt reg0
    let struct (r1B, r1A) = getFPUPseudoRegVars ctxt reg1
    let struct (tmp0, tmp1) = tmpVars2 ir 64<rt>
    let res = !*ir 64<rt>
    !?ir (castFrom80Bit tmp0 64<rt> r0B r0A)
    !?ir (castFrom80Bit tmp1 64<rt> r1B r1A)
    if leftToRight then !!ir (res := binOp tmp0 tmp1)
    else !!ir (res := binOp tmp1 tmp0)
    !?ir (castTo80Bit ctxt r0B r0A res)
  | _ -> raise InvalidOperandException
  if doPop then !?ir (popFPUStack ctxt) else ()
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let private fpuIntOp ins insLen ctxt binOp leftToRight =
  let ir = IRBuilder (8)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let oprExpr = transOneOpr ins insLen ctxt
  let struct (tmp, dst) = tmpVars2 ir 64<rt>
  let res = !*ir 64<rt>
  !<ir insLen
  !!ir (tmp := AST.cast CastKind.IntToFloat 64<rt> oprExpr)
  !?ir (castFrom80Bit dst 64<rt> st0b st0a)
  if leftToRight then !!ir (res := binOp dst tmp)
  else !!ir (res := binOp tmp dst)
  !?ir (castTo80Bit ctxt st0b st0a res)
  !>ir insLen

let fpuadd ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fadd doPop true

let fiadd ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fadd true

let fpusub ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fsub doPop true

let fisub ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fsub true

let fsubr ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fsub doPop false

let fisubr ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fsub false

let fpumul ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fmul doPop true

let fimul ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fmul true

let fpudiv ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fdiv doPop true

let fidiv ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fdiv true

let fdivr ins insLen ctxt doPop =
  fpuFBinOp ins insLen ctxt AST.fdiv doPop false

let fidivr ins insLen ctxt =
  fpuIntOp ins insLen ctxt AST.fdiv false

let inline private castToF64 intexp =
  AST.cast CastKind.IntToFloat 64<rt> intexp

let fprem _ins insLen ctxt round =
  let ir = IRBuilder (32)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
  let caster = if round then CastKind.FtoIRound else CastKind.FtoITrunc
  let lblLT64 = ir.NewSymbol "ExpDiffInRange"
  let lblGE64 = ir.NewSymbol "ExpDiffOutOfRange"
  let lblExit = ir.NewSymbol "Exit"
  let struct (tmp0, tmp1) = tmpVars2 ir 64<rt>
  let expDiff = !*ir 16<rt>
  let expMask = numI32 0x7fff 16<rt>
  let n64 = numI32 64 16<rt>
  let n2 = numI32 2 64<rt>
  let struct (divres, intres, tmpres, divider) = tmpVars4 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  !!ir (expDiff := (st0b .& expMask) .- (st1b .& expMask))
  !!ir (AST.cjmp (AST.lt expDiff n64) (AST.name lblLT64) (AST.name lblGE64))
  !!ir (AST.lmark lblLT64) (* D < 64 *)
  !!ir (divres := AST.fdiv tmp0 tmp1)
  !!ir (intres := AST.cast caster 64<rt> divres)
  !!ir (tmpres := AST.fsub tmp0 (AST.fmul tmp1 (castToF64 intres)))
  !?ir (castTo80Bit ctxt st0b st0a tmpres)
  !!ir (!.ctxt R.FSWC2 := AST.b0)
  !!ir (!.ctxt R.FSWC1 := AST.xtlo 1<rt> intres)
  !!ir (!.ctxt R.FSWC3 := AST.extract intres 1<rt> 1)
  !!ir (!.ctxt R.FSWC0 := AST.extract intres 1<rt> 2)
  !!ir (AST.jmp (AST.name lblExit))
  !!ir (AST.lmark lblGE64) (* ELSE *)
  !!ir (!.ctxt R.FSWC2 := AST.b1)
  !!ir (tmpres := AST.fsub (castToF64 expDiff) (castToF64 (numI32 63 64<rt>)))
  !!ir (divider := AST.fpow n2 tmpres)
  !!ir (divres := AST.fdiv (AST.fdiv tmp0 tmp1) divider)
  !!ir (intres := AST.cast CastKind.FtoITrunc 64<rt> divres)
  !!ir (tmpres :=
    AST.fsub tmp0 (AST.fmul tmp1 (AST.fmul (castToF64 intres) divider)))
  !?ir (castTo80Bit ctxt st0b st0a tmpres)
  !!ir (AST.lmark lblExit)
  !>ir insLen

let fabs _ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (st0b, _st0a) = getFPUPseudoRegVars ctxt R.ST0
  !<ir insLen
  !!ir (AST.extract st0b 1<rt> 15 := AST.b0)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let fchs _ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (st0b, _st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmp = !*ir 1<rt>
  !<ir insLen
  !!ir (tmp := AST.xthi 1<rt> st0b)
  !!ir (AST.xthi 1<rt> st0b := AST.not tmp)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let frndint _ins insLen ctxt =
  let ir = IRBuilder (32)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmp0 = !*ir 64<rt>
  let rcField = !*ir 2<rt> (* Rounding Control *)
  let cst00 = AST.cast CastKind.FtoIRound 64<rt> tmp0
  let cst01 = AST.cast CastKind.FtoIFloor 64<rt> tmp0
  let cst10 = AST.cast CastKind.FtoICeil 64<rt> tmp0
  let cst11 = AST.cast CastKind.FtoITrunc 64<rt> tmp0
  let num2 = numI32 2 2<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !!ir (rcField := AST.extract (!.ctxt R.FCW) 2<rt> 10)
  !!ir (tmp0 := AST.ite (rcField == AST.num0 2<rt>) cst00 cst11)
  !!ir (tmp0 := AST.ite (rcField == AST.num1 2<rt>) cst01 tmp0)
  !!ir (tmp0 := AST.ite (rcField == num2) cst10 tmp0)
  !?ir (castTo80Bit ctxt st0b st0a (castToF64 tmp0))
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fscale _ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (tmp0, tmp1, tmp2) = tmpVars3 ir 64<rt>
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  !!ir (tmp2 := numI32 1 64<rt> << (AST.cast CastKind.FtoITrunc 64<rt> tmp1))
  !?ir (castTo80Bit ctxt st0b st0a (AST.fmul tmp1 (castToF64 tmp2)))
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fsqrt _ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let tmp0 = !*ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castTo80Bit ctxt st0b st0a (AST.unop UnOpType.FSQRT tmp0))
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let fxtract _ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let n3fff = numI32 0x3FFF 16<rt>
  let tmpB, tmpA = !*ir 16<rt>, !*ir 64<rt>
  let tmpF = !*ir 64<rt>
  !<ir insLen
  !!ir (tmpB := (st0b .& numI32 0x8000 16<rt>) .| n3fff)
  !!ir (tmpA := st0a)
  !!ir (tmpF := castToF64 ((st0b .& numI32 0x7fff 16<rt>) .- n3fff))
  !?ir (pushFPUStack ctxt)
  !?ir (castTo80Bit ctxt st0b st0a tmpF)
  !?ir (updateC1OnStore ctxt)
  !>ir insLen

let private prepareTwoOprsForComparison (ins: InsInfo) insLen ctxt ir =
  let struct (tmp0, tmp1) = tmpVars2 ir 64<rt>
  match ins.Operands with
  | NoOperand ->
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
    let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
    !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
    !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  | OneOperand (OprReg r) ->
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
    let struct (st1b, st1a) = getFPUPseudoRegVars ctxt r
    !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
    !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  | OneOperand (opr) ->
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
    let oprExpr = transOprToExpr ins insLen ctxt opr
    !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
    !!ir (tmp1 := AST.cast CastKind.FloatCast 64<rt> oprExpr)
  | TwoOperands (OprReg r1, OprReg r2) ->
    let struct (st0b, st0a) = getFPUPseudoRegVars ctxt r1
    let struct (st1b, st1a) = getFPUPseudoRegVars ctxt r2
    !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
    !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  | _ -> raise InvalidOperandException
  struct (tmp0, tmp1)

let fcom (ins: InsInfo) insLen ctxt nPop unordered =
  let ir = IRBuilder (64)
  let c0 = !.ctxt R.FSWC0
  let c2 = !.ctxt R.FSWC2
  let c3 = !.ctxt R.FSWC3
  !<ir insLen
  let struct (tmp0, tmp1) = prepareTwoOprsForComparison ins insLen ctxt ir
  !!ir (c0 := AST.flt tmp0 tmp1)
  !!ir (c2 := AST.b0)
  !!ir (c3 := (tmp0 == tmp1))
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  if nPop > 0 then !?ir (popFPUStack ctxt) else ()
  if nPop = 2 then !?ir (popFPUStack ctxt) else ()
  !>ir insLen

let ficom ins insLen ctxt doPop =
  let ir = IRBuilder (32)
  let oprExpr = transOneOpr ins insLen ctxt
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (tmp0, tmp1) = tmpVars2 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !!ir (tmp1 := AST.cast CastKind.IntToFloat 64<rt> oprExpr)
  !!ir (!.ctxt R.FSWC0 := AST.flt tmp0 tmp1)
  !!ir (!.ctxt R.FSWC2 := AST.b0)
  !!ir (!.ctxt R.FSWC3 := tmp0 == tmp1)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  if doPop then !?ir (popFPUStack ctxt) else ()
  !>ir insLen

let fcomi ins insLen ctxt doPop =
  let ir = IRBuilder (64)
  let zf = !.ctxt R.ZF
  let pf = !.ctxt R.PF
  let cf = !.ctxt R.CF
  !<ir insLen
  let struct (tmp0, tmp1) = prepareTwoOprsForComparison ins insLen ctxt ir
  !!ir (cf := AST.flt tmp0 tmp1)
  !!ir (pf := AST.b0)
  !!ir (zf := (tmp0 == tmp1))
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  if doPop then !?ir (popFPUStack ctxt) else ()
  !>ir insLen

let ftst _ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let num0V = AST.num0 64<rt>
  let c0 = !.ctxt R.FSWC0
  let c2 = !.ctxt R.FSWC2
  let c3 = !.ctxt R.FSWC3
  let tmp = !*ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp 64<rt> st0b st0a)
  !!ir (c0 := AST.flt tmp num0V)
  !!ir (c2 := AST.b0)
  !!ir (c3 := tmp == num0V)
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !>ir insLen

let fxam _ins insLen ctxt =
  let ir = IRBuilder (8)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let n7fff = numI32 0x7fff 16<rt>
  let exponent = st0b .& n7fff
  let nanCond = (exponent == n7fff) .& (AST.xtlo 62<rt> st0a != AST.num0 62<rt>)
  let c3Cond1 = (exponent == AST.num0 16<rt>)
  let isAllZero = (st0a == AST.num0 64<rt>) .& (st0b == AST.num0 16<rt>)
  let c2Cond0 = AST.not (isAllZero .| nanCond)
  let c0Cond1 = (exponent == n7fff)
  !<ir insLen
  !!ir (!.ctxt R.FSWC1 := AST.xthi 1<rt> st0b)
  !!ir (!.ctxt R.FSWC3 := c3Cond1)
  !!ir (!.ctxt R.FSWC2 := c2Cond0)
  !!ir (!.ctxt R.FSWC0 := c0Cond1)
  !>ir insLen

let private checkForTrigFunction unsigned lin lout ir =
  let maxLimit = numI64 (1L <<< 63) 64<rt>
  let maxFloat = AST.cast CastKind.IntToFloat 64<rt> maxLimit
  !!ir (AST.cjmp (AST.flt unsigned maxFloat) (AST.name lin) (AST.name lout))

let private ftrig _ins insLen ctxt trigFunc =
  let ir = IRBuilder (32)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let n7fff = numI32 0x7fff 16<rt>
  let c0 = !.ctxt R.FSWC0
  let c1 = !.ctxt R.FSWC1
  let c2 = !.ctxt R.FSWC2
  let c3 = !.ctxt R.FSWC3
  let lin = ir.NewSymbol "IsInRange"
  let lout = ir.NewSymbol "IsOutOfRange"
  let lexit = ir.NewSymbol "Exit"
  let struct (unsigned, signed, tmp) = tmpVars3 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit unsigned 64<rt> (st0b .& n7fff) st0a)
  !?ir (castFrom80Bit signed 64<rt> st0b st0a)
  !?ir (checkForTrigFunction unsigned lin lout)
  !!ir (AST.lmark lin)
  !!ir (tmp := trigFunc signed)
  !?ir (castTo80Bit ctxt st0b st0a tmp)
  !!ir (c2 := AST.b0)
  !!ir (AST.jmp (AST.name lexit))
  !!ir (AST.lmark lout)
  !!ir (c2 := AST.b1)
  !!ir (AST.lmark lexit)
  !!ir (c0 := undefC0)
  !!ir (c3 := undefC3)
  !!ir (c1:= AST.b0)
  !>ir insLen

let fsin ins insLen ctxt =
  ftrig ins insLen ctxt AST.fsin

let fcos ins insLen ctxt =
  ftrig ins insLen ctxt AST.fcos

let fsincos _ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let n7fff = numI32 0x7fff 16<rt>
  let c0 = !.ctxt R.FSWC0
  let c2 = !.ctxt R.FSWC2
  let c3 = !.ctxt R.FSWC3
  let lin = ir.NewSymbol "IsInRange"
  let lout = ir.NewSymbol "IsOutOfRange"
  let lexit = ir.NewSymbol "Exit"
  let struct (unsigned, signed, tmpsin, tmpcos) = tmpVars4 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit unsigned 64<rt> (st0b .& n7fff) st0a)
  !?ir (castFrom80Bit signed 64<rt> st0b st0a)
  !?ir (checkForTrigFunction unsigned lin lout)
  !!ir (AST.lmark lin)
  !!ir (tmpcos := AST.fcos signed)
  !!ir (tmpsin := AST.fsin signed)
  !?ir (castTo80Bit ctxt st0b st0a tmpsin)
  !?ir (pushFPUStack ctxt)
  !?ir (castTo80Bit ctxt st0b st0a tmpcos)
  !!ir (c2 := AST.b0)
  !!ir (AST.jmp (AST.name lexit))
  !!ir (AST.lmark lout)
  !!ir (c2 := AST.b1)
  !!ir (AST.lmark lexit)
  !!ir (c0 := undefC0)
  !!ir (c3 := undefC3)
  !?ir (updateC1OnLoad ctxt)
  !>ir insLen

let fptan _ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let n7fff = numI32 0x7fff 16<rt>
  let c0 = !.ctxt R.FSWC0
  let c2 = !.ctxt R.FSWC2
  let c3 = !.ctxt R.FSWC3
  let lin = ir.NewSymbol "IsInRange"
  let lout = ir.NewSymbol "IsOutOfRange"
  let lexit = ir.NewSymbol "Exit"
  let fone = numI64 0x3ff0000000000000L 64<rt> (* 1.0 *)
  let struct (unsigned, signed, tmp) = tmpVars3 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit unsigned 64<rt> (st0b .& n7fff) st0a)
  !?ir (castFrom80Bit signed 64<rt> st0b st0a)
  !?ir (checkForTrigFunction unsigned lin lout)
  !!ir (AST.lmark lin)
  !!ir (tmp := AST.ftan signed)
  !?ir (castTo80Bit ctxt st0b st0a tmp)
  !!ir (c2 := AST.b0)
  !?ir (pushFPUStack ctxt)
  !?ir (castTo80Bit ctxt st0b st0a fone)
  !!ir (c2 := AST.b0)
  !!ir (AST.jmp (AST.name lexit))
  !!ir (AST.lmark lout)
  !!ir (c2 := AST.b1)
  !!ir (AST.lmark lexit)
  !!ir (c0 := undefC0)
  !!ir (c3 := undefC3)
  !?ir (updateC1OnLoad ctxt)
  !>ir insLen

let fpatan _ins insLen ctxt =
  let ir = IRBuilder (16)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
  let struct (tmp0, tmp1, res) = tmpVars3 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  !!ir (res := AST.fatan (AST.fdiv tmp0 tmp1))
  !?ir (castTo80Bit ctxt st1b st1a res)
  !?ir (popFPUStack ctxt)
  !?ir (updateC1OnStore ctxt)
  !?ir (cflagsUndefined023 ctxt)
  !>ir insLen

let f2xm1 _isn insLen ctxt =
  let ir = IRBuilder (16)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let f1 = numI32 1 64<rt> |> castToF64
  let f2 = numI32 2 64<rt> |> castToF64
  let c1 = !.ctxt R.FSWC1
  let struct (tmp, res) = tmpVars2 ir 64<rt>
  !<ir insLen
  !?ir (castFrom80Bit tmp 64<rt> st0b st0a)
  !!ir (res := AST.fsub (AST.fpow f2 tmp) f1)
  !?ir (castTo80Bit ctxt st0b st0a res)
  !!ir (c1 := AST.b0)
  !?ir (cflagsUndefined023 ctxt)
  !>ir insLen

let fyl2x _ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
  let struct (tmp0, tmp1, res) = tmpVars3 ir 64<rt>
  let f2 = numI32 2 64<rt> |> castToF64
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  !!ir (res := AST.fmul tmp1 (AST.flog f2 tmp0))
  !?ir (castTo80Bit ctxt st1b st1a res)
  !?ir (popFPUStack ctxt)
  !?ir (updateC1OnStore ctxt)
  !?ir (cflagsUndefined023 ctxt)
  !>ir insLen

let fyl2xp1 _ins insLen ctxt =
  let ir = IRBuilder (64)
  let struct (st0b, st0a) = getFPUPseudoRegVars ctxt R.ST0
  let struct (st1b, st1a) = getFPUPseudoRegVars ctxt R.ST1
  let struct (tmp0, tmp1, res) = tmpVars3 ir 64<rt>
  let f1 = numI32 1 64<rt> |> castToF64
  let f2 = numI32 2 64<rt> |> castToF64
  !<ir insLen
  !?ir (castFrom80Bit tmp0 64<rt> st0b st0a)
  !?ir (castFrom80Bit tmp1 64<rt> st1b st1a)
  !!ir (res := AST.fmul tmp1 (AST.flog f2 (AST.fadd tmp0 f1)))
  !?ir (castTo80Bit ctxt st1b st1a res)
  !?ir (popFPUStack ctxt)
  !?ir (updateC1OnStore ctxt)
  !?ir (cflagsUndefined023 ctxt)
  !>ir insLen

let fld1 _ins insLen ctxt =
  let oprExpr = numU64 0x3FF0000000000000UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldz _ins insLen ctxt =
  let oprExpr = AST.num0 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldpi _ins insLen ctxt =
  let oprExpr = numU64 4614256656552045848UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldl2e _ins insLen ctxt =
  let oprExpr = numU64 4599094494223104509UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldln2 _ins insLen ctxt =
  let oprExpr = numU64 4604418534313441775UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldl2t _ins insLen ctxt =
  let oprExpr = numU64 4614662735865160561UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fldlg2 _ins insLen ctxt =
  let oprExpr = numU64 4599094494223104511UL 64<rt>
  fpuLoad insLen ctxt oprExpr

let fincstp _ins insLen ctxt =
  let ir = IRBuilder (16)
  let top = !.ctxt R.FTOP
  !<ir insLen
  (* TOP in B2R2 is really a counter, so we decrement TOP here (same as pop). *)
  !!ir (extractDstAssign top (top .- AST.num1 8<rt>))
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let fdecstp _ins insLen ctxt =
  let ir = IRBuilder (8)
  let top = !.ctxt R.FTOP
  !<ir insLen
  (* TOP in B2R2 is really a counter, so we increment TOP here. *)
  !!ir (extractDstAssign top (top .+ AST.num1 8<rt>))
  !!ir (!.ctxt R.FSWC1 := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let ffree (ins: InsInfo) insLen ctxt =
  let ir = IRBuilder (8)
  let top = !.ctxt R.FTOP
  let tagWord = !.ctxt R.FTW
  let struct (top16, shifter, tagValue) = tmpVars3 ir 16<rt>
  let value3 = numI32 3 16<rt>
  let offset =
    match ins.Operands with
    | OneOperand (OprReg R.ST0) -> numI32 0 16<rt>
    | OneOperand (OprReg R.ST1) -> numI32 1 16<rt>
    | OneOperand (OprReg R.ST2) -> numI32 2 16<rt>
    | OneOperand (OprReg R.ST3) -> numI32 3 16<rt>
    | OneOperand (OprReg R.ST4) -> numI32 4 16<rt>
    | OneOperand (OprReg R.ST5) -> numI32 5 16<rt>
    | OneOperand (OprReg R.ST6) -> numI32 6 16<rt>
    | OneOperand (OprReg R.ST7) -> numI32 7 16<rt>
    | _ -> raise InvalidOperandException
  !<ir insLen
  !!ir (top16 := AST.cast CastKind.ZeroExt 16<rt> top)
  !!ir (top16 := top16 .+ offset)
  !!ir (shifter := (numI32 2 16<rt>) .* top16)
  !!ir (tagValue := (value3 << shifter))
  !!ir (tagWord := tagWord .| tagValue)
  !>ir insLen

(* FIXME: check all unmasked pending floating point exceptions. *)
let private checkFPUExceptions ctxt ir = ()

let private clearFPU ctxt ir =
  let cw = numI32 895 16<rt>
  let tw = BitVector.maxUInt16 |> AST.num
  !!ir (!.ctxt R.FCW := cw)
  !!ir (!.ctxt R.FSW := AST.num0 16<rt>)
  !!ir (!.ctxt R.FTW := tw)

let finit _ins insLen ctxt =
  let ir = IRBuilder (32)
  !<ir insLen
  checkFPUExceptions ctxt ir
  clearFPU ctxt ir
  !>ir insLen

let fninit _ins insLen ctxt =
  let ir = IRBuilder (16)
  !<ir insLen
  clearFPU ctxt ir
  !>ir insLen

let fclex _ins insLen ctxt =
  let ir = IRBuilder (8)
  let stsWrd = !.ctxt R.FSW
  !<ir insLen
  !!ir (AST.xtlo 7<rt> stsWrd := AST.num0 7<rt>)
  !!ir (AST.xthi 1<rt> stsWrd := AST.b0)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC1 := undefC1)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let fstcw ins insLen ctxt =
  let ir = IRBuilder (16)
  let oprExpr = transOneOpr ins insLen ctxt
  !<ir insLen
  checkFPUExceptions ctxt ir
  !!ir (oprExpr := !.ctxt R.FCW)
  allCFlagsUndefined ctxt ir
  !>ir insLen

let fnstcw ins insLen ctxt =
  let ir = IRBuilder (8)
  let oprExpr = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (oprExpr := !.ctxt R.FCW)
  allCFlagsUndefined ctxt ir
  !>ir insLen

let fldcw ins insLen ctxt =
  let ir = IRBuilder (8)
  let oprExpr = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (!.ctxt R.FCW := oprExpr)
  !!ir (!.ctxt R.FSWC0 := undefC0)
  !!ir (!.ctxt R.FSWC1 := undefC1)
  !!ir (!.ctxt R.FSWC2 := undefC2)
  !!ir (!.ctxt R.FSWC3 := undefC3)
  !>ir insLen

let private m14fstenv dstAddr addrSize ctxt ir =
  let fiplo = AST.xtlo 16<rt> (!.ctxt R.FIP)
  let fdplo = AST.xtlo 16<rt> (!.ctxt R.FDP)
  !!ir (AST.store Endian.Little (dstAddr) (!.ctxt R.FCW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 2 addrSize) (!.ctxt R.FSW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 4 addrSize) (!.ctxt R.FTW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 6 addrSize) fiplo)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 8 addrSize) (!.ctxt R.FCS))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 10 addrSize) fdplo)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 12 addrSize) (!.ctxt R.FDS))

let private m28fstenv dstAddr addrSize ctxt ir =
  let n0 = numI32 0 16<rt>
  !!ir (AST.store Endian.Little (dstAddr) (!.ctxt R.FCW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 2 addrSize) n0)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 4 addrSize) (!.ctxt R.FSW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 6 addrSize) n0)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 8 addrSize) (!.ctxt R.FTW))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 10 addrSize) n0)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 12 addrSize) (!.ctxt R.FIP))
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 20 addrSize) (!.ctxt R.FDP))

let fnstenv ins insLen ctxt =
  let ir = IRBuilder (16)
  let dst = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr dst
  !<ir insLen
  match TypeCheck.typeOf dst with
  | 112<rt> -> m14fstenv addrExpr addrSize ctxt ir
  | 224<rt> -> m28fstenv addrExpr addrSize ctxt ir
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private m14fldenv srcAddr addrSize ctxt ir =
  !!ir (!.ctxt R.FCW := AST.loadLE 16<rt> (srcAddr))
  !!ir (!.ctxt R.FSW := AST.loadLE 16<rt> (srcAddr .+ numI32 2 addrSize))
  !!ir (!.ctxt R.FTW := AST.loadLE 16<rt> (srcAddr .+ numI32 4 addrSize))
  !!ir (AST.xtlo 16<rt> (!.ctxt R.FIP) :=
    AST.loadLE 16<rt> (srcAddr .+ numI32 6 addrSize))
  !!ir (!.ctxt R.FCS := AST.loadLE 16<rt> (srcAddr .+ numI32 8 addrSize))
  !!ir (AST.xtlo 16<rt> (!.ctxt R.FDP) :=
    AST.loadLE 16<rt> (srcAddr .+ numI32 10 addrSize))
  !!ir (!.ctxt R.FDS := AST.loadLE 16<rt> (srcAddr .+ numI32 12 addrSize))

let private m28fldenv srcAddr addrSize ctxt ir =
  !!ir (!.ctxt R.FCW := AST.loadLE 16<rt> (srcAddr))
  !!ir (!.ctxt R.FSW := AST.loadLE 16<rt> (srcAddr .+ numI32 4 addrSize))
  !!ir (!.ctxt R.FTW := AST.loadLE 16<rt> (srcAddr .+ numI32 8 addrSize))
  !!ir (!.ctxt R.FIP := AST.loadLE 64<rt> (srcAddr .+ numI32 12 addrSize))
  !!ir (!.ctxt R.FDP := AST.loadLE 64<rt> (srcAddr .+ numI32 20 addrSize))

let fldenv ins insLen ctxt =
  let ir = IRBuilder (16)
  let src = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr src
  !<ir insLen
  match TypeCheck.typeOf src with
  | 112<rt> -> m14fldenv addrExpr addrSize ctxt ir
  | 224<rt> -> m28fldenv addrExpr addrSize ctxt ir
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let private stSts dstAddr addrSize offset ctxt ir =
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST0
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 8) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST1
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 10) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 18) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST2
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 20) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 28) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST3
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 30) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 38) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST4
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 40) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 48) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST5
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 50) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 58) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST6
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 60) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 68) addrSize) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST7
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 70) addrSize) sta)
  !!ir (AST.store Endian.Little (dstAddr .+ numI32 (offset + 78) addrSize) stb)

let fnsave ins insLen ctxt =
  let ir = IRBuilder (32)
  let dst = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr dst
  !<ir insLen
  match TypeCheck.typeOf dst with
  | 752<rt> ->
    m14fstenv addrExpr addrSize ctxt ir
    stSts addrExpr addrSize 14 ctxt ir
  | 864<rt> ->
    m28fstenv addrExpr addrSize ctxt ir
    stSts addrExpr addrSize 28 ctxt ir
  | _ -> raise InvalidOperandSizeException
  !!ir (!.ctxt R.FCW := numI32 0x037F 16<rt>)
  !!ir (!.ctxt R.FSW := AST.num0 16<rt>)
  !!ir (!.ctxt R.FTW := numI32 0xFFFF 16<rt>)
  !!ir (!.ctxt R.FDP := AST.num0 64<rt>)
  !!ir (!.ctxt R.FIP := AST.num0 64<rt>)
  !!ir (!.ctxt R.FOP := AST.num0 16<rt>)
  !>ir insLen

let private ldSts srcAddr addrSize offset ctxt ir =
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST0
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 8) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST1
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 10) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 18) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST2
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 20) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 28) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST3
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 30) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 38) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST4
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 40) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 48) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST5
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 50) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 58) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST6
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 60) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 68) addrSize))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST7
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ numI32 (offset + 70) addrSize))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ numI32 (offset + 78) addrSize))

let frstor ins insLen ctxt =
  let ir = IRBuilder (32)
  let src = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr src
  !<ir insLen
  match TypeCheck.typeOf src with
  | 752<rt> ->
    m14fldenv addrExpr addrSize ctxt ir
    ldSts addrExpr addrSize 14 ctxt ir
  | 864<rt> ->
    m28fldenv addrExpr addrSize ctxt ir
    ldSts addrExpr addrSize 28 ctxt ir
  | _ -> raise InvalidOperandSizeException
  !>ir insLen

let fnstsw ins insLen ctxt =
  let ir = IRBuilder (8)
  let oprExpr = transOneOpr ins insLen ctxt
  !<ir insLen
  !!ir (oprExpr := !.ctxt R.FSW)
  allCFlagsUndefined ctxt ir
  !>ir insLen

let wait _ins insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  checkFPUExceptions ctxt ir
  !>ir insLen

let fnop _ins insLen ctxt =
  let ir = IRBuilder (8)
  !<ir insLen
  allCFlagsUndefined ctxt ir
  !>ir insLen

let inline private storeLE addr v =
  AST.store Endian.Little addr v

let private fxsaveInternal ctxt dstAddr addrSize is64bit ir =
  !!ir (storeLE (dstAddr) (!.ctxt R.FCW))
  !!ir (storeLE (dstAddr .+ (numI32 2 addrSize)) (!.ctxt R.FSW))
  !!ir (storeLE (dstAddr .+ (numI32 4 addrSize)) (!.ctxt R.FTW))
  !!ir (storeLE (dstAddr .+ (numI32 6 addrSize)) (!.ctxt R.FOP))
  !!ir (storeLE (dstAddr .+ (numI32 8 addrSize)) (!.ctxt R.FIP))
  !!ir (storeLE (dstAddr .+ (numI32 16 addrSize)) (!.ctxt R.FDP))
  !!ir (storeLE (dstAddr .+ (numI32 24 addrSize)) (!.ctxt R.MXCSR))
  !!ir (storeLE (dstAddr .+ (numI32 28 addrSize)) (!.ctxt R.MXCSRMASK))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST0
  !!ir (storeLE (dstAddr .+ (numI32 32 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 40 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST1
  !!ir (storeLE (dstAddr .+ (numI32 48 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 56 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST2
  !!ir (storeLE (dstAddr .+ (numI32 64 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 72 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST3
  !!ir (storeLE (dstAddr .+ (numI32 80 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 88 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST4
  !!ir (storeLE (dstAddr .+ (numI32 96 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 104 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST5
  !!ir (storeLE (dstAddr .+ (numI32 112 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 120 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST6
  !!ir (storeLE (dstAddr .+ (numI32 128 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 136 addrSize)) stb)
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST7
  !!ir (storeLE (dstAddr .+ (numI32 144 addrSize)) sta)
  !!ir (storeLE (dstAddr .+ (numI32 152 addrSize)) stb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM0
  !!ir (storeLE (dstAddr .+ (numI32 160 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 168 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM1
  !!ir (storeLE (dstAddr .+ (numI32 176 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 184 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM2
  !!ir (storeLE (dstAddr .+ (numI32 192 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 200 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM3
  !!ir (storeLE (dstAddr .+ (numI32 208 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 216 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM4
  !!ir (storeLE (dstAddr .+ (numI32 224 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 232 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM5
  !!ir (storeLE (dstAddr .+ (numI32 240 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 248 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM6
  !!ir (storeLE (dstAddr .+ (numI32 256 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 264 addrSize)) xmmb)
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM7
  !!ir (storeLE (dstAddr .+ (numI32 272 addrSize)) xmma)
  !!ir (storeLE (dstAddr .+ (numI32 280 addrSize)) xmmb)
  if is64bit then
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM8
    !!ir (storeLE (dstAddr .+ (numI32 288 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 296 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM9
    !!ir (storeLE (dstAddr .+ (numI32 304 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 312 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM10
    !!ir (storeLE (dstAddr .+ (numI32 320 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 328 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM11
    !!ir (storeLE (dstAddr .+ (numI32 336 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 344 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM12
    !!ir (storeLE (dstAddr .+ (numI32 352 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 360 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM13
    !!ir (storeLE (dstAddr .+ (numI32 368 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 376 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM14
    !!ir (storeLE (dstAddr .+ (numI32 384 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 392 addrSize)) xmmb)
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM15
    !!ir (storeLE (dstAddr .+ (numI32 400 addrSize)) xmma)
    !!ir (storeLE (dstAddr .+ (numI32 408 addrSize)) xmmb)
  else ()

let fxsave ins insLen ctxt =
  let ir = IRBuilder (128)
  let dst = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr dst
  !<ir insLen
  !?ir (fxsaveInternal ctxt addrExpr addrSize (ctxt.WordBitSize = 64<rt>))
  !>ir insLen

let private fxrstoreInternal ctxt srcAddr addrSz is64bit ir =
  !!ir (!.ctxt R.FCW := AST.loadLE 16<rt> (srcAddr))
  !!ir (!.ctxt R.FSW := AST.loadLE 16<rt> (srcAddr .+ (numI32 2 addrSz)))
  !!ir (!.ctxt R.FTW := AST.loadLE 16<rt> (srcAddr .+ (numI32 4 addrSz)))
  !!ir (!.ctxt R.FOP := AST.loadLE 16<rt> (srcAddr .+ (numI32 6 addrSz)))
  !!ir (!.ctxt R.FIP := AST.loadLE 64<rt> (srcAddr .+ (numI32 8 addrSz)))
  !!ir (!.ctxt R.FDP := AST.loadLE 64<rt> (srcAddr .+ (numI32 16 addrSz)))
  !!ir (!.ctxt R.MXCSR := AST.loadLE 32<rt> (srcAddr .+ (numI32 24 addrSz)))
  !!ir (!.ctxt R.MXCSRMASK := AST.loadLE 32<rt> (srcAddr .+ (numI32 28 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST0
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 32 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 40 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST1
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 48 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 56 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST2
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 64 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 72 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST3
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 80 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 88 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST4
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 96 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 104 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST5
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 112 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 120 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST6
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 128 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 136 addrSz)))
  let struct (stb, sta) = getFPUPseudoRegVars ctxt R.ST7
  !!ir (sta := AST.loadLE 64<rt> (srcAddr .+ (numI32 144 addrSz)))
  !!ir (stb := AST.loadLE 16<rt> (srcAddr .+ (numI32 152 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM0
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 160 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 168 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM1
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 176 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 184 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM2
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 192 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 200 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM3
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 208 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 216 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM4
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 224 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 232 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM5
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 240 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 248 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM6
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 256 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 264 addrSz)))
  let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM7
  !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 272 addrSz)))
  !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 280 addrSz)))
  if is64bit then
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM8
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 288 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 296 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM9
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 304 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 312 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM10
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 320 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 328 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM11
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 336 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 344 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM12
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 352 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 360 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM13
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 368 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 376 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM14
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 384 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 392 addrSz)))
    let xmmb, xmma = getPseudoRegVar128 ctxt R.XMM15
    !!ir (xmma := AST.loadLE 64<rt> (srcAddr .+ (numI32 400 addrSz)))
    !!ir (xmmb := AST.loadLE 64<rt> (srcAddr .+ (numI32 408 addrSz)))
  else ()

let fxrstor ins insLen ctxt =
  let ir = IRBuilder (128)
  let src = transOneOpr ins insLen ctxt
  let struct (addrExpr, addrSize) = getLoadAddressExpr src
  !<ir insLen
  !?ir (fxrstoreInternal ctxt addrExpr addrSize (ctxt.WordBitSize = 64<rt>))
  !>ir insLen

